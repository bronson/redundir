#!/usr/bin/env python3
"""
redundir-tui - Interactive TUI for exploring redundant directories

This provides a split-pane interface for browsing duplicate files:
- Top pane: List of directories with redundancy scores
- Bottom pane: Related directories and duplicate files for selected directory
"""

import curses
import sys
import os
from pathlib import Path

# Import core functions from redundir by loading it directly
def load_redundir():
    """Load redundir module from same directory or PATH."""
    import types

    # Try to find redundir in same directory as this script
    # Check multiple possible locations
    possible_paths = [
        Path(__file__).parent / "redundir",  # Same directory
        Path.cwd() / "redundir",  # Current working directory
        Path(sys.argv[0]).parent / "redundir",  # Script directory from argv
    ]

    for redundir_path in possible_paths:
        if redundir_path.exists() and redundir_path.is_file():
            try:
                # Read and execute the file directly since it has no .py extension
                with open(redundir_path, 'r') as f:
                    code = f.read()

                # Create a module to hold the executed code
                redundir = types.ModuleType('redundir')
                redundir.__file__ = str(redundir_path)
                sys.modules['redundir'] = redundir

                # Execute the code in the module's namespace
                exec(code, redundir.__dict__)

                # Verify required functions exist
                if hasattr(redundir, 'find_duplicates') and hasattr(redundir, 'calculate_redundancy_score'):
                    return redundir
            except Exception as e:
                print(f"Error loading {redundir_path}: {e}", file=sys.stderr)
                continue

    # Try regular import as fallback
    try:
        import redundir
        return redundir
    except ImportError:
        pass

    print("Error: Could not find redundir script", file=sys.stderr)
    print("Tried locations:", file=sys.stderr)
    for p in possible_paths:
        print(f"  {p} (exists: {p.exists()})", file=sys.stderr)
    sys.exit(1)

redundir_module = load_redundir()
find_duplicates = redundir_module.find_duplicates
calculate_redundancy_score = redundir_module.calculate_redundancy_score


class RedundirTUI:
    def __init__(self, root_paths, algorithm='blake2b', jobs=4):
        # Normalize to list
        if isinstance(root_paths, (str, Path)):
            root_paths = [root_paths]
        self.root_paths = [Path(p).resolve() for p in root_paths]
        self.algorithm = algorithm
        self.jobs = jobs
        self.selected_idx = 0
        self.top_offset = 0
        self.bottom_offset = 0
        self.bottom_selected_idx = 0
        self.active_pane = 'top'  # 'top' or 'bottom'
        self.last_bottom_dir_idx = None  # Track which directory's details we're showing
        self.show_quit_message = False  # Show "press q to quit" message
        self.navigation_stack = []  # Stack of directory indices for back navigation
        self.selected_file = None  # Currently selected file for filtering top pane
        self.current_filtered_dirs = []  # Filtered directory list when a file is selected
        self.current_bottom_dir = None  # The directory whose files are shown in bottom pane (doesn't change when navigating within bottom pane)

        # Data will be populated by scan()
        self.sorted_dirs = []
        self.dir_stats = {}
        self.file_to_hash = {}
        self.hash_to_dirs = {}
        self.dir_all_files = {}
        self.total_duplicates = 0
        self.total_files = 0

    def scan(self, quiet=False):
        """Scan the directory tree for duplicates."""
        result = find_duplicates(
            self.root_paths,
            algorithm=self.algorithm,
            jobs=self.jobs,
            quiet=quiet
        )
        self.dir_stats, self.total_duplicates, self.total_files, \
            self.file_to_hash, self.hash_to_dirs, self.dir_all_files = result

        # Sort directories by redundancy score
        self.sorted_dirs = sorted(
            self.dir_stats.items(),
            key=lambda x: (-calculate_redundancy_score(x[1][0], x[1][1]), str(x[0]))
        )

    def get_relative_path(self, path):
        """Convert absolute path to relative display path."""
        # Try each root path
        for root_path in self.root_paths:
            try:
                rel = path.relative_to(root_path)
                display = str(root_path.name / rel) if str(rel) != '.' else str(root_path.name)
                return display
            except ValueError:
                continue
        # If not relative to any root, use absolute path
        return str(path)

    def get_related_dirs(self, dir_path):
        """Get related directories and their hypothetical redundancy scores."""
        # Find all hashes in this directory
        dir_hashes = set()
        for fpath in self.dir_all_files.get(dir_path, []):
            if fpath in self.file_to_hash:
                dir_hashes.add(self.file_to_hash[fpath])

        # Find related directories
        related_dirs = set()
        for h in dir_hashes:
            for d in self.hash_to_dirs[h]:
                if d != dir_path:
                    related_dirs.add(d)

        # Calculate hypothetical redundancy
        related_info = []
        for related_dir in related_dirs:
            related_files = self.dir_all_files.get(related_dir, [])
            total_related = len(related_files)

            hypothetical_duplicates = 0
            for fpath in related_files:
                if fpath in self.file_to_hash:
                    h = self.file_to_hash[fpath]
                    other_dirs = self.hash_to_dirs[h] - {dir_path, related_dir}
                    if len(other_dirs) > 0:
                        hypothetical_duplicates += 1

            hyp_score = calculate_redundancy_score(hypothetical_duplicates, total_related)
            rel_display = self.get_relative_path(related_dir)
            related_info.append((hyp_score, hypothetical_duplicates, total_related, rel_display))

        # Sort by hypothetical redundancy score
        related_info.sort(key=lambda x: (-x[0], str(x[3])))
        return related_info

    def get_duplicate_files(self, dir_path):
        """Get list of duplicate files in the directory."""
        dup_files = []
        for fpath in self.dir_all_files.get(dir_path, []):
            if fpath in self.file_to_hash:
                dup_files.append(fpath.name)
        return sorted(dup_files)

    def get_all_files_with_counts(self, dir_path):
        """Get list of all files in directory with count of dirs containing each.

        Returns list of (filename, dir_count, file_path) tuples, sorted by
        dir_count descending (most duplicated first), then by filename.
        """
        file_info = []
        for fpath in self.dir_all_files.get(dir_path, []):
            fname = fpath.name
            # Count how many directories contain this file (by hash)
            if fpath in self.file_to_hash:
                fhash = self.file_to_hash[fpath]
                dir_count = len(self.hash_to_dirs.get(fhash, set()))
            else:
                # Unique file (not hashed, only in this directory)
                dir_count = 1
            file_info.append((fname, dir_count, fpath))

        # Sort by count descending, then by filename
        file_info.sort(key=lambda x: (-x[1], x[0]))
        return file_info

    def get_dirs_containing_file(self, file_path):
        """Get list of directories that contain the given file (by hash)."""
        if file_path not in self.file_to_hash:
            # Unique file, only in its own directory
            return [file_path.parent]

        fhash = self.file_to_hash[file_path]
        return list(self.hash_to_dirs.get(fhash, set()))

    def get_filename_in_dir(self, file_path, dir_path):
        """Get the actual filename for a file's hash in a specific directory.

        Since duplicate files can have different names in different directories,
        we need to look up the actual filename in each directory.
        """
        if file_path not in self.file_to_hash:
            # Unique file, just return its name
            return file_path.name

        fhash = self.file_to_hash[file_path]

        # Search through all files in the target directory for one with matching hash
        for fpath in self.dir_all_files.get(dir_path, []):
            if fpath in self.file_to_hash and self.file_to_hash[fpath] == fhash:
                return fpath.name

        # Fallback to original filename if not found
        return file_path.name

    def draw_top_pane(self, win, height, width):
        """Draw the directory list in the top pane."""
        win.clear()

        # Border with highlight if active
        if self.active_pane == 'top':
            win.attron(curses.A_BOLD)
        win.border()
        if self.active_pane == 'top':
            win.attroff(curses.A_BOLD)

        # Determine which directories to show (filter if a file is selected)
        if self.selected_file:
            # Show only directories containing the selected file
            dirs_to_show = self.get_dirs_containing_file(self.selected_file)
            filtered_dirs = [(dp, stats) for dp, stats in self.sorted_dirs if dp in dirs_to_show]
            title = f" Directories containing {self.selected_file.name} ({len(filtered_dirs)}) "
        else:
            # Show all directories with redundancy
            filtered_dirs = self.sorted_dirs
            title = f" Directories with Redundancy ({len(filtered_dirs)}) "

        # Store filtered dirs for navigation
        self.current_filtered_dirs = filtered_dirs

        title_attr = curses.A_BOLD | curses.A_REVERSE if self.active_pane == 'top' else curses.A_BOLD
        win.addstr(0, 2, title[:width-4], title_attr)

        # Show quit message if needed
        if self.show_quit_message:
            msg = " Press 'q' to quit "
            try:
                win.addstr(height - 1, width - len(msg) - 1, msg, curses.A_REVERSE | curses.A_BOLD)
            except curses.error:
                pass

        if not filtered_dirs:
            win.addstr(1, 1, "No directories to display")
            win.refresh()
            return

        # Calculate column width for count
        max_count_width = max(
            len(f"{dup}/{total}")
            for _, (dup, total) in filtered_dirs
        ) if filtered_dirs else 3

        # Display directories
        display_height = height - 2
        for i in range(display_height):
            idx = self.top_offset + i
            if idx >= len(filtered_dirs):
                break

            dir_path, (duplicates, total) = filtered_dirs[idx]
            score = calculate_redundancy_score(duplicates, total)
            rel_path = self.get_relative_path(dir_path)

            # Format line - include filename if filtering by file
            percent_str = f"{score:7.2%}"
            count_str = f"{duplicates}/{total}".rjust(max_count_width)
            if self.selected_file:
                # Show directory/filename when filtering
                # Get the actual filename in this directory (may differ from selected file's name)
                actual_filename = self.get_filename_in_dir(self.selected_file, dir_path)
                line = f"{percent_str}  {count_str}  {rel_path}/{actual_filename}"
            else:
                line = f"{percent_str}  {count_str}  {rel_path}"

            # Truncate if too long
            max_len = width - 3
            if len(line) > max_len:
                line = line[:max_len-3] + "..."

            y = i + 1
            if idx == self.selected_idx:
                attr = curses.A_REVERSE
            else:
                attr = curses.A_NORMAL
            win.addstr(y, 1, line.ljust(width - 2), attr)

        win.refresh()

    def draw_bottom_pane(self, win, height, width):
        """Draw the details for selected directory in the bottom pane."""
        win.clear()

        # Border with highlight if active
        if self.active_pane == 'bottom':
            win.attron(curses.A_BOLD)
        win.border()
        if self.active_pane == 'bottom':
            win.attroff(curses.A_BOLD)

        if not self.sorted_dirs:
            win.addstr(1, 1, "No duplicate files found.")
            win.refresh()
            return

        # Use current_bottom_dir if set, otherwise use selected directory from sorted_dirs
        if self.current_bottom_dir is not None:
            dir_path = self.current_bottom_dir
            # Find the stats for this directory
            duplicates, total = 0, 0
            for dp, (d, t) in self.sorted_dirs:
                if dp == dir_path:
                    duplicates, total = d, t
                    break
        else:
            dir_path, (duplicates, total) = self.sorted_dirs[self.selected_idx]
        rel_path = self.get_relative_path(dir_path)

        # Title
        title = f" Files in: {rel_path} "
        if len(title) > width - 4:
            title = " " + title[-(width-5):] + " "
        title_attr = curses.A_BOLD | curses.A_REVERSE if self.active_pane == 'bottom' else curses.A_BOLD
        win.addstr(0, 2, title, title_attr)

        # Get related directories and all files with counts
        related_dirs = self.get_related_dirs(dir_path)
        all_files = self.get_all_files_with_counts(dir_path)

        # Calculate max count width for alignment
        max_count_width = 3
        if related_dirs:
            max_count_width = max(max_count_width, max(
                len(f"{dup}/{total}")
                for _, dup, total, _ in related_dirs
            ))
        if all_files:
            max_file_count_width = max(len(str(count)) for _, count, _ in all_files)
            max_count_width = max(max_count_width, max_file_count_width)

        lines = []
        selectable_indices = []  # Track which line indices are selectable
        line_to_dir = {}  # Map line index to directory index for related directories
        line_to_file = {}  # Map line index to file path

        # Related directories section
        if related_dirs:
            lines.append(("Related directories (if this dir didn't exist):", curses.A_BOLD))
            for hyp_score, hyp_dup, hyp_total, rel_display in related_dirs:
                percent_str = f"{hyp_score:7.2%}"
                count_str = f"{hyp_dup}/{hyp_total}".rjust(max_count_width)
                line = f"  {percent_str}  {count_str}  {rel_display}"
                line_idx = len(lines)
                selectable_indices.append(line_idx)
                # Store the actual directory path for this line
                for idx, (dp, _) in enumerate(self.sorted_dirs):
                    if self.get_relative_path(dp) == rel_display:
                        line_to_dir[line_idx] = idx
                        break
                lines.append((line, curses.A_NORMAL))
            lines.append(("", curses.A_NORMAL))

        # Files section - show all files with directory count
        if all_files:
            lines.append((f"Files ({len(all_files)}):", curses.A_BOLD))
            for fname, dir_count, fpath in all_files:
                line_idx = len(lines)
                selectable_indices.append(line_idx)
                line_to_file[line_idx] = fpath
                # Format: count right-justified, then filename
                count_str = str(dir_count).rjust(max_count_width)
                line = f"  {count_str}  {fname}"
                lines.append((line, curses.A_NORMAL))

        # Display with scrolling
        display_height = height - 2
        for i in range(display_height):
            idx = self.bottom_offset + i
            if idx >= len(lines):
                break

            line, attr = lines[idx]
            y = i + 1

            # Truncate if too long
            max_len = width - 3
            if len(line) > max_len:
                line = line[:max_len-3] + "..."

            # Highlight selected line if bottom pane is active
            if self.active_pane == 'bottom' and idx == self.bottom_selected_idx:
                attr = curses.A_REVERSE

            try:
                win.addstr(y, 1, line, attr)
            except curses.error:
                pass  # Ignore errors from writing to last line

        # Scrollbar indicator
        if len(lines) > display_height:
            indicator = f" [{self.bottom_offset + 1}-{min(self.bottom_offset + display_height, len(lines))}/{len(lines)}] "
            try:
                win.addstr(height - 1, width - len(indicator) - 1, indicator, curses.A_DIM)
            except curses.error:
                pass

        win.refresh()

        # Store lines count and selectable indices for navigation
        self.bottom_lines_count = len(lines)
        self.bottom_selectable_indices = selectable_indices
        self.bottom_line_to_dir = line_to_dir
        self.bottom_line_to_file = line_to_file

    def run(self, stdscr):
        """Main TUI loop."""
        curses.curs_set(0)  # Hide cursor
        stdscr.clear()

        # Set escape delay to 25ms to make ESC key responsive
        # (curses waits to see if ESC is part of an escape sequence)
        if hasattr(curses, 'set_escdelay'):
            curses.set_escdelay(25)

        # Initialize colors if available
        if curses.has_colors():
            curses.init_pair(1, curses.COLOR_WHITE, curses.COLOR_BLUE)

        # Show loading message
        height, width = stdscr.getmaxyx()
        stdscr.addstr(height // 2, width // 2 - 10, "Starting TUI...", curses.A_BOLD)
        stdscr.refresh()

        if not self.sorted_dirs:
            stdscr.clear()
            stdscr.addstr(height // 2, width // 2 - 12, "No duplicate files found.", curses.A_BOLD)
            stdscr.addstr(height // 2 + 1, width // 2 - 10, "Press any key to exit.")
            stdscr.refresh()
            stdscr.getch()
            return

        # Main loop
        while True:
            height, width = stdscr.getmaxyx()

            # Split screen: top 40%, bottom 60%
            top_height = max(5, height * 2 // 5)
            bottom_height = height - top_height

            # Create windows
            top_win = curses.newwin(top_height, width, 0, 0)
            bottom_win = curses.newwin(bottom_height, width, top_height, 0)

            # Draw panes
            self.draw_top_pane(top_win, top_height, width)
            self.draw_bottom_pane(bottom_win, bottom_height, width)

            # Handle input
            key = stdscr.getch()

            # Tab to switch panes
            if key == ord('\t'):  # Tab key
                if self.active_pane == 'top':
                    self.active_pane = 'bottom'
                    # Set current_bottom_dir to the selected directory
                    dirs_to_use = self.current_filtered_dirs if self.current_filtered_dirs else self.sorted_dirs
                    if self.selected_idx < len(dirs_to_use):
                        new_dir = dirs_to_use[self.selected_idx][0]
                    else:
                        new_dir = self.sorted_dirs[0][0] if self.sorted_dirs else None
                    # If switching to a different directory, reset selection
                    if self.current_bottom_dir != new_dir:
                        self.current_bottom_dir = new_dir
                        if hasattr(self, 'bottom_selectable_indices') and self.bottom_selectable_indices:
                            self.bottom_selected_idx = self.bottom_selectable_indices[0]
                        else:
                            self.bottom_selected_idx = 0
                        self.bottom_offset = 0
                        self.selected_file = None  # Clear file filter when switching directories
                    # Otherwise preserve the current selection (already set)
                else:
                    self.active_pane = 'top'
                continue

            # Return key or Right arrow - context-sensitive drill down
            if key in (ord('\n'), ord('\r'), curses.KEY_ENTER, curses.KEY_RIGHT, ord('l')):
                if self.active_pane == 'top':
                    # Switch to bottom pane
                    self.active_pane = 'bottom'
                    # Set current_bottom_dir to the selected directory
                    dirs_to_use = self.current_filtered_dirs if self.current_filtered_dirs else self.sorted_dirs
                    if self.selected_idx < len(dirs_to_use):
                        new_dir = dirs_to_use[self.selected_idx][0]
                    else:
                        new_dir = self.sorted_dirs[0][0] if self.sorted_dirs else None
                    # If switching to a different directory, reset selection
                    if self.current_bottom_dir != new_dir:
                        self.current_bottom_dir = new_dir
                        if hasattr(self, 'bottom_selectable_indices') and self.bottom_selectable_indices:
                            self.bottom_selected_idx = self.bottom_selectable_indices[0]
                        else:
                            self.bottom_selected_idx = 0
                        self.bottom_offset = 0
                        self.selected_file = None  # Clear file filter when switching directories
                    self.show_quit_message = False
                else:  # bottom pane
                    # Check if current selection is a file - switch to top pane with filter
                    if hasattr(self, 'bottom_line_to_file') and self.bottom_selected_idx in self.bottom_line_to_file:
                        # File is already filtering top pane, just switch to top pane
                        self.selected_file = self.bottom_line_to_file[self.bottom_selected_idx]
                        # Push current state to navigation stack for back navigation
                        self.navigation_stack.append({
                            'type': 'file_filter',
                            'selected_idx': self.selected_idx,
                            'selected_file': None,  # Will restore to no filter
                            'bottom_selected_idx': self.bottom_selected_idx,
                            'current_bottom_dir': self.current_bottom_dir
                        })
                        self.active_pane = 'top'
                        self.selected_idx = 0
                        self.top_offset = 0
                    # Check if current selection is a related directory
                    elif hasattr(self, 'bottom_line_to_dir') and self.bottom_selected_idx in self.bottom_line_to_dir:
                        # Jump to that directory in top pane
                        target_idx = self.bottom_line_to_dir[self.bottom_selected_idx]
                        # Push current directory to navigation stack
                        self.navigation_stack.append({
                            'type': 'directory',
                            'selected_idx': self.selected_idx,
                            'selected_file': self.selected_file,
                            'current_bottom_dir': self.current_bottom_dir
                        })
                        # Jump to target directory
                        self.selected_idx = target_idx
                        self.active_pane = 'top'
                        self.current_bottom_dir = None  # Will be set when entering bottom pane
                        self.selected_file = None
                        # Adjust scroll to show selected directory
                        if self.selected_idx < self.top_offset:
                            self.top_offset = self.selected_idx
                        elif self.selected_idx >= self.top_offset + (top_height - 2):
                            self.top_offset = self.selected_idx - (top_height - 2) + 1
                continue

            # Escape key or Left arrow - context-sensitive behavior
            if key in (27, curses.KEY_LEFT, ord('h')):  # ESC or Left arrow
                if self.active_pane == 'bottom':
                    # Just switch to top pane, keep the filter if any
                    self.active_pane = 'top'
                    self.show_quit_message = False
                else:  # top pane
                    # Left arrow in top pane - pop from navigation stack if available
                    if key in (curses.KEY_LEFT, ord('h')) and self.navigation_stack:
                        nav_state = self.navigation_stack.pop()
                        if isinstance(nav_state, dict):
                            self.selected_idx = nav_state.get('selected_idx', 0)
                            self.selected_file = nav_state.get('selected_file', None)
                            self.current_bottom_dir = nav_state.get('current_bottom_dir', None)
                            if nav_state.get('type') == 'file_filter':
                                # Restore bottom pane selection
                                self.active_pane = 'bottom'
                                self.bottom_selected_idx = nav_state.get('bottom_selected_idx', 0)
                        else:
                            # Legacy: just an index
                            self.selected_idx = nav_state
                            self.selected_file = None
                            self.current_bottom_dir = None
                        # Adjust scroll to show selected directory
                        if self.selected_idx < self.top_offset:
                            self.top_offset = self.selected_idx
                        elif self.selected_idx >= self.top_offset + (top_height - 2):
                            self.top_offset = self.selected_idx - (top_height - 2) + 1
                    elif self.selected_file:
                        # Clear file filter, stay on current directory
                        self.selected_file = None
                        # Don't reset selected_idx - keep showing the same directory
                    elif key == 27:
                        # ESC shows quit message
                        self.show_quit_message = True
                continue

            # Q key - quit immediately
            if key in (ord('q'), ord('Q')):
                break
            elif key in (curses.KEY_UP, ord('k')):
                self.show_quit_message = False
                if self.active_pane == 'top':
                    if self.selected_idx > 0:
                        self.selected_idx -= 1
                        # Mark that bottom pane needs refresh for new directory
                        self.last_bottom_dir_idx = None
                        # Adjust top offset if needed
                        if self.selected_idx < self.top_offset:
                            self.top_offset = self.selected_idx
                else:  # bottom pane
                    if hasattr(self, 'bottom_selectable_indices') and self.bottom_selectable_indices:
                        current_pos = self.bottom_selectable_indices.index(self.bottom_selected_idx) if self.bottom_selected_idx in self.bottom_selectable_indices else 0
                        if current_pos > 0:
                            self.bottom_selected_idx = self.bottom_selectable_indices[current_pos - 1]
                            # Adjust bottom offset if needed
                            if self.bottom_selected_idx < self.bottom_offset:
                                self.bottom_offset = self.bottom_selected_idx
                            # Update file filter based on new selection (don't change selected_idx)
                            if hasattr(self, 'bottom_line_to_file') and self.bottom_selected_idx in self.bottom_line_to_file:
                                self.selected_file = self.bottom_line_to_file[self.bottom_selected_idx]
                            else:
                                self.selected_file = None
                            # Don't change selected_idx or current_bottom_dir - just update the filter display
            elif key in (curses.KEY_DOWN, ord('j')):
                self.show_quit_message = False
                if self.active_pane == 'top':
                    # Use filtered dirs for bounds checking
                    max_idx = len(self.current_filtered_dirs) - 1 if hasattr(self, 'current_filtered_dirs') and self.current_filtered_dirs else len(self.sorted_dirs) - 1
                    if self.selected_idx < max_idx:
                        self.selected_idx += 1
                        # Mark that bottom pane needs refresh for new directory
                        self.last_bottom_dir_idx = None
                        # Adjust top offset if needed
                        display_height = top_height - 2
                        if self.selected_idx >= self.top_offset + display_height:
                            self.top_offset = self.selected_idx - display_height + 1
                else:  # bottom pane
                    if hasattr(self, 'bottom_selectable_indices') and self.bottom_selectable_indices:
                        current_pos = self.bottom_selectable_indices.index(self.bottom_selected_idx) if self.bottom_selected_idx in self.bottom_selectable_indices else -1
                        if current_pos < len(self.bottom_selectable_indices) - 1:
                            self.bottom_selected_idx = self.bottom_selectable_indices[current_pos + 1]
                            # Adjust bottom offset if needed
                            display_height = bottom_height - 2
                            if self.bottom_selected_idx >= self.bottom_offset + display_height:
                                self.bottom_offset = self.bottom_selected_idx - display_height + 1
                            # Update file filter based on new selection (don't change selected_idx)
                            if hasattr(self, 'bottom_line_to_file') and self.bottom_selected_idx in self.bottom_line_to_file:
                                self.selected_file = self.bottom_line_to_file[self.bottom_selected_idx]
                            else:
                                self.selected_file = None
                            # Don't change selected_idx or current_bottom_dir - just update the filter display
            elif key == curses.KEY_PPAGE:  # Page Up
                self.show_quit_message = False
                if self.active_pane == 'top':
                    self.selected_idx = max(0, self.selected_idx - (top_height - 2))
                    self.top_offset = max(0, self.top_offset - (top_height - 2))
                    self.last_bottom_dir_idx = None
                else:
                    if hasattr(self, 'bottom_selectable_indices') and self.bottom_selectable_indices:
                        current_pos = self.bottom_selectable_indices.index(self.bottom_selected_idx) if self.bottom_selected_idx in self.bottom_selectable_indices else 0
                        new_pos = max(0, current_pos - (bottom_height - 2))
                        self.bottom_selected_idx = self.bottom_selectable_indices[new_pos]
                        self.bottom_offset = max(0, self.bottom_selected_idx - (bottom_height - 2))
            elif key in (curses.KEY_NPAGE, 6):  # Page Down or Ctrl-F
                self.show_quit_message = False
                if self.active_pane == 'top':
                    display_height = top_height - 2
                    max_idx = len(self.current_filtered_dirs) - 1 if hasattr(self, 'current_filtered_dirs') and self.current_filtered_dirs else len(self.sorted_dirs) - 1
                    self.selected_idx = min(max_idx, self.selected_idx + display_height)
                    total_dirs = len(self.current_filtered_dirs) if hasattr(self, 'current_filtered_dirs') and self.current_filtered_dirs else len(self.sorted_dirs)
                    self.top_offset = min(max(0, total_dirs - display_height),
                                         self.top_offset + display_height)
                    self.last_bottom_dir_idx = None
                else:
                    if hasattr(self, 'bottom_selectable_indices') and self.bottom_selectable_indices:
                        current_pos = self.bottom_selectable_indices.index(self.bottom_selected_idx) if self.bottom_selected_idx in self.bottom_selectable_indices else 0
                        new_pos = min(len(self.bottom_selectable_indices) - 1, current_pos + (bottom_height - 2))
                        self.bottom_selected_idx = self.bottom_selectable_indices[new_pos]
                        display_height = bottom_height - 2
                        if self.bottom_selected_idx >= self.bottom_offset + display_height:
                            self.bottom_offset = self.bottom_selected_idx - display_height + 1
            elif key == 2:  # Ctrl-B
                self.show_quit_message = False
                if self.active_pane == 'top':
                    self.selected_idx = max(0, self.selected_idx - (top_height - 2))
                    self.top_offset = max(0, self.top_offset - (top_height - 2))
                    self.last_bottom_dir_idx = None
                else:
                    if hasattr(self, 'bottom_selectable_indices') and self.bottom_selectable_indices:
                        current_pos = self.bottom_selectable_indices.index(self.bottom_selected_idx) if self.bottom_selected_idx in self.bottom_selectable_indices else 0
                        new_pos = max(0, current_pos - (bottom_height - 2))
                        self.bottom_selected_idx = self.bottom_selectable_indices[new_pos]
                        self.bottom_offset = max(0, self.bottom_selected_idx - (bottom_height - 2))
            elif key in (curses.KEY_HOME, ord('<')):  # Home or <
                self.show_quit_message = False
                if self.active_pane == 'top':
                    self.selected_idx = 0
                    self.top_offset = 0
                    self.last_bottom_dir_idx = None
                else:
                    if hasattr(self, 'bottom_selectable_indices') and self.bottom_selectable_indices:
                        self.bottom_selected_idx = self.bottom_selectable_indices[0]
                    else:
                        self.bottom_selected_idx = 0
                    self.bottom_offset = 0
            elif key in (curses.KEY_END, ord('>')):  # End or >
                self.show_quit_message = False
                if self.active_pane == 'top':
                    total_dirs = len(self.current_filtered_dirs) if hasattr(self, 'current_filtered_dirs') and self.current_filtered_dirs else len(self.sorted_dirs)
                    self.selected_idx = total_dirs - 1
                    display_height = top_height - 2
                    self.top_offset = max(0, total_dirs - display_height)
                    self.last_bottom_dir_idx = None
                else:
                    if hasattr(self, 'bottom_selectable_indices') and self.bottom_selectable_indices:
                        self.bottom_selected_idx = self.bottom_selectable_indices[-1]
                        display_height = bottom_height - 2
                        self.bottom_offset = max(0, self.bottom_selected_idx - display_height + 1)
            elif key == curses.KEY_RESIZE:
                stdscr.clear()


def main():
    import argparse

    parser = argparse.ArgumentParser(
        prog='redundir-tui',
        description='Interactive TUI for exploring redundant directories.'
    )
    parser.add_argument(
        'directories',
        nargs='*',
        default=['.'],
        metavar='directory',
        help='Directories to scan (default: current directory)'
    )
    parser.add_argument(
        '-a', '--algorithm',
        default='blake2b',
        choices=['md5', 'sha1', 'sha256', 'blake2b', 'blake2s'],
        help='Hash algorithm to use (default: blake2b)'
    )
    parser.add_argument(
        '-j', '--jobs',
        type=int,
        default=4,
        metavar='N',
        help='Number of parallel hashing jobs (default: 4, use 1 to disable)'
    )

    args = parser.parse_args()

    # Handle both single directory and multiple directories
    roots = []
    for directory in args.directories:
        root = Path(directory).resolve()
        if not root.exists():
            print(f"Error: '{directory}' does not exist", file=sys.stderr)
            sys.exit(1)
        if not root.is_dir():
            print(f"Error: '{directory}' is not a directory", file=sys.stderr)
            sys.exit(1)
        roots.append(root)

    tui = RedundirTUI(roots, algorithm=args.algorithm, jobs=args.jobs)

    # Scan with progress output before starting TUI
    if len(roots) == 1:
        print(f"Scanning {roots[0]}...")
    else:
        print(f"Scanning {len(roots)} directories...")
        for root in roots:
            print(f"  {root}")
    tui.scan(quiet=False)

    if not tui.sorted_dirs:
        print("No duplicate files found.")
        sys.exit(0)

    try:
        curses.wrapper(tui.run)
    except KeyboardInterrupt:
        pass


if __name__ == '__main__':
    main()
