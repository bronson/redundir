#!/usr/bin/env python3
"""
dedupdir-tui - Interactive TUI for exploring redundant directories
version 0.2.XX

This script provides a TUI to help quickly deduplicate files. It shows the
redundancies scores for all directories in a tree and lets you temporarily
remove files and immediately see the effect on the scores.
"""

import curses
import sys
import os
import shutil
import threading
import queue
from pathlib import Path
from datetime import datetime

# Import core functions from dedupdir by loading it directly
def load_dedupdir():
    """Load dedupdir module from same directory or PATH."""
    import types

    # Try to find dedupdir in same directory as this script
    # Check multiple possible locations
    possible_paths = [
        Path(__file__).parent / "dedupdir",  # Same directory
        Path.cwd() / "dedupdir",  # Current working directory
        Path(sys.argv[0]).parent / "dedupdir",  # Script directory from argv
    ]

    for dedupdir_path in possible_paths:
        if dedupdir_path.exists() and dedupdir_path.is_file():
            try:
                # Read and execute the file directly since it has no .py extension
                with open(dedupdir_path, 'r') as f:
                    code = f.read()

                # Create a module to hold the executed code
                dedupdir = types.ModuleType('dedupdir')
                dedupdir.__file__ = str(dedupdir_path)
                sys.modules['dedupdir'] = dedupdir

                # Execute the code in the module's namespace
                exec(code, dedupdir.__dict__)

                # Verify required functions exist
                if hasattr(dedupdir, 'find_duplicates') and hasattr(dedupdir, 'calculate_redundancy_score'):
                    return dedupdir
            except Exception as e:
                print(f"Error loading {dedupdir_path}: {e}", file=sys.stderr)
                continue

    # Try regular import as fallback
    try:
        import dedupdir
        return dedupdir
    except ImportError:
        pass

    print("Error: Could not find dedupdir script", file=sys.stderr)
    print("Tried locations:", file=sys.stderr)
    for p in possible_paths:
        print(f"  {p} (exists: {p.exists()})", file=sys.stderr)
    sys.exit(1)

dedupdir_module = load_dedupdir()
find_duplicates = dedupdir_module.find_duplicates
calculate_redundancy_score = dedupdir_module.calculate_redundancy_score
hash_file = dedupdir_module.hash_file
CACHE_FILE_NAME = dedupdir_module.CACHE_FILE_NAME


class DedupdirTUI:
    def __init__(self, root_paths, algorithm='blake2b', jobs=4):
        # Normalize to list
        if isinstance(root_paths, (str, Path)):
            root_paths = [root_paths]
        self.root_paths = [Path(p).resolve() for p in root_paths]
        self.algorithm = algorithm
        self.jobs = jobs

        # Navigation state
        self.selected_idx = 0
        self.scroll_offset = 0
        self.show_quit_message = False
        self.alert_message = None  # Message to show in dismissable alert dialog

        # View stack for drill-down navigation
        # Each entry is a dict: {'type': 'main'|'dir_detail'|'file_detail', 'data': {...}}
        self.view_stack = [{'type': 'main'}]

        # Trash system (trash dirs are per-root, not in cwd)
        self.trash_stack = []  # Stack for undo: [(original_path, trash_path, is_dir), ...]
        self.viewing_trash = False  # Whether we're in trash viewing mode
        self.trash_selected_idx = 0
        self.trash_offset = 0
        self.trash_path_stack = []  # Stack of (trash_path, original_path, selected_idx, offset) for drill-down navigation
        self.confirm_trash_item = None  # Item pending confirmation
        self.confirm_trash_type = None  # 'file' or 'directory'
        self.confirm_quit = False  # Whether quit confirmation is pending
        self.show_no_duplicates_message = False  # Show message when no duplicates found

        # Collapsed directory groups - set of parent dir paths that are collapsed
        self.expanded_groups = set()  # Groups that have been explicitly expanded
        self._display_list_cache = None  # Cached display list for performance
        self._dir_sizes_cache = {}  # Cache for directory sizes to avoid repeated stat() calls
        self._relationship_cache = None  # Cache for parent-child relationships (expensive to compute)
        self._recursive_stats_cache = {}  # Cache for recursive directory stats
        self._dir_contents_cache = {}  # Cache for get_all_files_with_counts results

        # Sort mode: 'redundancy', 'duplicates', 'total', 'path', 'size', 'mtime'
        self.sort_mode = 'redundancy'
        self.sort_modes = ['redundancy', 'duplicates', 'total', 'path', 'size', 'mtime']

        # Data will be populated by scan()
        self.sorted_dirs = []
        self.dir_stats = {}
        self.file_to_hash = {}
        self.hash_to_dirs = {}
        self.dir_all_files = {}
        self.total_duplicates = 0
        self.total_files = 0

        # Background verification state
        self.cached_hashes = {}  # file_path -> hash for files loaded from cache
        self.verification_thread = None
        self.verification_error = None  # Set if verification fails
        self.verification_queue = queue.Queue()  # For communicating errors from thread
        self.verification_complete = False
        self.verification_progress = (0, 0)  # (verified, total)

    def scan(self, quiet=False):
        """Scan the directory tree for duplicates."""
        result = find_duplicates(
            self.root_paths,
            algorithm=self.algorithm,
            jobs=self.jobs,
            quiet=quiet
        )
        self.dir_stats, self.total_duplicates, self.total_files, \
            self.file_to_hash, self.hash_to_dirs, self.dir_all_files, \
            self.cached_hashes = result

        # Recalculate sorted_dirs with all directories
        self.recalculate_sorted_dirs()
        self.invalidate_display_cache()

        # Start background verification if we used cached data
        if self.cached_hashes:
            self.start_background_verification()

    def rescan(self):
        """Invalidate all caches and rescan the directory tree.

        Use this after filesystem modifications (promote, trash, restore).
        Caches must be invalidated BEFORE scan() because scan() calls
        recalculate_sorted_dirs() which uses get_recursive_stats() (cached).
        """
        self.invalidate_relationship_cache()
        self.invalidate_size_cache()
        self.invalidate_recursive_stats_cache()
        self.invalidate_dir_contents_cache()
        self.scan(quiet=True)

    def start_background_verification(self):
        """Start a background thread to verify cached hashes."""
        if not self.cached_hashes:
            self.verification_complete = True
            return

        self.verification_progress = (0, len(self.cached_hashes))

        def verify_worker():
            """Background worker that verifies cached hashes one at a time."""
            files_to_verify = list(self.cached_hashes.items())
            total = len(files_to_verify)
            verified = 0

            for fpath, expected_hash in files_to_verify:
                verified += 1
                self.verification_progress = (verified, total)

                try:
                    actual_hash = hash_file(fpath, self.algorithm)
                    if actual_hash is None:
                        # File unreadable - skip
                        continue
                    if actual_hash != expected_hash:
                        error_msg = f"Cache verification failed!\n\nFile: {fpath}\nExpected: {expected_hash[:16]}...\nActual: {actual_hash[:16]}...\n\nThe file was modified but the cache wasn't updated.\nRemove {CACHE_FILE_NAME} files and restart."
                        self.verification_queue.put(('error', error_msg))
                        return
                except Exception:
                    # Skip files that can't be read
                    continue

            # Verification complete with no errors
            self.verification_queue.put(('complete', None))

        self.verification_thread = threading.Thread(target=verify_worker, daemon=True)
        self.verification_thread.start()

    def check_verification_status(self):
        """Check for verification errors from background thread. Returns error message or None."""
        try:
            while True:
                msg_type, msg_data = self.verification_queue.get_nowait()
                if msg_type == 'error':
                    self.verification_error = msg_data
                    return msg_data
                elif msg_type == 'complete':
                    self.verification_complete = True
        except queue.Empty:
            pass
        return None

    def get_dir_mtime(self, dir_path):
        """Get the most recent mtime of any file in the directory."""
        try:
            return dir_path.stat().st_mtime
        except:
            return 0

    def recalculate_sorted_dirs(self):
        """Recalculate sorted_dirs including ALL directories, even those with 0% redundancy.

        Uses recursive stats so each directory's redundancy includes all subdirectories.
        """
        all_dirs_with_stats = []
        for dir_path in self.dir_all_files.keys():
            # Get recursive stats (includes all subdirectories)
            stats = self.get_recursive_stats(dir_path)
            all_dirs_with_stats.append((dir_path, stats))

        # Sort based on current sort mode
        if self.sort_mode == 'redundancy':
            self.sorted_dirs = sorted(
                all_dirs_with_stats,
                key=lambda x: (-calculate_redundancy_score(x[1][0], x[1][1]), str(x[0]))
            )
        elif self.sort_mode == 'duplicates':
            self.sorted_dirs = sorted(
                all_dirs_with_stats,
                key=lambda x: (-x[1][0], str(x[0]))  # By duplicate count descending
            )
        elif self.sort_mode == 'total':
            self.sorted_dirs = sorted(
                all_dirs_with_stats,
                key=lambda x: (-x[1][1], str(x[0]))  # By total files descending
            )
        elif self.sort_mode == 'path':
            self.sorted_dirs = sorted(
                all_dirs_with_stats,
                key=lambda x: str(x[0])  # By path ascending
            )
        elif self.sort_mode == 'size':
            self.sorted_dirs = sorted(
                all_dirs_with_stats,
                key=lambda x: (-self.get_dir_size(x[0]), str(x[0]))  # By size descending
            )
        elif self.sort_mode == 'mtime':
            self.sorted_dirs = sorted(
                all_dirs_with_stats,
                key=lambda x: (-self.get_dir_mtime(x[0]), str(x[0]))  # By mtime descending (newest first)
            )
        else:
            # Default to redundancy
            self.sorted_dirs = sorted(
                all_dirs_with_stats,
                key=lambda x: (-calculate_redundancy_score(x[1][0], x[1][1]), str(x[0]))
            )

    def cycle_sort_mode(self, reverse=False):
        """Cycle to the next (or previous) sort mode and re-sort directories."""
        current_idx = self.sort_modes.index(self.sort_mode)
        if reverse:
            next_idx = (current_idx - 1) % len(self.sort_modes)
        else:
            next_idx = (current_idx + 1) % len(self.sort_modes)
        self.sort_mode = self.sort_modes[next_idx]
        self.recalculate_sorted_dirs()
        self.invalidate_display_cache()
        self.invalidate_relationship_cache()

    def invalidate_display_cache(self):
        """Invalidate the display list cache, forcing a rebuild on next access."""
        self._display_list_cache = None

    def invalidate_relationship_cache(self):
        """Invalidate the relationship cache, forcing a rebuild on next access."""
        self._relationship_cache = None
        self._display_list_cache = None  # Display list depends on relationships

    def invalidate_size_cache(self):
        """Invalidate the directory size cache."""
        self._dir_sizes_cache = {}

    def invalidate_recursive_stats_cache(self):
        """Invalidate the recursive stats cache."""
        self._recursive_stats_cache = {}

    def invalidate_dir_contents_cache(self):
        """Invalidate the directory contents cache."""
        self._dir_contents_cache = {}

    def get_dir_size(self, dir_path):
        """Get total size of files in a directory (cached)."""
        if dir_path in self._dir_sizes_cache:
            return self._dir_sizes_cache[dir_path]

        total_size = 0
        for fpath in self.dir_all_files.get(dir_path, []):
            try:
                total_size += fpath.stat().st_size
            except:
                pass

        self._dir_sizes_cache[dir_path] = total_size
        return total_size

    def build_relationship_cache(self):
        """Build and cache parent-child relationships (expensive operation)."""
        if self._relationship_cache is not None:
            return self._relationship_cache

        if not self.sorted_dirs:
            self._relationship_cache = (set(), {})
            return self._relationship_cache

        # First pass: identify which directories are 100% redundant (recursively)
        fully_redundant = set()
        for dir_path, _ in self.sorted_dirs:
            dups, total = self.get_recursive_stats(dir_path)
            if total > 0 and dups == total:
                fully_redundant.add(dir_path)

        # Second pass: find parent-child relationships among sorted_dirs
        # A child is a DIRECT subdirectory of a parent (no intermediate dirs in sorted_dirs)
        children_map = {}  # parent_path -> [(child_path, stats), ...]

        for i, (dir_path, stats) in enumerate(self.sorted_dirs):
            # Find all parents of this directory that are in sorted_dirs
            parents_in_list = []
            for j, (potential_parent, parent_stats) in enumerate(self.sorted_dirs):
                if i != j and self.is_subdir(dir_path, potential_parent):
                    parents_in_list.append((potential_parent, parent_stats, len(str(potential_parent))))

            # The closest parent is the one with the longest path
            if parents_in_list:
                parents_in_list.sort(key=lambda x: x[2], reverse=True)
                closest_parent, _, _ = parents_in_list[0]
                if closest_parent not in children_map:
                    children_map[closest_parent] = []
                children_map[closest_parent].append((dir_path, stats))

        self._relationship_cache = (fully_redundant, children_map)
        return self._relationship_cache

    def build_display_list(self):
        """Build display list with collapsible groups for 100% redundant subdirectories.

        Returns list of display items, each is either:
        - ('dir', dir_path, stats, is_child) - a regular directory entry (is_child=True if under a collapse)
        - ('collapse', parent_path, child_dirs, total_files, total_dups) - a collapse line
        """
        # Return cached version if available
        if self._display_list_cache is not None:
            return self._display_list_cache

        if not self.sorted_dirs:
            return []

        # Get cached relationship data (expensive to compute)
        fully_redundant, children_map = self.build_relationship_cache()

        # Build display list using cached relationships
        display_list = []
        skip_dirs = set()  # Dirs to skip because they're in a collapse
        child_of_collapse = set()  # Dirs that are children of an expanded collapse

        for dir_path, stats in self.sorted_dirs:
            if dir_path in skip_dirs:
                continue

            # Check if this is a child of an expanded collapse
            is_child = dir_path in child_of_collapse

            # Add the directory itself
            display_list.append(('dir', dir_path, stats, is_child))

            # Check if this directory has collapsible children
            if dir_path in children_map and dir_path in fully_redundant:
                all_children = children_map[dir_path]
                # Filter to only children that are 100% redundant
                children = [
                    (child_path, stats) for child_path, stats in all_children
                    if child_path in fully_redundant
                ]

                if children:
                    # Calculate totals for the collapse
                    total_files = sum(s[1] for _, s in children)
                    total_dups = sum(s[0] for _, s in children)

                    # Calculate total size of files in collapsed directories (using cache)
                    total_size = sum(self.get_dir_size(child_path) for child_path, _ in children)

                    # Add collapse line
                    child_paths = [cp for cp, _ in children]
                    display_list.append(('collapse', dir_path, child_paths, total_files, total_dups, total_size))

                    # If not expanded, skip the children
                    if dir_path not in self.expanded_groups:
                        for child_path, _ in children:
                            skip_dirs.add(child_path)
                            # Also skip grandchildren
                            if child_path in children_map:
                                for grandchild_path, _ in children_map[child_path]:
                                    skip_dirs.add(grandchild_path)
                    else:
                        # Mark children as belonging to this collapse (for indentation)
                        for child_path, _ in children:
                            child_of_collapse.add(child_path)

        self._display_list_cache = display_list
        return display_list

    def is_subdir(self, child, parent):
        """Check if child is a subdirectory of parent."""
        try:
            child.relative_to(parent)
            return child != parent
        except ValueError:
            return False

    def get_path_with_root(self, path):
        """Get path including root prefix (e.g., 'pix/subdir/file.jpg')."""
        path = Path(path)
        # Find which root this path belongs to
        for root in self.root_paths:
            try:
                rel = path.relative_to(root.parent)
                return str(rel)
            except ValueError:
                continue
        # Fallback to just the path
        return str(path)

    def get_relative_path(self, path):
        """Convert absolute path to relative display path."""
        # Try each root path
        for root_path in self.root_paths:
            try:
                rel = path.relative_to(root_path)
                display = str(root_path.name / rel) if str(rel) != '.' else str(root_path.name)
                return display
            except ValueError:
                continue
        # If not relative to any root, use absolute path
        return str(path)

    def get_related_dirs(self, dir_path):
        """Get related directories and their hypothetical redundancy scores.

        Returns list of (related_dir_path, shared_files, duplicates, total_files) tuples.
        """
        # Find all hashes in this directory
        dir_hashes = set()
        for fpath in self.dir_all_files.get(dir_path, []):
            if fpath in self.file_to_hash:
                dir_hashes.add(self.file_to_hash[fpath])

        # Find related directories and count shared files
        related_dirs_info = {}
        for h in dir_hashes:
            for d in self.hash_to_dirs[h]:
                if d != dir_path:
                    if d not in related_dirs_info:
                        related_dirs_info[d] = 0
                    related_dirs_info[d] += 1  # Count shared files

        # Calculate hypothetical redundancy for each related directory
        related_info = []
        for related_dir, shared_count in related_dirs_info.items():
            related_files = self.dir_all_files.get(related_dir, [])
            total_related = len(related_files)

            hypothetical_duplicates = 0
            for fpath in related_files:
                if fpath in self.file_to_hash:
                    h = self.file_to_hash[fpath]
                    other_dirs = self.hash_to_dirs[h] - {dir_path, related_dir}
                    if len(other_dirs) > 0:
                        hypothetical_duplicates += 1

            related_info.append((related_dir, shared_count, hypothetical_duplicates, total_related))

        # Sort by shared files descending, then by hypothetical duplicates descending
        related_info.sort(key=lambda x: (-x[1], -x[2]))
        return related_info

    def get_duplicate_files(self, dir_path):
        """Get list of duplicate files in the directory."""
        dup_files = []
        for fpath in self.dir_all_files.get(dir_path, []):
            if fpath in self.file_to_hash:
                dup_files.append(fpath.name)
        return sorted(dup_files)

    def get_all_files_with_counts(self, dir_path):
        """Get list of files and subdirectories in directory with redundancy info.

        Returns list of (display_name, count_or_stats, path, item_type) tuples.
        - For files: (filename, dir_count, file_path, 'file')
        - For dirs: (dirname, (dups, total), dir_path, 'dir')

        Sorted with files first (by count desc), then directories (by redundancy).
        Results are cached for performance.
        """
        # Check cache first
        if dir_path in self._dir_contents_cache:
            return self._dir_contents_cache[dir_path]

        items = []

        # Get direct files in this directory
        for fpath in self.dir_all_files.get(dir_path, []):
            fname = fpath.name
            # Count how many directories contain this file (by hash)
            if fpath in self.file_to_hash:
                fhash = self.file_to_hash[fpath]
                dir_count = len(self.hash_to_dirs.get(fhash, set()))
            else:
                # Unique file (not hashed, only in this directory)
                dir_count = 1
            items.append((fname, dir_count, fpath, 'file'))

        # Get immediate subdirectories (not all descendants, just direct children)
        for other_dir in self.dir_all_files.keys():
            if other_dir != dir_path and self.is_subdir(other_dir, dir_path):
                # Check if it's a direct child (no intermediate directory in our list)
                is_direct_child = True
                for potential_parent in self.dir_all_files.keys():
                    if (potential_parent != dir_path and
                        potential_parent != other_dir and
                        self.is_subdir(other_dir, potential_parent) and
                        self.is_subdir(potential_parent, dir_path)):
                        is_direct_child = False
                        break

                if is_direct_child:
                    # Get recursive stats for this subdirectory
                    dups, total = self.get_recursive_stats(other_dir)
                    # Use relative name
                    try:
                        rel_name = other_dir.relative_to(dir_path)
                        display_name = str(rel_name) + "/"
                    except ValueError:
                        display_name = other_dir.name + "/"
                    items.append((display_name, (dups, total), other_dir, 'dir'))

        # Sort: files first (by count desc), then directories (by redundancy % desc)
        files = [(n, c, p, t) for n, c, p, t in items if t == 'file']
        dirs = [(n, c, p, t) for n, c, p, t in items if t == 'dir']

        files.sort(key=lambda x: (-x[1], x[0].lower()))
        dirs.sort(key=lambda x: (-calculate_redundancy_score(x[1][0], x[1][1]) if x[1][1] > 0 else 0, x[0].lower()))

        # Combine with divider between files and dirs (if both exist)
        result = files
        if files and dirs:
            result.append(('--- Subdirectories ---', None, None, 'divider'))
        result.extend(dirs)

        self._dir_contents_cache[dir_path] = result
        return result

    def get_dirs_containing_file(self, file_path):
        """Get list of directories that contain the given file (by hash)."""
        if file_path not in self.file_to_hash:
            # Unique file, only in its own directory
            return [file_path.parent]

        fhash = self.file_to_hash[file_path]
        return list(self.hash_to_dirs.get(fhash, set()))

    def get_filename_in_dir(self, file_path, dir_path):
        """Get the actual filename for a file's hash in a specific directory.

        Since duplicate files can have different names in different directories,
        we need to look up the actual filename in each directory.
        """
        if file_path not in self.file_to_hash:
            # Unique file, just return its name
            return file_path.name

        fhash = self.file_to_hash[file_path]

        # Search through all files in the target directory for one with matching hash
        for fpath in self.dir_all_files.get(dir_path, []):
            if fpath in self.file_to_hash and self.file_to_hash[fpath] == fhash:
                return fpath.name

        # Fallback to original filename if not found
        return file_path.name

    def get_trash_dir_for_root(self, root_path):
        """Get the trash directory for a specific root."""
        return root_path / '~dedupdir-trash'

    def init_trash_dir_for_root(self, root_path):
        """Initialize trash directory for a specific root if it doesn't exist."""
        trash_dir = self.get_trash_dir_for_root(root_path)
        if not trash_dir.exists():
            trash_dir.mkdir(parents=True)
        return trash_dir

    def get_trash_items(self, parent_path=None):
        """Scan trash directories and return list of items.

        If parent_path is None, shows top-level items from all roots.
        If parent_path is specified, shows contents of that directory.
        """
        items = []

        if parent_path:
            # Show contents of a specific directory
            parent = Path(parent_path)
            if not parent.exists() or not parent.is_dir():
                return items

            # Find the root this path belongs to
            root_path = None
            for rp in self.root_paths:
                trash_dir = self.get_trash_dir_for_root(rp)
                try:
                    parent.relative_to(trash_dir)
                    root_path = rp
                    break
                except ValueError:
                    continue

            if not root_path:
                return items

            trash_dir = self.get_trash_dir_for_root(root_path)

            try:
                for item in parent.iterdir():
                    rel_to_trash = item.relative_to(trash_dir)
                    original_path = root_path / rel_to_trash

                    if item.is_file():
                        try:
                            size = item.stat().st_size
                            timestamp = datetime.fromtimestamp(item.stat().st_ctime).isoformat()
                        except:
                            size = 0
                            timestamp = ''

                        items.append({
                            'original_path': str(original_path),
                            'trash_path': str(item),
                            'root_name': root_path.name,
                            'relative_path': str(rel_to_trash),
                            'type': 'file',
                            'size': size,
                            'file_count': 1,
                            'timestamp': timestamp
                        })
                    elif item.is_dir():
                        file_count = 0
                        total_size = 0
                        latest_time = 0
                        try:
                            for f in item.rglob('*'):
                                if f.is_file():
                                    file_count += 1
                                    try:
                                        stat = f.stat()
                                        total_size += stat.st_size
                                        latest_time = max(latest_time, stat.st_ctime)
                                    except:
                                        pass
                            if latest_time == 0:
                                latest_time = item.stat().st_ctime
                        except:
                            pass

                        items.append({
                            'original_path': str(original_path),
                            'trash_path': str(item),
                            'root_name': root_path.name,
                            'relative_path': str(rel_to_trash),
                            'type': 'directory',
                            'size': total_size,
                            'file_count': file_count,
                            'timestamp': datetime.fromtimestamp(latest_time).isoformat() if latest_time else ''
                        })
            except PermissionError:
                pass

            items.sort(key=lambda x: (x['type'] != 'directory', x['relative_path'].lower()))
            return items

        # Top-level: show items from all roots
        for root_path in self.root_paths:
            trash_dir = self.get_trash_dir_for_root(root_path)
            if not trash_dir.exists():
                continue

            # Only get top-level items in trash (not recursive)
            try:
                for item in trash_dir.iterdir():
                    rel_to_trash = item.relative_to(trash_dir)
                    original_path = root_path / rel_to_trash

                    if item.is_file():
                        try:
                            size = item.stat().st_size
                            timestamp = datetime.fromtimestamp(item.stat().st_ctime).isoformat()
                        except:
                            size = 0
                            timestamp = ''

                        items.append({
                            'original_path': str(original_path),
                            'trash_path': str(item),
                            'root_name': root_path.name,
                            'relative_path': str(rel_to_trash),
                            'type': 'file',
                            'size': size,
                            'file_count': 1,
                            'timestamp': timestamp
                        })
                    elif item.is_dir():
                        # Count files and total size in directory
                        file_count = 0
                        total_size = 0
                        latest_time = 0
                        try:
                            for f in item.rglob('*'):
                                if f.is_file():
                                    file_count += 1
                                    try:
                                        stat = f.stat()
                                        total_size += stat.st_size
                                        latest_time = max(latest_time, stat.st_ctime)
                                    except:
                                        pass
                            if latest_time == 0:
                                latest_time = item.stat().st_ctime
                        except:
                            pass

                        items.append({
                            'original_path': str(original_path),
                            'trash_path': str(item),
                            'root_name': root_path.name,
                            'relative_path': str(rel_to_trash),
                            'type': 'directory',
                            'size': total_size,
                            'file_count': file_count,
                            'timestamp': datetime.fromtimestamp(latest_time).isoformat() if latest_time else ''
                        })
            except PermissionError:
                continue

        # Sort by timestamp (newest first)
        items.sort(key=lambda x: x['timestamp'], reverse=True)
        return items

    def get_current_view(self):
        """Get the current view from the view stack."""
        return self.view_stack[-1] if self.view_stack else {'type': 'main'}

    def push_view(self, view):
        """Push a new view onto the stack."""
        # Save current selection state in the current view
        if self.view_stack:
            current = self.view_stack[-1]
            current['selected_idx'] = self.selected_idx
            current['scroll_offset'] = self.scroll_offset

        self.view_stack.append(view)
        self.selected_idx = 0
        self.scroll_offset = 0

    def pop_view(self):
        """Pop the current view and return to the previous one."""
        if len(self.view_stack) > 1:
            self.view_stack.pop()
            # Restore selection state from the previous view
            prev_view = self.view_stack[-1]
            self.selected_idx = prev_view.get('selected_idx', 0)
            self.scroll_offset = prev_view.get('scroll_offset', 0)
            return True
        return False

    def get_current_list_size(self):
        """Get the size of the current list being displayed."""
        view = self.get_current_view()
        if view['type'] == 'main':
            return len(self.build_display_list())
        elif view['type'] == 'dir_detail':
            dir_path = view['data']['dir_path']
            files = self.get_all_files_with_counts(dir_path)
            return len(files)
        elif view['type'] == 'file_detail':
            file_path = view['data']['file_path']
            return len(self.get_dirs_containing_file(file_path))
        return 0

    def get_current_visible_lines(self, usable_height):
        """Get the number of visible content lines for the current view.

        This accounts for view type and stack depth (overlay indentation).
        """
        view = self.get_current_view()
        level_idx = len(self.view_stack) - 1

        if view['type'] == 'main':
            # Main view: height - 3 for border/header, but navigation uses -5
            return usable_height - 5
        else:
            # Overlay views are indented by level_idx rows
            overlay_height = usable_height - level_idx
            if view['type'] == 'dir_detail':
                # dir_detail uses height - 3 (title + header line + border)
                return overlay_height - 3
            else:
                # file_detail uses height - 5
                return overlay_height - 5

    def format_stats_text(self, duplicate_files, total_files):
        """Format stats as ' X files | Y dupes | Z% ' string."""
        if total_files == 0:
            return " 0 files | 0 dupes | 0% "

        duplication_percent = (duplicate_files / total_files) * 100

        if duplication_percent == 0.0:
            percent_str = "0%"
        elif duplication_percent < 0.01:
            percent_str = "<0.01%"
        elif duplication_percent < 1.0:
            percent_str = f"{duplication_percent:.2f}%"
        elif duplication_percent < 10.0:
            percent_str = f"{duplication_percent:.1f}%"
        else:
            percent_str = f"{duplication_percent:.0f}%"

        return f" {total_files} files | {duplicate_files} dupes | {percent_str} "

    def get_current_stats(self):
        """Calculate current statistics: total files, duplicate files, and duplication percentage.

        Returns a tuple: (total_files, duplicate_files, duplication_percent)
        """
        # Count all unique files across all directories
        all_files = set()
        for dir_path, files in self.dir_all_files.items():
            all_files.update(files)

        total_files = len(all_files)

        if total_files == 0:
            return 0, 0, 0.0

        # Count duplicate files (files that exist in more than one directory)
        duplicate_files = 0
        for file_path in all_files:
            if file_path in self.file_to_hash:
                file_hash = self.file_to_hash[file_path]
                num_dirs = len(self.hash_to_dirs.get(file_hash, set()))
                if num_dirs > 1:
                    duplicate_files += 1

        # Calculate percentage - ensure we don't show 0% if there are duplicates
        if duplicate_files > 0:
            duplication_percent = (duplicate_files / total_files) * 100
            # If percentage rounds to 0 but there are duplicates, show at least 0.01%
            if duplication_percent < 0.01:
                duplication_percent = 0.01
        else:
            duplication_percent = 0.0

        return total_files, duplicate_files, duplication_percent

    def get_file_redundancy_count(self, file_path):
        """Get how many directories contain this file (based on hash)."""
        if file_path not in self.file_to_hash:
            return 0
        file_hash = self.file_to_hash[file_path]
        return len(self.hash_to_dirs.get(file_hash, set()))

    def get_recursive_stats(self, dir_path):
        """Get stats including all files in subdirectories.

        Returns (duplicates, total) counting all UNIQUE files recursively under dir_path.
        A file is counted as a duplicate if its hash appears in more than one directory.
        Uses caching for performance.
        """
        # Check cache first
        if dir_path in self._recursive_stats_cache:
            return self._recursive_stats_cache[dir_path]

        # Collect all unique files in this directory tree
        all_files = set()

        # Include this directory's own files
        for fpath in self.dir_all_files.get(dir_path, []):
            all_files.add(fpath)

        # Include all subdirectories
        for other_dir in self.dir_all_files.keys():
            if other_dir != dir_path and self.is_subdir(other_dir, dir_path):
                for fpath in self.dir_all_files.get(other_dir, []):
                    all_files.add(fpath)

        total_files = len(all_files)

        # Count duplicates (files whose hash appears in more than one directory)
        total_dups = 0
        for fpath in all_files:
            if fpath in self.file_to_hash:
                fhash = self.file_to_hash[fpath]
                if len(self.hash_to_dirs.get(fhash, set())) > 1:
                    total_dups += 1

        result = (total_dups, total_files)
        self._recursive_stats_cache[dir_path] = result
        return result

    def is_dir_fully_redundant(self, dir_path):
        """Check if all files in directory (recursively) exist in other directories."""
        # Get recursive stats - if not 100% redundant, it's not fully redundant
        dups, total = self.get_recursive_stats(dir_path)
        if total == 0:
            return True
        return dups == total

    def trash_item(self, item_path, item_type):
        """Move item to trash and update data structures."""
        item_path = Path(item_path)

        # Find which root this item belongs to
        root_for_item = None
        for root in self.root_paths:
            try:
                item_path.relative_to(root)
                root_for_item = root
                break
            except ValueError:
                continue

        if not root_for_item:
            return False

        # Initialize trash dir for this root
        trash_dir = self.init_trash_dir_for_root(root_for_item)

        # Create relative path from root
        rel_path = item_path.relative_to(root_for_item)

        # Create trash path (directly under trash dir, preserving structure)
        trash_path = trash_dir / rel_path
        trash_path.parent.mkdir(parents=True, exist_ok=True)

        # Move to trash
        try:
            shutil.move(str(item_path), str(trash_path))
        except Exception as e:
            return False

        # Add to undo stack (store simple tuple)
        self.trash_stack.append((str(item_path), str(trash_path), item_type == 'directory'))

        # Update data structures
        if item_type == 'file':
            self.remove_file_from_data(item_path)
        else:  # directory
            self.remove_directory_from_data(item_path)

        # Recalculate sorted_dirs with all directories
        self.recalculate_sorted_dirs()
        self.invalidate_relationship_cache()
        self.invalidate_size_cache()
        self.invalidate_recursive_stats_cache()
        self.invalidate_dir_contents_cache()

        return True

    def remove_file_from_data(self, file_path):
        """Remove a file from internal data structures."""
        if file_path not in self.file_to_hash:
            return

        file_hash = self.file_to_hash[file_path]
        parent_dir = file_path.parent

        # Get all directories that will be affected by this trashing
        # (all directories that have files with this hash)
        affected_dirs = set()
        if file_hash in self.hash_to_dirs:
            affected_dirs = self.hash_to_dirs[file_hash].copy()

        # Remove file from dir_all_files
        if parent_dir in self.dir_all_files:
            if file_path in self.dir_all_files[parent_dir]:
                self.dir_all_files[parent_dir].remove(file_path)

        # Remove the directory from hash_to_dirs
        if file_hash in self.hash_to_dirs:
            self.hash_to_dirs[file_hash].discard(parent_dir)

            # If no more directories have this hash, remove it
            if not self.hash_to_dirs[file_hash]:
                del self.hash_to_dirs[file_hash]

        # Remove from file_to_hash
        del self.file_to_hash[file_path]

        # Recalculate stats for ALL affected directories
        # (not just the one we trashed from, but all that had this hash)
        for dir_path in affected_dirs:
            if dir_path in self.dir_stats or dir_path in self.dir_all_files:
                # Recalculate duplicates for this directory
                new_dup = 0
                for f in self.dir_all_files.get(dir_path, []):
                    if f in self.file_to_hash:
                        fh = self.file_to_hash[f]
                        if len(self.hash_to_dirs.get(fh, set())) > 1:
                            new_dup += 1
                new_total = len(self.dir_all_files.get(dir_path, []))

                # Update or remove from dir_stats
                if new_total > 0 and new_dup > 0:
                    self.dir_stats[dir_path] = (new_dup, new_total)
                elif dir_path in self.dir_stats:
                    del self.dir_stats[dir_path]

    def remove_directory_from_data(self, dir_path):
        """Remove a directory and all its files from internal data structures.

        Also removes any child directories that are inside the removed directory.
        """
        # Find all directories that are children of dir_path (including dir_path itself)
        dirs_to_remove = [dir_path]
        for other_dir in list(self.dir_all_files.keys()):
            if other_dir != dir_path and self.is_subdir(other_dir, dir_path):
                dirs_to_remove.append(other_dir)

        # Also check dir_stats for directories that might not be in dir_all_files
        for other_dir in list(self.dir_stats.keys()):
            if other_dir != dir_path and other_dir not in dirs_to_remove and self.is_subdir(other_dir, dir_path):
                dirs_to_remove.append(other_dir)

        # Remove each directory and its files
        for dir_to_remove in dirs_to_remove:
            # Get all files in this directory
            files_to_remove = self.dir_all_files.get(dir_to_remove, [])[:]

            # Remove each file
            for file_path in files_to_remove:
                self.remove_file_from_data(file_path)

            # Remove directory from dir_all_files and dir_stats
            if dir_to_remove in self.dir_all_files:
                del self.dir_all_files[dir_to_remove]
            if dir_to_remove in self.dir_stats:
                del self.dir_stats[dir_to_remove]

        # Clean up expanded_groups if the removed directory was expanded
        self.expanded_groups.discard(dir_path)

    def undo_last_trash(self):
        """Undo the most recent trash operation."""
        if not self.trash_stack:
            return False

        original_path_str, trash_path_str, is_dir = self.trash_stack.pop()
        trash_path = Path(trash_path_str)
        original_path = Path(original_path_str)

        # Move back from trash
        try:
            original_path.parent.mkdir(parents=True, exist_ok=True)
            shutil.move(str(trash_path), str(original_path))
        except Exception as e:
            # Put it back on stack if restore failed
            self.trash_stack.append((original_path_str, trash_path_str, is_dir))
            return False

        # Clean up empty directories in trash
        self.cleanup_empty_trash_dirs(trash_path.parent)

        # Rescan to update data structures
        self.rescan()

        return True

    def restore_from_trash(self, trash_record):
        """Restore an item from trash by its metadata record."""
        trash_path = Path(trash_record['trash_path'])
        original_path = Path(trash_record['original_path'])

        if not trash_path.exists():
            return False

        try:
            original_path.parent.mkdir(parents=True, exist_ok=True)
            shutil.move(str(trash_path), str(original_path))
        except Exception as e:
            return False

        # Clean up empty directories in trash
        self.cleanup_empty_trash_dirs(trash_path.parent)

        # Remove from trash stack if present
        self.trash_stack = [d for d in self.trash_stack if d[1] != trash_record['trash_path']]

        # Rescan to update data structures
        self.rescan()

        return True

    def cleanup_empty_trash_dirs(self, start_dir):
        """Remove empty directories in trash, walking up from start_dir."""
        if not start_dir.exists():
            return

        # Walk up from start_dir, removing empty directories
        current = start_dir
        while current.exists() and current.is_dir():
            # Check if this is a trash directory
            is_trash_root = any(current == self.get_trash_dir_for_root(root) for root in self.root_paths)
            if is_trash_root:
                break

            # Check if directory is empty
            try:
                if not any(current.iterdir()):
                    # Directory is empty, remove it
                    current.rmdir()
                    # Move up to parent
                    current = current.parent
                else:
                    # Directory not empty, stop
                    break
            except (OSError, PermissionError):
                # Can't remove or access, stop
                break

    def format_mtime(self, path):
        """Format modification time compactly."""
        try:
            mtime = path.stat().st_mtime
            dt = datetime.fromtimestamp(mtime)
            now = datetime.now()

            # If today, show time
            if dt.date() == now.date():
                return dt.strftime("%H:%M")
            # If this year, show month-day
            elif dt.year == now.year:
                return dt.strftime("%m-%d")
            # Otherwise show year
            else:
                return dt.strftime("%Y")
        except:
            return "-----"

    def needs_scroll_indicators(self, scroll_offset, total_items, visible_height):
        """Check if scroll indicators are needed.

        Returns (needs_top, needs_bottom) tuple.
        Indicators overlay content, so they don't reduce visible space.
        """
        if total_items <= visible_height:
            return False, False
        needs_top = scroll_offset > 0
        needs_bottom = scroll_offset + visible_height < total_items
        return needs_top, needs_bottom

    def draw_position_indicator(self, win, height, width, scroll_offset, total_items, visible_height):
        """Draw position indicator like '0% (1-18 of 23)' in bottom right."""
        if total_items <= 0:
            return

        # Indicators overlay content, so visible_height is the actual visible count
        if total_items <= visible_height:
            # All items visible
            status = f" 1-{total_items} of {total_items} "
        else:
            max_offset = total_items - visible_height
            # Clamp percent to 0-100 range
            percent = min(100, max(0, (scroll_offset / max_offset * 100))) if max_offset > 0 else 0
            first = scroll_offset + 1
            last = min(scroll_offset + visible_height, total_items)
            status = f" {percent:.0f}% ({first}-{last} of {total_items}) "

        try:
            win.addstr(height - 1, width - len(status) - 1, status, curses.A_DIM)
        except curses.error:
            pass

    def draw_scroll_indicators(self, win, height, width, scroll_offset, total_items, visible_height, content_start_y=1, show_position=True):
        """Draw scroll bar and more-content arrows.

        Args:
            win: curses window
            height: window height
            width: window width
            scroll_offset: current scroll position
            total_items: total number of items
            visible_height: number of visible lines for content
            content_start_y: y position where content starts (for top arrow)
        """
        needs_top, needs_bottom = self.needs_scroll_indicators(scroll_offset, total_items, visible_height)

        if not needs_top and not needs_bottom:
            return  # No scrolling needed

        # Draw up indicator on its own line if content above
        if needs_top:
            try:
                indicator = "     more    "
                win.addstr(content_start_y, 1, indicator, curses.A_DIM)
            except curses.error:
                pass

        # Draw down indicator on its own line if content below
        if needs_bottom:
            try:
                indicator = "     more    "
                win.addstr(height - 2, 1, indicator, curses.A_DIM)
            except curses.error:
                pass

        # Calculate scrollbar area (full content height, inclusive of last row before border)
        scrollbar_start_y = content_start_y
        scrollbar_end_y = height - 1  # exclusive end (height - 2 is last drawable row)
        scrollbar_height = scrollbar_end_y - scrollbar_start_y

        if scrollbar_height < 3:
            return  # Not enough room for scroll bar

        # Calculate thumb size and position
        visible_ratio = visible_height / total_items
        thumb_size = max(1, int(scrollbar_height * visible_ratio))

        scroll_range = total_items - visible_height
        if scroll_range > 0:
            scroll_ratio = scroll_offset / scroll_range
            thumb_pos = round((scrollbar_height - thumb_size) * scroll_ratio)
        else:
            thumb_pos = 0

        # Draw scroll bar track and thumb
        for i in range(scrollbar_height):
            y = scrollbar_start_y + i
            try:
                if i >= thumb_pos and i < thumb_pos + thumb_size:
                    win.addstr(y, width - 2, "", curses.A_DIM)
                else:
                    win.addstr(y, width - 2, "", curses.A_DIM)
            except curses.error:
                pass

        # Draw position indicator for non-help windows
        if show_position:
            self.draw_position_indicator(win, height, width, scroll_offset, total_items, visible_height)

    def draw_main_view(self, win, height, width, selected_idx, scroll_offset):
        """Draw the main directory list view."""
        win.clear()
        win.border()

        # Show statistics in upper right corner
        total_files, duplicate_files, _ = self.get_current_stats()
        stats_text = self.format_stats_text(duplicate_files, total_files)
        stats_x = width - len(stats_text) - 2
        if stats_x > 2:
            try:
                win.addstr(0, stats_x, stats_text, curses.A_DIM)
            except curses.error:
                pass

        # Build display list with collapsible groups
        display_list = self.build_display_list()

        title = f" All Directories ({len(self.sorted_dirs)}) "
        try:
            win.addstr(0, 2, title[:width-4], curses.A_BOLD)
        except curses.error:
            pass

        if not display_list:
            win.addstr(2, 1, "No directories to display")
            win.noutrefresh()
            return

        # Column headers with full-width underline, highlight current sort column
        header_line = 1
        base_attr = curses.A_BOLD | curses.A_UNDERLINE
        sort_attr = curses.A_BOLD | curses.A_UNDERLINE | curses.A_REVERSE
        try:
            # Draw full-width underline first
            win.addstr(header_line, 1, " " * (width - 2), curses.A_UNDERLINE)
            # Then draw headers on top, highlighting the current sort column
            win.addstr(header_line, 1, " %Dup", sort_attr if self.sort_mode == 'redundancy' else base_attr)
            win.addstr(header_line, 8, "#Dup", sort_attr if self.sort_mode == 'duplicates' else base_attr)
            win.addstr(header_line, 14, "Total", sort_attr if self.sort_mode == 'total' else base_attr)
            win.addstr(header_line, 21, "Directory Path", sort_attr if self.sort_mode == 'path' else base_attr)
            # Right-aligned headers
            if width > 60:
                size_attr = sort_attr if self.sort_mode == 'size' else base_attr
                mtime_attr = sort_attr if self.sort_mode == 'mtime' else base_attr
                win.addstr(header_line, width - 13, "Size", size_attr)
                win.addstr(header_line, width - 7, "MTime", mtime_attr)
        except curses.error:
            pass

        # Display items
        display_height = height - 3  # Account for border, header, and bottom border

        # Check if we need scroll indicators (they take up content lines)
        needs_top, needs_bottom = self.needs_scroll_indicators(scroll_offset, len(display_list), display_height)
        content_lines = display_height - (1 if needs_top else 0) - (1 if needs_bottom else 0)
        start_offset = 1 if needs_top else 0

        for i in range(content_lines):
            idx = scroll_offset + i
            if idx >= len(display_list):
                break

            item = display_list[idx]

            if item[0] == 'dir':
                # Regular directory entry
                _, dir_path, (duplicates, total), is_child = item
                score = calculate_redundancy_score(duplicates, total)
                path_str = self.get_path_with_root(dir_path)
                mtime_str = self.format_mtime(dir_path)
                dir_size = self.get_dir_size(dir_path)

                # Format size
                if dir_size < 1024:
                    size_str = f"{dir_size}B"
                elif dir_size < 1024 * 1024:
                    size_str = f"{dir_size/1024:.1f}K"
                elif dir_size < 1024 * 1024 * 1024:
                    size_str = f"{dir_size/(1024*1024):.1f}M"
                else:
                    size_str = f"{dir_size/(1024*1024*1024):.1f}G"

                # Format columns - stats always aligned, only path is indented
                percent_col = f"{score:6.1%}" if score > 0 else "   0% "
                dup_col = f"{duplicates:5d}"
                total_col = f"{total:5d}"

                # Left part: stats always aligned, path indented for children
                indent = "  " if is_child else ""
                left_part = f"{percent_col} {dup_col}  {total_col}  {indent}{path_str}"

                # Right part: size and mtime
                right_part = f"{size_str:>6s}  {mtime_str}"

                # Calculate available space
                max_len = width - 3
                right_len = len(right_part) + 2  # +2 for spacing

                if len(left_part) + right_len <= max_len:
                    # Enough space for both - pad middle with spaces
                    padding = max_len - len(left_part) - len(right_part)
                    line = left_part + " " * padding + right_part
                elif len(left_part) <= max_len:
                    # Not enough for right part, just show left (truncate if needed)
                    line = left_part[:max_len]
                else:
                    # Truncate left part
                    line = left_part[:max_len-3] + "..."

            elif item[0] == 'collapse':
                # Collapse line
                _, parent_path, child_dirs, total_files, total_dups, total_size = item
                num_dirs = len(child_dirs)
                is_expanded = parent_path in self.expanded_groups

                # Proper pluralization
                dir_word = "subdir" if num_dirs == 1 else "subdirs"
                file_word = "file" if total_files == 1 else "files"

                # Format size
                if total_size < 1024:
                    size_str = f"{total_size}B"
                elif total_size < 1024 * 1024:
                    size_str = f"{total_size/1024:.1f}K"
                elif total_size < 1024 * 1024 * 1024:
                    size_str = f"{total_size/(1024*1024):.1f}M"
                else:
                    size_str = f"{total_size/(1024*1024*1024):.1f}G"

                if is_expanded:
                    line = f"         {num_dirs} {dir_word}, {total_files} {file_word}, {size_str}"
                else:
                    line = f"         {num_dirs} {dir_word}, {total_files} {file_word}, {size_str}"

            # For collapse lines, truncate if too long
            if item[0] == 'collapse':
                max_len = width - 3
                if len(line) > max_len:
                    line = line[:max_len-3] + "..."

            y = i + 2 + start_offset  # Start after header (and top indicator if present)
            attr = curses.A_REVERSE if idx == selected_idx else curses.A_NORMAL
            try:
                win.addstr(y, 1, line.ljust(width - 4), attr)  # Leave room for scroll bar
            except curses.error:
                pass

        # Draw scroll indicators
        self.draw_scroll_indicators(win, height, width, scroll_offset, len(display_list), display_height, content_start_y=2)

        win.noutrefresh()

    def draw_dir_detail_view(self, win, height, width, view, selected_idx, scroll_offset):
        """Draw directory detail view showing only files in that directory."""
        dir_path = view['data']['dir_path']

        win.clear()
        win.border()

        # Get files and subdirectories in this directory
        items = self.get_all_files_with_counts(dir_path)

        # Title bar: dir name on left, recursive stats on right
        title = f" {self.get_path_with_root(dir_path)}/ "
        dups, total = self.get_recursive_stats(dir_path)
        stats_text = self.format_stats_text(dups, total)
        stats_x = width - len(stats_text) - 2
        try:
            win.addstr(0, 2, title[:stats_x-3], curses.A_BOLD)
            if stats_x > len(title) + 2:
                win.addstr(0, stats_x, stats_text, curses.A_DIM)
        except curses.error:
            pass

        # Column headers on line 1 with full underline
        header_line = 1
        base_attr = curses.A_BOLD | curses.A_UNDERLINE
        try:
            win.addstr(header_line, 1, " " * (width - 2), curses.A_UNDERLINE)
            win.addstr(header_line, 1, " Copies", base_attr)
            win.addstr(header_line, 10, "Name", base_attr)
            if width > 50:
                win.addstr(header_line, width - 13, "Size", base_attr)
                win.addstr(header_line, width - 7, "MTime", base_attr)
        except curses.error:
            pass

        if not items:
            try:
                win.addstr(2, 1, "  (No files)")
            except curses.error:
                pass
            win.noutrefresh()
            return

        # Display items (files and directories)
        display_height = height - 3  # Account for border, title, column header

        # Draw items (indicators will overlay first/last lines)
        for i in range(display_height):
            idx = scroll_offset + i
            if idx >= len(items):
                break

            name, count_or_stats, path, item_type = items[idx]

            # Handle divider line
            if item_type == 'divider':
                divider_line = "" * (width - 4)
                y = i + 2
                try:
                    win.addstr(y, 1, divider_line, curses.A_DIM)
                except curses.error:
                    pass
                continue

            if item_type == 'dir':
                # Directory entry - show redundancy stats
                dups, total = count_or_stats
                if total > 0:
                    score = calculate_redundancy_score(dups, total)
                    count_col = f"{score:5.0%}"
                else:
                    count_col = "    -"
            else:
                # File entry - show copy count
                count_col = f"{count_or_stats:5d}"

            # Get size
            try:
                if item_type == 'dir':
                    size_bytes = self.get_dir_size(path)
                else:
                    size_bytes = path.stat().st_size
                if size_bytes < 1024:
                    size_str = f"{size_bytes}B"
                elif size_bytes < 1024 * 1024:
                    size_str = f"{size_bytes/1024:.1f}K"
                elif size_bytes < 1024 * 1024 * 1024:
                    size_str = f"{size_bytes/(1024*1024):.1f}M"
                else:
                    size_str = f"{size_bytes/(1024*1024*1024):.1f}G"
            except:
                size_str = "---"

            mtime_str = self.format_mtime(path)

            # Left part: count/percent and name (4 spaces to align with "Name" header at col 10)
            left_part = f"{count_col}    {name}"

            # Right part: size and mtime
            right_part = f"{size_str:>6s}  {mtime_str}"

            # Calculate available space
            max_len = width - 3
            right_len = len(right_part) + 2  # +2 for spacing

            if len(left_part) + right_len <= max_len:
                # Enough space for both - pad middle with spaces
                padding = max_len - len(left_part) - len(right_part)
                line = left_part + " " * padding + right_part
            elif len(left_part) <= max_len:
                # Not enough for right part, just show left
                line = left_part[:max_len]
            else:
                # Truncate left part
                line = left_part[:max_len-3] + "..."

            y = i + 2  # Start after headers
            # Don't allow selection of divider line
            attr = curses.A_REVERSE if (idx == selected_idx and item_type != 'divider') else curses.A_NORMAL
            try:
                win.addstr(y, 1, line.ljust(width - 4), attr)  # Leave room for scroll bar
            except curses.error:
                pass

        # Draw scroll indicators
        self.draw_scroll_indicators(win, height, width, scroll_offset, len(items), display_height, content_start_y=2)

        win.noutrefresh()

    def draw_file_detail_view(self, win, height, width, view, selected_idx, scroll_offset):
        """Draw file detail view showing all directories containing this file."""
        file_path = view['data']['file_path']

        win.clear()
        win.border()

        title = f" {self.get_path_with_root(file_path)} "
        try:
            win.addstr(0, 2, title[:width-4], curses.A_BOLD)
        except curses.error:
            pass

        # Get all directories containing this file
        dirs_with_file = self.get_dirs_containing_file(file_path)

        # Headers
        try:
            win.addstr(2, 1, f"Directories Containing This File ({len(dirs_with_file)}):", curses.A_BOLD)
            win.addstr(3, 1, " %Dup", curses.A_BOLD | curses.A_UNDERLINE)
            win.addstr(3, 8, "Dup", curses.A_BOLD | curses.A_UNDERLINE)
            win.addstr(3, 13, "Total", curses.A_BOLD | curses.A_UNDERLINE)
            win.addstr(3, 20, "MTime", curses.A_BOLD | curses.A_UNDERLINE)
            win.addstr(3, 28, "Directory Path", curses.A_BOLD | curses.A_UNDERLINE)
        except curses.error:
            pass

        # Display directories
        display_height = height - 5

        # Draw directories (indicators will overlay first/last lines)
        for i in range(display_height):
            idx = self.scroll_offset + i
            if idx >= len(dirs_with_file):
                break

            dir_path = dirs_with_file[idx]
            if dir_path in self.dir_stats:
                duplicates, total = self.dir_stats[dir_path]
            else:
                duplicates, total = 0, len(self.dir_all_files.get(dir_path, []))

            score = calculate_redundancy_score(duplicates, total)
            path_str = self.get_path_with_root(dir_path)
            mtime_str = self.format_mtime(dir_path)

            percent_col = f"{score:6.1%}" if score > 0 else "   0% "
            dup_col = f"{duplicates:4d}"
            total_col = f"{total:5d}"

            line = f"{percent_col} {dup_col}  {total_col}  {mtime_str}  {path_str}"
            max_len = width - 3
            if len(line) > max_len:
                line = line[:max_len-3] + "..."

            y = i + 4  # Start after headers
            attr = curses.A_REVERSE if idx == selected_idx else curses.A_NORMAL
            try:
                win.addstr(y, 1, line.ljust(width - 4), attr)  # Leave room for scroll bar
            except curses.error:
                pass

        # Draw scroll indicators
        self.draw_scroll_indicators(win, height, width, self.scroll_offset, len(dirs_with_file), display_height, content_start_y=4)

        win.noutrefresh()
    def draw_trash_pane(self, win, height, width):
        """Draw the trash viewer in full screen."""
        win.clear()
        win.border()

        # Show current path in title
        if self.trash_path_stack:
            current_trash_path, current_orig_path, _, _ = self.trash_path_stack[-1]
            # Find root name for this path
            for root_path in self.root_paths:
                trash_dir = self.get_trash_dir_for_root(root_path)
                try:
                    rel_path = Path(current_trash_path).relative_to(trash_dir)
                    title = f" Trash: {root_path.name}/{rel_path}/ "
                    break
                except ValueError:
                    continue
            else:
                title = f" Trash: {Path(current_orig_path).name}/ "
        else:
            title = " Trash (~dedupdir-trash) "
        win.addstr(0, 2, title[:width-4], curses.A_BOLD | curses.A_REVERSE)

        # Show "no duplicates" message if applicable
        if self.show_no_duplicates_message:
            msg = "No duplicate files found. You can restore files from trash below, or press 'q' to quit."
            try:
                win.addstr(2, 2, msg[:width-4], curses.A_BOLD)
            except curses.error:
                pass

        # Get items for current level
        current_trash_path = self.trash_path_stack[-1][0] if self.trash_path_stack else None
        items = self.get_trash_items(current_trash_path)

        if not items:
            msg_y = 4 if self.show_no_duplicates_message else 2
            win.addstr(msg_y, 2, "Trash is empty", curses.A_DIM)
            if self.show_no_duplicates_message:
                win.addstr(msg_y + 2, 2, "Press 'q' to quit.", curses.A_DIM)
            win.noutrefresh()
            return

        # Display trash items
        start_y = 4 if self.show_no_duplicates_message else 1
        display_height = (height - start_y - 1) if self.show_no_duplicates_message else (height - 2)

        # Check if we need scroll indicators (they take up content lines)
        needs_top, needs_bottom = self.needs_scroll_indicators(self.trash_offset, len(items), display_height)
        content_lines = display_height - (1 if needs_top else 0) - (1 if needs_bottom else 0)
        indicator_offset = 1 if needs_top else 0

        for i in range(content_lines):
            idx = self.trash_offset + i
            if idx >= len(items):
                break

            item = items[idx]
            item_type = item.get('type', 'unknown')
            rel_path = item.get('relative_path', 'unknown')
            root_name = item.get('root_name', '')
            timestamp = item.get('timestamp', '')[:19]  # YYYY-MM-DDTHH:MM:SS
            file_count = item.get('file_count', 0)
            size = item.get('size', 0)

            # Format size
            if size < 1024:
                size_str = f"{size}B"
            elif size < 1024 * 1024:
                size_str = f"{size/1024:.1f}K"
            elif size < 1024 * 1024 * 1024:
                size_str = f"{size/(1024*1024):.1f}M"
            else:
                size_str = f"{size/(1024*1024*1024):.1f}G"

            # Format: [type] root/path (with file count for dirs)
            type_icon = "" if item_type == "file" else ""
            if item_type == "directory" and file_count > 0:
                path_part = f"{type_icon} {root_name}/{rel_path}/ ({file_count} files)"
            elif item_type == "directory":
                path_part = f"{type_icon} {root_name}/{rel_path}/"
            else:
                path_part = f"{type_icon} {root_name}/{rel_path}"

            # Format timestamp as "MMM DD HH:MM" (e.g., "Jan 20 14:23")
            if len(timestamp) >= 16:
                try:
                    dt = datetime.fromisoformat(timestamp)
                    time_part = dt.strftime("%b %d %H:%M")
                except:
                    time_part = timestamp[5:16]
            else:
                time_part = timestamp

            y = i + start_y + indicator_offset
            attr = curses.A_REVERSE if idx == self.trash_selected_idx else curses.A_NORMAL

            try:
                # Right side: size and timestamp
                right_part = f"{size_str:>7}  {time_part}"
                right_width = len(right_part) + 2

                # Calculate available space for path
                path_max_width = width - right_width - 3

                # Truncate path if needed
                if len(path_part) > path_max_width:
                    path_part = path_part[:path_max_width-3] + "..."

                # Draw path on left
                win.addstr(y, 1, path_part, attr)

                # Draw size and timestamp on right
                right_x = width - right_width - 1
                win.addstr(y, right_x, right_part, attr | curses.A_DIM)
            except curses.error:
                pass

        # Draw scroll indicators
        self.draw_scroll_indicators(win, height, width, self.trash_offset, len(items), display_height, content_start_y=start_y)

        win.noutrefresh()

    def get_file_type(self, file_path):
        """Detect file type: 'text', 'image', 'binary'."""
        try:
            # Check by extension first
            suffix = file_path.suffix.lower()

            # Image extensions
            image_exts = {'.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.tif', '.webp', '.ico', '.svg'}
            if suffix in image_exts:
                return 'image'

            # Read first chunk to detect text vs binary
            with open(file_path, 'rb') as f:
                chunk = f.read(8192)
                if not chunk:
                    return 'text'  # Empty file

                # Check for null bytes (strong indicator of binary)
                if b'\x00' in chunk:
                    return 'binary'

                # Try to decode as UTF-8
                try:
                    chunk.decode('utf-8')
                    return 'text'
                except UnicodeDecodeError:
                    return 'binary'
        except (IOError, OSError):
            return 'binary'

    def get_file_content_for_viewing(self, file_path):
        """Get file content/info for viewing. Returns (metadata_lines, content_lines, file_type)."""
        file_type = self.get_file_type(file_path)
        metadata_lines = []
        content_lines = []

        try:
            file_size = file_path.stat().st_size
            size_mb = file_size / (1024 * 1024)

            # Add header with file info (metadata)
            metadata_lines.append(f"File: {file_path.name}")
            metadata_lines.append(f"Path: {file_path}")
            metadata_lines.append(f"Size: {file_size:,} bytes ({size_mb:.2f} MB)")
            metadata_lines.append(f"Type: {file_type.upper()}")

            if file_type == 'image':
                # Try to get EXIF data or image info
                content_lines.append("")

                # Try exiftool first
                try:
                    import subprocess
                    result = subprocess.run(['exiftool', str(file_path)],
                                          capture_output=True, text=True, timeout=5)
                    if result.returncode == 0:
                        content_lines.extend(result.stdout.splitlines())
                    else:
                        raise Exception("exiftool failed")
                except:
                    # Try identify (ImageMagick)
                    try:
                        result = subprocess.run(['identify', '-verbose', str(file_path)],
                                              capture_output=True, text=True, timeout=5)
                        if result.returncode == 0:
                            content_lines.extend(result.stdout.splitlines())
                        else:
                            raise Exception("identify failed")
                    except:
                        # Just show basic info
                        content_lines.append("(No image tools available - install exiftool or ImageMagick for details)")
                        content_lines.append("")
                        content_lines.append("This is an image file. Use an image viewer to see it.")

            elif file_type == 'text':

                # Limit reading to 10MB for text files
                max_bytes = 10 * 1024 * 1024

                with open(file_path, 'r', encoding='utf-8', errors='replace') as f:
                    bytes_read = 0
                    for line_num, line in enumerate(f, 1):
                        if bytes_read >= max_bytes:
                            content_lines.append("")
                            content_lines.append(f"... (file truncated at {max_bytes:,} bytes, showing first ~{line_num} lines)")
                            break
                        content_lines.append(line.rstrip('\n\r'))
                        bytes_read += len(line.encode('utf-8'))

            else:  # binary

                # Show hex dump of first 4KB
                max_bytes = 4096
                with open(file_path, 'rb') as f:
                    data = f.read(max_bytes)

                # Create hex dump
                for i in range(0, len(data), 16):
                    chunk = data[i:i+16]
                    hex_part = ' '.join(f'{b:02x}' for b in chunk)
                    ascii_part = ''.join(chr(b) if 32 <= b < 127 else '.' for b in chunk)
                    content_lines.append(f'{i:08x}  {hex_part:<48}  {ascii_part}')

                if file_size > max_bytes:
                    content_lines.append("")
                    content_lines.append(f"... (showing first {max_bytes:,} of {file_size:,} bytes)")

        except Exception as e:
            content_lines.append(f"Error reading file: {e}")

        return metadata_lines, content_lines, file_type

    def draw_file_viewer(self, stdscr, file_path, metadata_lines, content_lines, scroll_offset):
        """Draw file viewer as centered overlay window (75% width, 85% height)."""
        term_height, term_width = stdscr.getmaxyx()

        # Create centered overlay window (75% width, 85% height)
        height = int(term_height * 0.85)
        width = int(term_width * 0.75)
        y = (term_height - height) // 2
        x = (term_width - width) // 2

        # Create window for file viewer
        viewer_win = curses.newwin(height, width, y, x)
        viewer_win.clear()
        viewer_win.border()

        # Title
        title = f" Viewing: {file_path.name} (q/ESC to close, arrows/j/k to scroll) "
        viewer_win.addstr(0, 2, title[:width-4], curses.A_BOLD | curses.A_REVERSE)

        # Draw metadata section (fixed, not scrollable, in dim color)
        metadata_height = len(metadata_lines)
        for i, line in enumerate(metadata_lines):
            display_line = line[:width-3]
            try:
                viewer_win.addstr(1 + i, 1, display_line, curses.A_DIM)
            except curses.error:
                pass

        # Draw separator line
        separator_y = 1 + metadata_height
        try:
            viewer_win.addstr(separator_y, 1, "" * (width - 2))
        except curses.error:
            pass

        # Calculate visible area for content (below metadata and separator)
        content_start_y = separator_y + 1
        content_height = height - content_start_y - 1  # -1 for bottom border
        # When scrolled, top indicator takes one line, reducing content area by 1
        if len(content_lines) <= content_height:
            max_offset = 0
        else:
            max_offset = max(0, len(content_lines) - content_height + 1)
        scroll_offset = max(0, min(scroll_offset, max_offset))

        # Draw content lines (scrollable, indicators will overlay first/last lines)
        for i in range(content_height):
            line_idx = scroll_offset + i
            if line_idx < len(content_lines):
                line = content_lines[line_idx]
                # Truncate line to fit width (leave room for scroll bar)
                display_line = line[:width-5]
                try:
                    viewer_win.addstr(content_start_y + i, 1, display_line)
                except curses.error:
                    pass  # Ignore errors from writing to last position

        # Draw scroll indicators
        self.draw_scroll_indicators(viewer_win, height, width, scroll_offset, len(content_lines), content_height, content_start_y=content_start_y)

        viewer_win.noutrefresh()
        curses.doupdate()
        return scroll_offset, len(content_lines), max_offset

    def get_help_text(self, mode):
        """Get context-sensitive help text for the given mode."""
        if mode == 'main':
            return """Main View - Exploring Duplicate Files

Navigation:
  / or j/k        Navigate items
  / or h/l        Collapse/expand groups
  Enter             Drill down into directory
  PgUp/PgDn         Page up/down
  Ctrl-B/Ctrl-F     Page up/down
  Home/End or g/G   Jump to first/last item

Sorting:
  s                 Cycle sort mode (current column highlighted)
                    Modes: %Dup, #Dup, Total, Path, Size, MTime

Actions:
  o                 Open directory in file browser
  t                 Trash selected directory
  P                 Promote item to parent directory
  u                 Undo last trash operation
  T                 View trash
  q                 Quit

Directories showing 100% redundancy are safe to trash -
all their files exist elsewhere. Collapsed groups ()
contain multiple 100% redundant subdirectories."""

        elif mode == 'trash':
            return """Trash Viewer

Navigation:
  / or j/k        Navigate trash items
  PgUp/PgDn         Page up/down
  Ctrl-B/Ctrl-F     Page up/down
  Home/End or </>   Jump to first/last item

Actions:
  v                 View selected file
  o                 Open selected file with desktop viewer
  r                 Restore selected item
  t or Esc          Return to main view
  q                 Quit

Files are moved to ~dedupdir-trash/ in each root
directory. They remain there until you manually
delete the trash directories."""

        elif mode == 'dir_detail':
            return """Directory Detail View

Navigation:
  / or j/k        Navigate files and subdirectories
  Enter or l/      Drill into file or subdirectory
  Esc or h/        Go back to previous view
  PgUp/PgDn         Page up/down
  Ctrl-B/Ctrl-F     Page up/down
  Home/End or g/G   Jump to first/last item

Actions:
  v                 View selected file
  o                 Open selected item
  t                 Trash selected item
  P                 Promote: move item to parent directory
  u                 Undo last trash operation
  q                 Quit (with confirmation)

The redundancy count shows how many directories contain
a copy of each file. Files with count 1 are unique."""

        elif mode == 'file_detail':
            return """File Detail View

This view shows all directories containing copies of
a specific file (identified by content hash).

Navigation:
  / or j/k        Navigate directories
  Enter or l/      Drill into directory
  Esc or h/        Go back to previous view
  PgUp/PgDn         Page up/down

Actions:
  v                 View file content
  o                 Open file
  t                 Trash selected directory
  u                 Undo last trash operation
  q                 Quit (with confirmation)"""

        elif mode == 'viewer':
            return """File Viewer

Navigation:
  / or j/k        Scroll up/down one line
  PgUp/PgDn         Scroll up/down one page
  Ctrl-B/Ctrl-F     Page up/down (alternative)
  Home/End or </>   Jump to start/end

Display:
  - Metadata shown at top (file, path, size, type)
  - Horizontal line separates metadata from content
  - Text files: shows content (up to 10MB)
  - Images: shows EXIF data if available
  - Binary files: shows hex dump (first 4KB)

Actions:
  q or Esc          Close viewer and return"""

        elif mode == 'confirm':
            return """Trash Confirmation

You are about to trash an item that is not fully
redundant. If you trash it, you will lose data unless
you restore it from the trash.

Actions:
  y or Y            Confirm - move to trash
  n or N            Cancel
  Esc               Cancel
  q                 Quit application
"""
        else:
            return "Help not available for this mode."

    def draw_help_popup(self, stdscr, mode, scroll_offset=0):
        """Draw help popup as centered overlay with scrolling support."""
        term_height, term_width = stdscr.getmaxyx()

        # Help window size (80% width, 80% height)
        height = int(term_height * 0.80)
        width = int(term_width * 0.80)
        width = min(width, 80)  # Max 80 chars wide
        y = (term_height - height) // 2
        x = (term_width - width) // 2

        # Create help window
        help_win = curses.newwin(height, width, y, x)
        help_win.clear()
        help_win.border()

        # Title
        title = " Help - h//Esc to close, /j/k to scroll "
        help_win.addstr(0, (width - len(title)) // 2, title[:width-2], curses.A_BOLD | curses.A_REVERSE)

        # Get help text and display
        help_text = self.get_help_text(mode)
        lines = help_text.split('\n')

        # Calculate visible area and scroll bounds
        visible_height = height - 2
        # When scrolled, top indicator takes one line, so we can show one less content line
        # max_offset is the scroll position where the last line is visible
        if len(lines) <= visible_height:
            max_offset = 0
        else:
            # Once scrolled, top indicator appears, reducing content area by 1
            max_offset = max(0, len(lines) - visible_height + 1)
        scroll_offset = max(0, min(scroll_offset, max_offset))

        # Draw help lines with scrolling (indicators will overlay first/last lines)
        for i in range(visible_height):
            line_idx = scroll_offset + i
            if line_idx < len(lines):
                display_line = lines[line_idx][:width-5]  # Leave room for scroll bar
                try:
                    help_win.addstr(1 + i, 1, display_line)
                except curses.error:
                    pass

        # Draw scroll indicators
        self.draw_scroll_indicators(help_win, height, width, scroll_offset, len(lines), visible_height, content_start_y=1, show_position=True)

        help_win.noutrefresh()
        curses.doupdate()
        return scroll_offset, len(lines)

    def show_help_viewer(self, stdscr, mode):
        """Show scrollable help viewer and handle navigation until exit."""
        scroll_offset = 0
        while True:
            scroll_offset, total_lines = self.draw_help_popup(stdscr, mode, scroll_offset)
            help_key = stdscr.getch()

            if help_key in (ord('h'), ord('H'), curses.KEY_LEFT, 27):  # h, H, , or ESC
                break
            elif help_key == curses.KEY_RESIZE:
                stdscr.clear()
                stdscr.refresh()
                continue
            elif help_key in (curses.KEY_UP, ord('k')):
                scroll_offset = max(0, scroll_offset - 1)
            elif help_key in (curses.KEY_DOWN, ord('j')):
                help_height = int(stdscr.getmaxyx()[0] * 0.80)
                visible_height = help_height - 2
                max_offset = max(0, total_lines - visible_height + 1) if total_lines > visible_height else 0
                scroll_offset = min(max_offset, scroll_offset + 1)
            elif help_key in (curses.KEY_PPAGE, 2):  # Page Up or Ctrl-B
                help_height = int(stdscr.getmaxyx()[0] * 0.80)
                visible_height = help_height - 2
                scroll_offset = max(0, scroll_offset - visible_height)
            elif help_key in (curses.KEY_NPAGE, 6):  # Page Down or Ctrl-F
                help_height = int(stdscr.getmaxyx()[0] * 0.80)
                visible_height = help_height - 2
                max_offset = max(0, total_lines - visible_height + 1) if total_lines > visible_height else 0
                scroll_offset = min(max_offset, scroll_offset + visible_height)
            elif help_key in (curses.KEY_HOME, ord('<')):
                scroll_offset = 0
            elif help_key in (curses.KEY_END, ord('>')):
                help_height = int(stdscr.getmaxyx()[0] * 0.80)
                visible_height = help_height - 2
                scroll_offset = max(0, total_lines - visible_height + 1) if total_lines > visible_height else 0

    def open_file_with_system_app(self, file_path):
        """Open file with system's default application (cross-platform)."""
        try:
            import subprocess
            import platform
            system = platform.system()
            if system == 'Darwin':  # macOS
                subprocess.Popen(['open', str(file_path)])
            elif system == 'Windows':
                subprocess.Popen(['start', str(file_path)], shell=True)
            else:  # Linux and others
                subprocess.Popen(['xdg-open', str(file_path)])
        except Exception:
            pass  # Silently fail if can't open

    def get_hint_text(self, mode):
        """Get hint bar text for the given mode."""
        if mode == 'main':
            return ":Navigate  Enter:Drill Down  s:Sort  o:Open  t:Trash  T:View Trash  q:Quit"
        elif mode == 'dir_detail':
            return ":Navigate  Enter:Drill Down  v:View  o:Open  t:Trash  P:Promote  Esc:Back"
        elif mode == 'file_detail':
            return ":Navigate  Enter:Drill Down  v:View  o:Open  t:Trash  Esc:Back"
        elif mode == 'trash':
            if self.trash_path_stack:
                return ":Navigate  Enter:Open  r:Restore  v:View  o:Open  h/Esc:Back"
            else:
                return ":Navigate  Enter:Open  r:Restore  v:View  o:Open  Esc:Exit"
        elif mode == 'viewer':
            return ":Scroll  PgUp/PgDn:Page  q:Close"
        elif mode == 'confirm':
            return "y:Yes  n:No  Esc:Cancel"
        else:
            return ""

    def draw_hint_bar(self, stdscr, mode):
        """Draw hint bar at bottom of screen."""
        height, width = stdscr.getmaxyx()

        # Check for quit message flash
        if self.show_quit_message:
            hint_text = ">>> Press 'q' to quit <<<"
            self.show_quit_message = False  # Clear after one display
        else:
            hint_text = self.get_hint_text(mode)
        help_text = "[?] Help"

        # Add verification status if running
        verify_text = ""
        if self.cached_hashes and not self.verification_complete and not self.verification_error:
            verified, total = self.verification_progress
            if total > 0:
                percent = (verified * 100) // total
                verify_text = f" [Verifying: {percent}%]"

        # Calculate positions
        available_width = width - len(help_text) - len(verify_text) - 4  # -4 for spacing
        if len(hint_text) > available_width:
            hint_text = hint_text[:available_width-3] + "..."

        # Draw hint bar
        try:
            # Clear the line first with normal color, then draw text
            stdscr.addstr(height - 1, 0, " " * (width - 1))
            # Draw hints on left
            stdscr.addstr(height - 1, 1, hint_text, curses.A_DIM)
            # Draw verification status in middle (if present)
            if verify_text:
                verify_x = 1 + len(hint_text) + 1
                stdscr.addstr(height - 1, verify_x, verify_text, curses.A_DIM)
            # Draw help on right
            stdscr.addstr(height - 1, width - len(help_text) - 1, help_text, curses.A_DIM)
            stdscr.noutrefresh()
        except curses.error:
            pass  # Ignore errors at edge of screen

    def show_verification_error(self, stdscr, error_message):
        """Display a fatal verification error and wait for user to acknowledge."""
        while True:
            height, width = stdscr.getmaxyx()
            stdscr.clear()

            # Draw error box
            box_width = min(70, width - 4)
            lines = []
            for line in error_message.split('\n'):
                # Word wrap long lines
                while len(line) > box_width - 4:
                    lines.append(line[:box_width - 4])
                    line = line[box_width - 4:]
                lines.append(line)

            box_height = len(lines) + 6  # Title, blank, lines, blank, instruction, border
            box_y = (height - box_height) // 2
            box_x = (width - box_width) // 2

            # Create dialog window
            try:
                dialog_win = curses.newwin(box_height, box_width, box_y, box_x)
                dialog_win.clear()
                dialog_win.border()

                # Title
                title = " CACHE VERIFICATION FAILED "
                dialog_win.addstr(0, (box_width - len(title)) // 2, title, curses.A_BOLD | curses.A_REVERSE)

                # Error message
                for i, line in enumerate(lines):
                    try:
                        dialog_win.addstr(2 + i, 2, line[:box_width - 4])
                    except curses.error:
                        pass

                # Instruction
                instruction = "Press any key to exit"
                dialog_win.addstr(box_height - 2, (box_width - len(instruction)) // 2, instruction, curses.A_DIM)

                dialog_win.refresh()
            except curses.error:
                pass

            # Wait for key
            key = stdscr.getch()
            if key == curses.KEY_RESIZE:
                stdscr.clear()
                stdscr.refresh()
                continue
            else:
                break

    def draw_dialog(self, stdscr, message, prompt, title=None, message_style=0, prompt_style=curses.A_REVERSE):
        """Draw a dialog box in the center of the screen.

        Args:
            stdscr: curses screen
            message: Message text (can contain newlines)
            prompt: Prompt text shown at bottom
            title: Optional title shown in top border
            message_style: curses attribute for message text (default: none)
            prompt_style: curses attribute for prompt text (default: A_REVERSE)
        """
        height, width = stdscr.getmaxyx()

        # Dialog dimensions
        dialog_height = 9
        dialog_width = min(70, width - 4)
        dialog_y = (height - dialog_height) // 2
        dialog_x = (width - dialog_width) // 2

        # Create dialog window
        dialog = curses.newwin(dialog_height, dialog_width, dialog_y, dialog_x)
        dialog.clear()
        dialog.box()

        # Title (if provided)
        content_start_y = 1
        if title:
            dialog.addstr(0, (dialog_width - len(title)) // 2, title, curses.A_BOLD | curses.A_REVERSE)
            content_start_y = 2

        # Split message by newlines first, then word wrap each line
        lines = []
        for msg_line in message.split('\n'):
            if not msg_line:
                lines.append("")
            else:
                words = msg_line.split()
                current_line = ""
                for word in words:
                    if len(current_line) + len(word) + 1 <= dialog_width - 4:
                        current_line += (" " if current_line else "") + word
                    else:
                        lines.append(current_line)
                        current_line = word
                if current_line:
                    lines.append(current_line)

        # Draw message lines
        for i, line in enumerate(lines[:5]):  # Max 5 lines
            dialog.addstr(content_start_y + i, 2, line, message_style)

        # Draw prompt
        dialog.addstr(dialog_height - 2, (dialog_width - len(prompt)) // 2, prompt, prompt_style)

        dialog.noutrefresh()
        return dialog

    def draw_alert_dialog(self, stdscr, message):
        """Draw a dismissable alert dialog in the center of the screen."""
        return self.draw_dialog(
            stdscr, message,
            prompt="Press any key to continue",
            title=" Alert ",
            message_style=0,
            prompt_style=curses.A_DIM
        )

    def draw_confirmation_dialog(self, stdscr, message, prompt="Confirm? (y/n)"):
        """Draw a confirmation dialog in the center of the screen."""
        return self.draw_dialog(
            stdscr, message,
            prompt=prompt,
            title=None,
            message_style=curses.A_BOLD,
            prompt_style=curses.A_REVERSE
        )

    def handle_enter_key(self, view):
        """Handle Enter key - drill down into directories or files."""
        if view['type'] == 'main':
            # Get the display list to find what's selected
            display_list = self.build_display_list()
            if self.selected_idx < len(display_list):
                item = display_list[self.selected_idx]

                if item[0] == 'dir':
                    # Drilling into a directory
                    _, dir_path, _, _ = item
                    self.push_view({'type': 'dir_detail', 'data': {'dir_path': dir_path}})

                elif item[0] == 'collapse':
                    # Toggle collapse/expand
                    _, parent_path, _, _, _, _ = item
                    if parent_path in self.expanded_groups:
                        self.expanded_groups.discard(parent_path)
                    else:
                        self.expanded_groups.add(parent_path)
                    self.invalidate_display_cache()

        elif view['type'] == 'dir_detail':
            # Drilling into a file or subdirectory from directory view
            dir_path = view['data']['dir_path']
            items = self.get_all_files_with_counts(dir_path)

            if self.selected_idx < len(items):
                name, count_or_stats, path, item_type = items[self.selected_idx]
                if item_type == 'divider':
                    pass  # Can't drill into divider
                elif item_type == 'dir':
                    # Drill into subdirectory
                    self.push_view({'type': 'dir_detail', 'data': {'dir_path': path}})
                elif item_type == 'file':
                    # Drill into file
                    self.push_view({'type': 'file_detail', 'data': {'file_path': path}})

        elif view['type'] == 'file_detail':
            # Drilling into a directory from file detail view
            file_path = view['data']['file_path']
            dirs_with_file = self.get_dirs_containing_file(file_path)
            if self.selected_idx < len(dirs_with_file):
                dir_path = dirs_with_file[self.selected_idx]
                self.push_view({'type': 'dir_detail', 'data': {'dir_path': dir_path}})

    def clamp_selection_after_trash(self):
        """Ensure selected_idx is still valid after an item was trashed.

        The selection should stay at the same index (so the next item becomes selected),
        unless we deleted the last item, in which case we need to move up.
        """
        list_size = self.get_current_list_size()
        if list_size == 0:
            self.selected_idx = 0
        elif self.selected_idx >= list_size:
            self.selected_idx = list_size - 1

    def skip_divider(self, direction):
        """Skip over divider lines when navigating in dir_detail view.

        Args:
            direction: 1 for moving down, -1 for moving up
        """
        view = self.get_current_view()
        if view['type'] != 'dir_detail':
            return

        dir_path = view['data']['dir_path']
        items = self.get_all_files_with_counts(dir_path)

        # If we landed on a divider, skip it
        if self.selected_idx < len(items):
            _, _, _, item_type = items[self.selected_idx]
            if item_type == 'divider':
                self.selected_idx += direction
                # Clamp to valid range
                if self.selected_idx < 0:
                    self.selected_idx = 0
                elif self.selected_idx >= len(items):
                    self.selected_idx = len(items) - 1

    def handle_trash_key(self, view):
        """Handle 't' key - trash selected item."""
        item_to_trash = None
        trash_type = None

        if view['type'] == 'main':
            # Get the display list to find what's selected
            display_list = self.build_display_list()
            if self.selected_idx < len(display_list):
                item = display_list[self.selected_idx]
                if item[0] == 'dir':
                    _, dir_path, _, _ = item
                    item_to_trash = dir_path
                    trash_type = 'directory'
                # Can't trash a collapse line

        elif view['type'] == 'dir_detail':
            # Trashing a file or subdirectory from directory view
            dir_path = view['data']['dir_path']
            items = self.get_all_files_with_counts(dir_path)

            if self.selected_idx < len(items):
                _, _, path, item_type = items[self.selected_idx]
                if item_type != 'divider':
                    item_to_trash = path
                    trash_type = 'directory' if item_type == 'dir' else 'file'

        elif view['type'] == 'file_detail':
            # Trashing a directory from file detail view
            file_path = view['data']['file_path']
            dirs_with_file = self.get_dirs_containing_file(file_path)
            if self.selected_idx < len(dirs_with_file):
                dir_path = dirs_with_file[self.selected_idx]
                item_to_trash = dir_path
                trash_type = 'directory'

        if item_to_trash:
            # Check if confirmation needed
            needs_confirmation = False
            num_roots = len(self.root_paths)

            if trash_type == 'file':
                count = self.get_file_redundancy_count(item_to_trash)
                # Confirm if this is the only copy (count <= 1)
                if count <= 1:
                    needs_confirmation = True
            else:  # directory
                if not self.is_dir_fully_redundant(item_to_trash):
                    needs_confirmation = True

            if needs_confirmation:
                self.confirm_trash_item = item_to_trash
                self.confirm_trash_type = trash_type
            else:
                # Trash immediately
                self.trash_item(item_to_trash, trash_type)
                self.clamp_selection_after_trash()

    def handle_promote_key(self, view):
        """Handle 'P' key - move selected item to parent directory."""
        if view['type'] != 'dir_detail':
            return  # Only works in directory detail view

        dir_path = view['data']['dir_path']
        items = self.get_all_files_with_counts(dir_path)

        if self.selected_idx >= len(items):
            return

        _, _, item_path, item_type = items[self.selected_idx]
        if item_type == 'divider' or item_path is None:
            return  # Can't promote a divider

        # Calculate destination in parent directory
        parent_dir = dir_path.parent
        dest_path = parent_dir / item_path.name

        # Check if destination already exists
        if dest_path.exists():
            parent_path_display = self.get_path_with_root(parent_dir)
            self.alert_message = f"Cannot promote '{item_path.name}':\n\nAn item with that name already exists in:\n\n{parent_path_display}"
            return

        # Check if parent is within one of our root paths
        is_within_roots = any(
            parent_dir == root or self.is_subdir(parent_dir, root)
            for root in self.root_paths
        )
        if not is_within_roots:
            self.alert_message = "Cannot promote:\n\nThe parent directory is outside the scanned directories."
            return

        # Move the item
        try:
            shutil.move(str(item_path), str(dest_path))
        except Exception as e:
            self.alert_message = f"Cannot promote:\n\n{e}"
            return

        # Check if the previous view is the parent directory
        prev_view_is_parent = False
        if len(self.view_stack) > 1:
            prev_view = self.view_stack[-2]
            if prev_view['type'] == 'dir_detail':
                prev_dir = prev_view['data']['dir_path']
                if prev_dir == parent_dir:
                    prev_view_is_parent = True

        # Rescan to update data structures
        self.rescan()

        if prev_view_is_parent:
            # Pop current view and highlight the moved item in parent
            self.pop_view()
            # Find the moved item in the parent's item list
            parent_items = self.get_all_files_with_counts(parent_dir)
            for i, (_, _, path, _) in enumerate(parent_items):
                if path == dest_path:
                    self.selected_idx = i
                    break
        else:
            # Stay in current view, adjust selection if needed
            self.clamp_selection_after_trash()

    def handle_view_key(self, view, stdscr, height, width):
        """Handle 'v' key - view file content."""
        file_path = None

        if view['type'] == 'dir_detail':
            # View file from directory view
            dir_path = view['data']['dir_path']
            items = self.get_all_files_with_counts(dir_path)

            if self.selected_idx < len(items):
                _, _, path, item_type = items[self.selected_idx]
                if item_type == 'file':
                    file_path = path

        elif view['type'] == 'file_detail':
            # View the file itself
            file_path = view['data']['file_path']

        if file_path and file_path.is_file():
            # Get file content once before entering viewer loop
            metadata_lines, content_lines, file_type = self.get_file_content_for_viewing(file_path)

            # Enter file viewing mode
            scroll_offset = 0
            while True:
                # Get current terminal dimensions
                height, width = stdscr.getmaxyx()

                # Redraw current view as background
                usable_height = height - 1
                main_win = curses.newwin(usable_height, width, 0, 0)
                if view['type'] == 'main':
                    self.draw_main_view(main_win, usable_height, width)
                elif view['type'] == 'dir_detail':
                    self.draw_dir_detail_view(main_win, usable_height, width)
                elif view['type'] == 'file_detail':
                    self.draw_file_detail_view(main_win, usable_height, width)

                # Draw file viewer overlay on top
                scroll_offset, total_lines, max_offset = self.draw_file_viewer(stdscr, file_path, metadata_lines, content_lines, scroll_offset)

                # Draw hint bar
                self.draw_hint_bar(stdscr, 'viewer')

                # Handle viewer input
                view_key = stdscr.getch()

                if view_key in (ord('q'), ord('Q'), 27):  # q, Q, or ESC
                    break
                elif view_key == curses.KEY_RESIZE:
                    stdscr.clear()
                    stdscr.refresh()
                    continue
                elif view_key == ord('?'):
                    self.show_help_viewer(stdscr, 'viewer')
                    continue
                elif view_key in (curses.KEY_UP, ord('k')):
                    scroll_offset = max(0, scroll_offset - 1)
                elif view_key in (curses.KEY_DOWN, ord('j')):
                    scroll_offset = min(max_offset, scroll_offset + 1)
                elif view_key in (curses.KEY_PPAGE, curses.KEY_NPAGE, 2, 6):  # PgUp/PgDn or Ctrl-B/Ctrl-F
                    # Use a page size that accounts for metadata area
                    viewer_height = int(height * 0.85)
                    page_size = max(1, viewer_height - 8)  # Approximate content area
                    if view_key in (curses.KEY_PPAGE, 2):  # Page Up or Ctrl-B
                        scroll_offset = max(0, scroll_offset - page_size)
                    else:  # Page Down or Ctrl-F
                        scroll_offset = min(max_offset, scroll_offset + page_size)
                elif view_key in (curses.KEY_HOME, ord('<')):
                    scroll_offset = 0
                elif view_key in (curses.KEY_END, ord('>')):
                    scroll_offset = max_offset

    def handle_open_key(self, view):
        """Handle 'o' key - open file or directory with system default application."""
        path_to_open = None

        if view['type'] == 'main':
            # Open directory from main view
            display_list = self.build_display_list()
            if self.selected_idx < len(display_list):
                item = display_list[self.selected_idx]
                if item[0] == 'dir':
                    _, dir_path, _, _ = item
                    path_to_open = dir_path

        elif view['type'] == 'dir_detail':
            # Open file or directory from directory view
            dir_path = view['data']['dir_path']
            items = self.get_all_files_with_counts(dir_path)

            if self.selected_idx < len(items):
                _, _, path, item_type = items[self.selected_idx]
                path_to_open = path

        elif view['type'] == 'file_detail':
            # Open directory from file detail view
            file_path = view['data']['file_path']
            dirs_with_file = self.get_dirs_containing_file(file_path)
            if self.selected_idx < len(dirs_with_file):
                path_to_open = dirs_with_file[self.selected_idx]

        if path_to_open and path_to_open.exists():
            self.open_file_with_system_app(path_to_open)

    def draw_all_panes(self, usable_height, width, do_update=True):
        """Draw all panes in the view stack with proper indentation and frozen selections.

        Args:
            usable_height: Available height for drawing
            width: Available width for drawing
            do_update: If True, call curses.doupdate() after drawing (default True)
        """
        # First, draw the main view (always at bottom) with its saved selection
        main_win = curses.newwin(usable_height, width, 0, 0)
        main_view = self.view_stack[0]
        if len(self.view_stack) == 1:
            # Main view is current - use live selection
            main_selected = self.selected_idx
            main_scroll = self.scroll_offset
        else:
            # Main view is background - use frozen selection
            main_selected = main_view.get('selected_idx', 0)
            main_scroll = main_view.get('scroll_offset', 0)
        self.draw_main_view(main_win, usable_height, width, main_selected, main_scroll)

        # Then draw each overlay in the stack (skip index 0 which is always 'main')
        for level_idx in range(1, len(self.view_stack)):
            level_view = self.view_stack[level_idx]

            # Each level is indented 4 columns and 1 row from the previous
            indent_x = level_idx * 4
            indent_y = level_idx * 1

            # Calculate overlay size (descend 1 row but extend to bottom)
            overlay_height = usable_height - indent_y
            overlay_width = width - indent_x

            # Make sure we have room
            if overlay_height < 10 or overlay_width < 40:
                break

            # Determine if this is the current view or a background view
            is_current_view = (level_idx == len(self.view_stack) - 1)

            # For background views, use their saved selection; for current view, use live selection
            if is_current_view:
                # Current view - use live selection (responds to arrow keys)
                draw_selected_idx = self.selected_idx
                draw_scroll_offset = self.scroll_offset
            else:
                # Background view - use frozen saved selection
                draw_selected_idx = level_view.get('selected_idx', 0)
                draw_scroll_offset = level_view.get('scroll_offset', 0)

            # Draw the overlay with the appropriate selection
            overlay_win = curses.newwin(overlay_height, overlay_width, indent_y, indent_x)
            if level_view['type'] == 'dir_detail':
                self.draw_dir_detail_view(overlay_win, overlay_height, overlay_width, level_view, draw_selected_idx, draw_scroll_offset)
            elif level_view['type'] == 'file_detail':
                self.draw_file_detail_view(overlay_win, overlay_height, overlay_width, level_view, draw_selected_idx, draw_scroll_offset)

        if do_update:
            curses.doupdate()

    def run(self, stdscr):
        """Main TUI loop."""
        curses.curs_set(0)  # Hide cursor
        stdscr.clear()

        # Set escape delay to 25ms to make ESC key responsive
        if hasattr(curses, 'set_escdelay'):
            curses.set_escdelay(25)

        # Initialize colors if available
        if curses.has_colors():
            curses.init_pair(1, curses.COLOR_WHITE, curses.COLOR_BLUE)

        # Show loading message
        height, width = stdscr.getmaxyx()
        stdscr.addstr(height // 2, width // 2 - 10, "Starting TUI...", curses.A_BOLD)
        stdscr.refresh()

        if not self.sorted_dirs:
            # No duplicates found - show trash viewer
            self.viewing_trash = True
            self.trash_selected_idx = 0
            self.trash_offset = 0
            self.show_no_duplicates_message = True
        else:
            self.show_no_duplicates_message = False

        # Main loop
        while True:
            # Set timeout for getch() - use 500ms during verification for progress updates
            if self.cached_hashes and not self.verification_complete and not self.verification_error:
                stdscr.timeout(500)  # 500ms timeout during verification
            else:
                stdscr.timeout(-1)  # Blocking mode when verification complete

            # Check for background verification errors
            verification_error = self.check_verification_status()
            if verification_error:
                # Show fatal error and exit
                self.show_verification_error(stdscr, verification_error)
                return  # Exit the TUI

            height, width = stdscr.getmaxyx()
            usable_height = height - 1  # Reserve last line for hint bar

            # Handle different display modes
            if self.viewing_trash:
                # Draw trash viewer overlay
                view = self.get_current_view()
                if view['type'] == 'main':
                    main_win = curses.newwin(usable_height, width, 0, 0)
                    self.draw_main_view(main_win, usable_height, width, self.selected_idx, self.scroll_offset)

                # Draw trash viewer as centered overlay (85% width, 92% height)
                trash_height = int(usable_height * 0.92)
                trash_width = int(width * 0.85)
                trash_y = (usable_height - trash_height) // 2
                trash_x = (width - trash_width) // 2
                trash_win = curses.newwin(trash_height, trash_width, trash_y, trash_x)
                self.draw_trash_pane(trash_win, trash_height, trash_width)
                self.draw_hint_bar(stdscr, 'trash')
                curses.doupdate()

            elif self.confirm_quit:
                # Draw quit confirmation dialog
                self.draw_all_panes(usable_height, width, do_update=False)
                message = "You have drilled down into the directory tree.\n\nAre you sure you want to quit?"
                self.draw_confirmation_dialog(stdscr, message, "Quit? (y/n)")
                self.draw_hint_bar(stdscr, 'confirm')
                curses.doupdate()

            elif self.alert_message is not None:
                # Draw alert dialog - draw all panes then overlay the dialog
                self.draw_all_panes(usable_height, width, do_update=False)
                self.draw_alert_dialog(stdscr, self.alert_message)
                curses.doupdate()

            elif self.confirm_trash_item is not None:
                # Draw confirmation dialog - draw all panes then overlay the dialog
                self.draw_all_panes(usable_height, width, do_update=False)

                # Draw confirmation dialog on top of all panes
                rel_path = self.get_path_with_root(self.confirm_trash_item)
                message = f"There is only one copy of\n\n{rel_path}\n\nIf you trash it, you will lose data."
                self.draw_confirmation_dialog(stdscr, message, "Trash anyway? (y/n)")
                self.draw_hint_bar(stdscr, 'confirm')
                curses.doupdate()

            else:
                # Normal view - draw all panes in the stack
                self.draw_all_panes(usable_height, width, do_update=False)

                view = self.get_current_view()
                self.draw_hint_bar(stdscr, view['type'])
                curses.doupdate()

            # Handle input
            key = stdscr.getch()

            # Handle timeout (no key pressed) - just redraw to update verification progress
            if key == -1:
                continue

            # Handle terminal resize
            if key == curses.KEY_RESIZE:
                stdscr.clear()
                stdscr.refresh()
                continue

            # Handle quit confirmation first (takes priority)
            if self.confirm_quit:
                if key in (ord('y'), ord('Y')):
                    break
                elif key in (ord('n'), ord('N'), 27):  # n, N, or ESC
                    self.confirm_quit = False
                    continue
                elif key == ord('?'):
                    self.show_help_viewer(stdscr, 'confirm')
                    continue
                else:
                    continue

            # Handle alert dialog (dismiss with any key)
            if self.alert_message is not None:
                self.alert_message = None
                continue

            # Handle trash confirmation dialog
            if self.confirm_trash_item is not None:
                if key in (ord('q'), ord('Q')):
                    break
                if key in (ord('y'), ord('Y')):
                    item_path, item_type = self.confirm_trash_item, self.confirm_trash_type
                    self.trash_item(item_path, item_type)
                    self.clamp_selection_after_trash()
                    self.confirm_trash_item = None
                    self.confirm_trash_type = None
                    continue
                elif key in (ord('n'), ord('N'), 27):  # n, N, or ESC
                    self.confirm_trash_item = None
                    self.confirm_trash_type = None
                    continue
                elif key == ord('?'):
                    self.show_help_viewer(stdscr, 'confirm')
                    continue
                else:
                    continue

            # Handle trash viewing mode
            if self.viewing_trash:
                if key in (ord('q'), ord('Q')):
                    break
                elif key in (ord('T'),):
                    if not self.show_no_duplicates_message:
                        self.viewing_trash = False
                        self.trash_path_stack = []  # Reset navigation
                    continue
                elif key == 27:  # ESC
                    if self.trash_path_stack:
                        # Go back up one level, restore previous selection
                        _, _, saved_idx, saved_offset = self.trash_path_stack.pop()
                        self.trash_selected_idx = saved_idx
                        self.trash_offset = saved_offset
                    elif not self.show_no_duplicates_message:
                        self.viewing_trash = False
                    continue
                elif key in (curses.KEY_LEFT, ord('h')):
                    # Also allow h/left to go back
                    if self.trash_path_stack:
                        _, _, saved_idx, saved_offset = self.trash_path_stack.pop()
                        self.trash_selected_idx = saved_idx
                        self.trash_offset = saved_offset
                    continue
                elif key in (curses.KEY_ENTER, ord('\n'), ord('\r'), curses.KEY_RIGHT, ord('l')):
                    # Drill down into directory
                    current_trash_path = self.trash_path_stack[-1][0] if self.trash_path_stack else None
                    items = self.get_trash_items(current_trash_path)
                    if items and self.trash_selected_idx < len(items):
                        item = items[self.trash_selected_idx]
                        if item['type'] == 'directory':
                            # Save current selection before drilling down
                            self.trash_path_stack.append((item['trash_path'], item['original_path'], self.trash_selected_idx, self.trash_offset))
                            self.trash_selected_idx = 0
                            self.trash_offset = 0
                    continue
                elif key == ord('?'):
                    self.show_help_viewer(stdscr, 'trash')
                    continue
                elif key in (ord('o'), ord('O')):
                    items = self.get_trash_items()
                    if items and self.trash_selected_idx < len(items):
                        item_dict = items[self.trash_selected_idx]
                        trash_path = Path(item_dict['trash_path'])
                        if trash_path.is_file():
                            self.open_file_with_system_app(trash_path)
                    continue
                elif key in (curses.KEY_UP, ord('k')):
                    items = self.get_trash_items()
                    if self.trash_selected_idx > 0:
                        self.trash_selected_idx -= 1
                        if self.trash_selected_idx < self.trash_offset:
                            self.trash_offset = self.trash_selected_idx
                elif key in (curses.KEY_DOWN, ord('j')):
                    current_trash_path = self.trash_path_stack[-1][0] if self.trash_path_stack else None
                    items = self.get_trash_items(current_trash_path)
                    if self.trash_selected_idx < len(items) - 1:
                        self.trash_selected_idx += 1
                        if self.trash_selected_idx >= self.trash_offset + (height - 2):
                            self.trash_offset = self.trash_selected_idx - (height - 2) + 1
                elif key in (ord('r'), ord('R')):
                    current_trash_path = self.trash_path_stack[-1][0] if self.trash_path_stack else None
                    items = self.get_trash_items(current_trash_path)
                    if items and self.trash_selected_idx < len(items):
                        if self.restore_from_trash(items[self.trash_selected_idx]):
                            items = self.get_trash_items(current_trash_path)
                            if self.trash_selected_idx >= len(items) and len(items) > 0:
                                self.trash_selected_idx = len(items) - 1
                            # If current directory is now empty and we're drilled down, go back up
                            if not items and self.trash_path_stack:
                                _, _, saved_idx, saved_offset = self.trash_path_stack.pop()
                                self.trash_selected_idx = saved_idx
                                self.trash_offset = saved_offset
                            if self.show_no_duplicates_message and self.sorted_dirs:
                                self.show_no_duplicates_message = False
                                self.viewing_trash = False
                continue

            # Normal navigation and actions
            view = self.get_current_view()
            list_size = self.get_current_list_size()

            # Q key - quit (with confirmation if not at top level)
            if key in (ord('q'), ord('Q')):
                if len(self.view_stack) > 1:
                    self.confirm_quit = True
                else:
                    break

            # ESC / Left arrow / h - go back (or collapse if on expanded collapse line)
            elif key in (27, curses.KEY_LEFT, ord('h')):
                # Check if we're on an expanded collapse line in main view
                if view['type'] == 'main':
                    display_list = self.build_display_list()
                    if self.selected_idx < len(display_list):
                        item = display_list[self.selected_idx]
                        if item[0] == 'collapse':
                            _, parent_path, _, _, _, _ = item
                            if parent_path in self.expanded_groups:
                                # Collapse the group instead of going back
                                self.expanded_groups.discard(parent_path)
                                self.invalidate_display_cache()
                                continue

                if not self.pop_view():
                    self.show_quit_message = True
                continue

            # ? key - help
            elif key == ord('?'):
                self.show_help_viewer(stdscr, view['type'])
                continue

            # T key - view trash
            elif key in (ord('T'),):
                if not self.viewing_trash:
                    self.viewing_trash = True
                    self.trash_selected_idx = 0
                    self.trash_offset = 0
                    self.trash_path_stack = []  # Start at top level
                continue

            # U key - undo last trash
            elif key in (ord('u'), ord('U')):
                self.undo_last_trash()
                continue

            # Navigation keys
            elif key in (curses.KEY_UP, ord('k')):
                if self.selected_idx > 0:
                    self.selected_idx -= 1
                    self.skip_divider(-1)  # Skip divider if we landed on one
                    # If selection went off screen (above), scroll to show it
                    if self.selected_idx < self.scroll_offset:
                        self.scroll_offset = self.selected_idx
                    # If selection is on first line and there's a top indicator, scroll early
                    elif self.selected_idx == self.scroll_offset and self.scroll_offset > 0:
                        self.scroll_offset -= 1
            elif key in (curses.KEY_DOWN, ord('j')):
                if self.selected_idx < list_size - 1:
                    self.selected_idx += 1
                    self.skip_divider(1)  # Skip divider if we landed on one
                    visible_lines = self.get_current_visible_lines(usable_height)
                    last_visible_idx = self.scroll_offset + visible_lines - 1
                    more_below = self.scroll_offset + visible_lines < list_size
                    # If selection went off screen, scroll to show it
                    if self.selected_idx > last_visible_idx:
                        self.scroll_offset = self.selected_idx - visible_lines + 1
                    # If selection is on last line and there's a bottom indicator, scroll early
                    elif self.selected_idx == last_visible_idx and more_below:
                        self.scroll_offset += 1
            elif key in (curses.KEY_PPAGE, 2):  # Page Up / Ctrl-B
                visible_lines = self.get_current_visible_lines(usable_height)
                self.selected_idx = max(0, self.selected_idx - visible_lines)
                self.scroll_offset = max(0, self.scroll_offset - visible_lines)
            elif key in (curses.KEY_NPAGE, 6):  # Page Down / Ctrl-F
                visible_lines = self.get_current_visible_lines(usable_height)
                self.selected_idx = min(list_size - 1, self.selected_idx + visible_lines)
                self.scroll_offset = min(self.scroll_offset + visible_lines, max(0, list_size - visible_lines))
            elif key in (curses.KEY_HOME, ord('g')):
                self.selected_idx = 0
                self.scroll_offset = 0
            elif key in (curses.KEY_END, ord('G')):
                self.selected_idx = list_size - 1
                visible_lines = self.get_current_visible_lines(usable_height)
                self.scroll_offset = max(0, list_size - visible_lines)

            # Enter / Right arrow / l key - drill down or expand collapse
            elif key in (curses.KEY_ENTER, ord('\n'), ord('\r'), curses.KEY_RIGHT, ord('l')):
                self.handle_enter_key(view)
                continue

            # 't' key - trash item
            elif key == ord('t'):
                self.handle_trash_key(view)
                continue

            # 'v' key - view file
            elif key in (ord('v'), ord('V')):
                self.handle_view_key(view, stdscr, height, width)
                continue

            # 'o' key - open file
            elif key in (ord('o'), ord('O')):
                self.handle_open_key(view)
                continue

            # 'P' key - promote item to parent directory
            elif key == ord('P'):
                self.handle_promote_key(view)
                continue

            # 's'/'S' key - cycle sort mode (main view only)
            elif key in (ord('s'), ord('S')):
                if view['type'] == 'main':
                    # Remember currently selected directory
                    selected_path = None
                    display_list = self.build_display_list()
                    if self.selected_idx < len(display_list):
                        item = display_list[self.selected_idx]
                        if item[0] == 'dir':
                            selected_path = item[1]
                        elif item[0] == 'collapse':
                            selected_path = item[1]  # parent path

                    self.cycle_sort_mode(reverse=(key == ord('S')))

                    # Find the same directory in the new sorted list
                    if selected_path:
                        new_display_list = self.build_display_list()
                        for i, item in enumerate(new_display_list):
                            if item[0] == 'dir' and item[1] == selected_path:
                                self.selected_idx = i
                                break
                            elif item[0] == 'collapse' and item[1] == selected_path:
                                self.selected_idx = i
                                break
                        else:
                            self.selected_idx = 0
                    else:
                        self.selected_idx = 0

                    # Adjust scroll to keep selection visible
                    visible_lines = self.get_current_visible_lines(usable_height)
                    if self.selected_idx < self.scroll_offset:
                        self.scroll_offset = self.selected_idx
                    elif self.selected_idx >= self.scroll_offset + visible_lines:
                        self.scroll_offset = self.selected_idx - visible_lines + 1
                continue

def main():
    import argparse

    parser = argparse.ArgumentParser(
        prog='dedupdir-tui',
        description='Interactive TUI for exploring redundant directories.'
    )
    parser.add_argument(
        'directories',
        nargs='*',
        default=['.'],
        metavar='directory',
        help='Directories to scan (default: current directory)'
    )
    parser.add_argument(
        '-a', '--algorithm',
        default='blake2b',
        choices=['md5', 'sha1', 'sha256', 'blake2b', 'blake2s'],
        help='Hash algorithm to use (default: blake2b)'
    )
    parser.add_argument(
        '-j', '--jobs',
        type=int,
        default=4,
        metavar='N',
        help='Number of parallel hashing jobs (default: 4, use 1 to disable)'
    )

    args = parser.parse_args()

    # Handle both single directory and multiple directories
    roots = []
    for directory in args.directories:
        root = Path(directory).resolve()
        if not root.exists():
            print(f"Error: '{directory}' does not exist", file=sys.stderr)
            sys.exit(1)
        if not root.is_dir():
            print(f"Error: '{directory}' is not a directory", file=sys.stderr)
            sys.exit(1)
        roots.append(root)

    tui = DedupdirTUI(roots, algorithm=args.algorithm, jobs=args.jobs)

    # Scan with progress output before starting TUI
    if len(roots) == 1:
        print(f"Scanning {roots[0]}...")
    else:
        print(f"Scanning {len(roots)} directories...")
        for root in roots:
            print(f"  {root}")
    tui.scan(quiet=False)

    if not tui.sorted_dirs:
        print("No duplicate files found.")
        sys.exit(0)

    try:
        curses.wrapper(tui.run)
    except KeyboardInterrupt:
        pass


if __name__ == '__main__':
    main()
