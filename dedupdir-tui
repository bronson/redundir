#!/usr/bin/env python3
"""
dedupdir-tui - Interactive TUI for exploring redundant directories
version 0.2.XX

This script provides a TUI to help quickly deduplicate files. It shows the
redundancies scores for all directories in a tree and lets you temporarily
remove files and immediately see the effect on the scores.
"""

import curses
import sys
import os
import shutil
from pathlib import Path
from datetime import datetime

# Import core functions from dedupdir by loading it directly
def load_dedupdir():
    """Load dedupdir module from same directory or PATH."""
    import types

    # Try to find dedupdir in same directory as this script
    # Check multiple possible locations
    possible_paths = [
        Path(__file__).parent / "dedupdir",  # Same directory
        Path.cwd() / "dedupdir",  # Current working directory
        Path(sys.argv[0]).parent / "dedupdir",  # Script directory from argv
    ]

    for dedupdir_path in possible_paths:
        if dedupdir_path.exists() and dedupdir_path.is_file():
            try:
                # Read and execute the file directly since it has no .py extension
                with open(dedupdir_path, 'r') as f:
                    code = f.read()

                # Create a module to hold the executed code
                dedupdir = types.ModuleType('dedupdir')
                dedupdir.__file__ = str(dedupdir_path)
                sys.modules['dedupdir'] = dedupdir

                # Execute the code in the module's namespace
                exec(code, dedupdir.__dict__)

                # Verify required functions exist
                if hasattr(dedupdir, 'find_duplicates') and hasattr(dedupdir, 'calculate_redundancy_score'):
                    return dedupdir
            except Exception as e:
                print(f"Error loading {dedupdir_path}: {e}", file=sys.stderr)
                continue

    # Try regular import as fallback
    try:
        import dedupdir
        return dedupdir
    except ImportError:
        pass

    print("Error: Could not find dedupdir script", file=sys.stderr)
    print("Tried locations:", file=sys.stderr)
    for p in possible_paths:
        print(f"  {p} (exists: {p.exists()})", file=sys.stderr)
    sys.exit(1)

dedupdir_module = load_dedupdir()
find_duplicates = dedupdir_module.find_duplicates
calculate_redundancy_score = dedupdir_module.calculate_redundancy_score


class DedupdirTUI:
    def __init__(self, root_paths, algorithm='blake2b', jobs=4):
        # Normalize to list
        if isinstance(root_paths, (str, Path)):
            root_paths = [root_paths]
        self.root_paths = [Path(p).resolve() for p in root_paths]
        self.algorithm = algorithm
        self.jobs = jobs

        # Navigation state
        self.selected_idx = 0
        self.scroll_offset = 0
        self.show_quit_message = False

        # View stack for drill-down navigation
        # Each entry is a dict: {'type': 'main'|'dir_detail'|'file_detail', 'data': {...}}
        self.view_stack = [{'type': 'main'}]

        # Trash system (trash dirs are per-root, not in cwd)
        self.trash_stack = []  # Stack for undo: [(original_path, trash_path, is_dir), ...]
        self.viewing_trash = False  # Whether we're in trash viewing mode
        self.trash_selected_idx = 0
        self.trash_offset = 0
        self.confirm_trash_item = None  # Item pending confirmation
        self.confirm_trash_type = None  # 'file' or 'directory'
        self.show_no_duplicates_message = False  # Show message when no duplicates found

        # Data will be populated by scan()
        self.sorted_dirs = []
        self.dir_stats = {}
        self.file_to_hash = {}
        self.hash_to_dirs = {}
        self.dir_all_files = {}
        self.total_duplicates = 0
        self.total_files = 0

    def scan(self, quiet=False):
        """Scan the directory tree for duplicates."""
        result = find_duplicates(
            self.root_paths,
            algorithm=self.algorithm,
            jobs=self.jobs,
            quiet=quiet
        )
        self.dir_stats, self.total_duplicates, self.total_files, \
            self.file_to_hash, self.hash_to_dirs, self.dir_all_files = result

        # Recalculate sorted_dirs with all directories
        self.recalculate_sorted_dirs()

    def recalculate_sorted_dirs(self):
        """Recalculate sorted_dirs including ALL directories, even those with 0% redundancy."""
        all_dirs_with_stats = []
        for dir_path, files in self.dir_all_files.items():
            if dir_path in self.dir_stats:
                # Directory has duplicates
                all_dirs_with_stats.append((dir_path, self.dir_stats[dir_path]))
            else:
                # Directory has no duplicates - add with 0/N stats
                total_files = len(files)
                all_dirs_with_stats.append((dir_path, (0, total_files)))

        # Sort directories by redundancy score
        self.sorted_dirs = sorted(
            all_dirs_with_stats,
            key=lambda x: (-calculate_redundancy_score(x[1][0], x[1][1]), str(x[0]))
        )

    def get_path_with_root(self, path):
        """Get path including root prefix (e.g., 'pix/subdir/file.jpg')."""
        path = Path(path)
        # Find which root this path belongs to
        for root in self.root_paths:
            try:
                rel = path.relative_to(root.parent)
                return str(rel)
            except ValueError:
                continue
        # Fallback to just the path
        return str(path)

    def get_relative_path(self, path):
        """Convert absolute path to relative display path."""
        # Try each root path
        for root_path in self.root_paths:
            try:
                rel = path.relative_to(root_path)
                display = str(root_path.name / rel) if str(rel) != '.' else str(root_path.name)
                return display
            except ValueError:
                continue
        # If not relative to any root, use absolute path
        return str(path)

    def get_related_dirs(self, dir_path):
        """Get related directories and their hypothetical redundancy scores.

        Returns list of (related_dir_path, shared_files, duplicates, total_files) tuples.
        """
        # Find all hashes in this directory
        dir_hashes = set()
        for fpath in self.dir_all_files.get(dir_path, []):
            if fpath in self.file_to_hash:
                dir_hashes.add(self.file_to_hash[fpath])

        # Find related directories and count shared files
        related_dirs_info = {}
        for h in dir_hashes:
            for d in self.hash_to_dirs[h]:
                if d != dir_path:
                    if d not in related_dirs_info:
                        related_dirs_info[d] = 0
                    related_dirs_info[d] += 1  # Count shared files

        # Calculate hypothetical redundancy for each related directory
        related_info = []
        for related_dir, shared_count in related_dirs_info.items():
            related_files = self.dir_all_files.get(related_dir, [])
            total_related = len(related_files)

            hypothetical_duplicates = 0
            for fpath in related_files:
                if fpath in self.file_to_hash:
                    h = self.file_to_hash[fpath]
                    other_dirs = self.hash_to_dirs[h] - {dir_path, related_dir}
                    if len(other_dirs) > 0:
                        hypothetical_duplicates += 1

            related_info.append((related_dir, shared_count, hypothetical_duplicates, total_related))

        # Sort by shared files descending, then by hypothetical duplicates descending
        related_info.sort(key=lambda x: (-x[1], -x[2]))
        return related_info

    def get_duplicate_files(self, dir_path):
        """Get list of duplicate files in the directory."""
        dup_files = []
        for fpath in self.dir_all_files.get(dir_path, []):
            if fpath in self.file_to_hash:
                dup_files.append(fpath.name)
        return sorted(dup_files)

    def get_all_files_with_counts(self, dir_path):
        """Get list of all files in directory with count of dirs containing each.

        Returns list of (filename, dir_count, file_path) tuples, sorted by
        dir_count descending (most duplicated first), then by filename.
        """
        file_info = []
        for fpath in self.dir_all_files.get(dir_path, []):
            fname = fpath.name
            # Count how many directories contain this file (by hash)
            if fpath in self.file_to_hash:
                fhash = self.file_to_hash[fpath]
                dir_count = len(self.hash_to_dirs.get(fhash, set()))
            else:
                # Unique file (not hashed, only in this directory)
                dir_count = 1
            file_info.append((fname, dir_count, fpath))

        # Sort by count descending, then by filename
        file_info.sort(key=lambda x: (-x[1], x[0]))
        return file_info

    def get_dirs_containing_file(self, file_path):
        """Get list of directories that contain the given file (by hash)."""
        if file_path not in self.file_to_hash:
            # Unique file, only in its own directory
            return [file_path.parent]

        fhash = self.file_to_hash[file_path]
        return list(self.hash_to_dirs.get(fhash, set()))

    def get_filename_in_dir(self, file_path, dir_path):
        """Get the actual filename for a file's hash in a specific directory.

        Since duplicate files can have different names in different directories,
        we need to look up the actual filename in each directory.
        """
        if file_path not in self.file_to_hash:
            # Unique file, just return its name
            return file_path.name

        fhash = self.file_to_hash[file_path]

        # Search through all files in the target directory for one with matching hash
        for fpath in self.dir_all_files.get(dir_path, []):
            if fpath in self.file_to_hash and self.file_to_hash[fpath] == fhash:
                return fpath.name

        # Fallback to original filename if not found
        return file_path.name

    def get_trash_dir_for_root(self, root_path):
        """Get the trash directory for a specific root."""
        return root_path / '~dedupdir-trash'

    def init_trash_dir_for_root(self, root_path):
        """Initialize trash directory for a specific root if it doesn't exist."""
        trash_dir = self.get_trash_dir_for_root(root_path)
        if not trash_dir.exists():
            trash_dir.mkdir(parents=True)
        return trash_dir

    def get_trash_items(self):
        """Scan trash directories in all roots and return list of items with metadata."""
        items = []

        for root_path in self.root_paths:
            trash_dir = self.get_trash_dir_for_root(root_path)
            if not trash_dir.exists():
                continue

            # Walk through all files/dirs in this trash dir
            for item in trash_dir.rglob('*'):
                if item.is_file() or (item.is_dir() and not any(item.iterdir())):
                    # It's a file or empty directory
                    rel_to_trash = item.relative_to(trash_dir)
                    original_path = root_path / rel_to_trash

                    items.append({
                        'original_path': str(original_path),
                        'trash_path': str(item),
                        'root_name': root_path.name,
                        'relative_path': str(rel_to_trash),
                        'type': 'file' if item.is_file() else 'directory',
                        'timestamp': datetime.fromtimestamp(item.stat().st_ctime).isoformat()
                    })

        # Sort by timestamp (newest first)
        items.sort(key=lambda x: x['timestamp'], reverse=True)
        return items

    def get_current_view(self):
        """Get the current view from the view stack."""
        return self.view_stack[-1] if self.view_stack else {'type': 'main'}

    def push_view(self, view):
        """Push a new view onto the stack."""
        # Save current selection state in the current view
        if self.view_stack:
            current = self.view_stack[-1]
            current['selected_idx'] = self.selected_idx
            current['scroll_offset'] = self.scroll_offset

        self.view_stack.append(view)
        self.selected_idx = 0
        self.scroll_offset = 0

    def pop_view(self):
        """Pop the current view and return to the previous one."""
        if len(self.view_stack) > 1:
            self.view_stack.pop()
            # Restore selection state from the previous view
            prev_view = self.view_stack[-1]
            self.selected_idx = prev_view.get('selected_idx', 0)
            self.scroll_offset = prev_view.get('scroll_offset', 0)
            return True
        return False

    def get_current_list_size(self):
        """Get the size of the current list being displayed."""
        view = self.get_current_view()
        if view['type'] == 'main':
            return len(self.sorted_dirs)
        elif view['type'] == 'dir_detail':
            dir_path = view['data']['dir_path']
            files = self.get_all_files_with_counts(dir_path)
            return len(files)
        elif view['type'] == 'file_detail':
            file_path = view['data']['file_path']
            return len(self.get_dirs_containing_file(file_path))
        return 0

    def get_current_stats(self):
        """Calculate current statistics: total files, duplicate files, and duplication percentage.

        Returns a tuple: (total_files, duplicate_files, duplication_percent)
        """
        # Count all unique files across all directories
        all_files = set()
        for dir_path, files in self.dir_all_files.items():
            all_files.update(files)

        total_files = len(all_files)

        if total_files == 0:
            return 0, 0, 0.0

        # Count duplicate files (files that exist in more than one directory)
        duplicate_files = 0
        for file_path in all_files:
            if file_path in self.file_to_hash:
                file_hash = self.file_to_hash[file_path]
                num_dirs = len(self.hash_to_dirs.get(file_hash, set()))
                if num_dirs > 1:
                    duplicate_files += 1

        # Calculate percentage - ensure we don't show 0% if there are duplicates
        if duplicate_files > 0:
            duplication_percent = (duplicate_files / total_files) * 100
            # If percentage rounds to 0 but there are duplicates, show at least 0.01%
            if duplication_percent < 0.01:
                duplication_percent = 0.01
        else:
            duplication_percent = 0.0

        return total_files, duplicate_files, duplication_percent

    def get_file_redundancy_count(self, file_path):
        """Get how many directories contain this file (based on hash)."""
        if file_path not in self.file_to_hash:
            return 0
        file_hash = self.file_to_hash[file_path]
        return len(self.hash_to_dirs.get(file_hash, set()))

    def is_dir_fully_redundant(self, dir_path):
        """Check if all files in directory exist in other directories."""
        files = self.dir_all_files.get(dir_path, [])
        if not files:
            return True

        num_roots = len(self.root_paths)
        for fpath in files:
            count = self.get_file_redundancy_count(fpath)
            if count < num_roots:
                return False
        return True

    def trash_item(self, item_path, item_type):
        """Move item to trash and update data structures."""
        item_path = Path(item_path)

        # Find which root this item belongs to
        root_for_item = None
        for root in self.root_paths:
            try:
                item_path.relative_to(root)
                root_for_item = root
                break
            except ValueError:
                continue

        if not root_for_item:
            return False

        # Initialize trash dir for this root
        trash_dir = self.init_trash_dir_for_root(root_for_item)

        # Create relative path from root
        rel_path = item_path.relative_to(root_for_item)

        # Create trash path (directly under trash dir, preserving structure)
        trash_path = trash_dir / rel_path
        trash_path.parent.mkdir(parents=True, exist_ok=True)

        # Move to trash
        try:
            shutil.move(str(item_path), str(trash_path))
        except Exception as e:
            return False

        # Add to undo stack (store simple tuple)
        self.trash_stack.append((str(item_path), str(trash_path), item_type == 'directory'))

        # Update data structures
        if item_type == 'file':
            self.remove_file_from_data(item_path)
        else:  # directory
            self.remove_directory_from_data(item_path)

        # Recalculate sorted_dirs with all directories
        self.recalculate_sorted_dirs()

        return True

    def remove_file_from_data(self, file_path):
        """Remove a file from internal data structures."""
        if file_path not in self.file_to_hash:
            return

        file_hash = self.file_to_hash[file_path]
        parent_dir = file_path.parent

        # Get all directories that will be affected by this trashing
        # (all directories that have files with this hash)
        affected_dirs = set()
        if file_hash in self.hash_to_dirs:
            affected_dirs = self.hash_to_dirs[file_hash].copy()

        # Remove file from dir_all_files
        if parent_dir in self.dir_all_files:
            if file_path in self.dir_all_files[parent_dir]:
                self.dir_all_files[parent_dir].remove(file_path)

        # Remove the directory from hash_to_dirs
        if file_hash in self.hash_to_dirs:
            self.hash_to_dirs[file_hash].discard(parent_dir)

            # If no more directories have this hash, remove it
            if not self.hash_to_dirs[file_hash]:
                del self.hash_to_dirs[file_hash]

        # Remove from file_to_hash
        del self.file_to_hash[file_path]

        # Recalculate stats for ALL affected directories
        # (not just the one we trashed from, but all that had this hash)
        for dir_path in affected_dirs:
            if dir_path in self.dir_stats or dir_path in self.dir_all_files:
                # Recalculate duplicates for this directory
                new_dup = 0
                for f in self.dir_all_files.get(dir_path, []):
                    if f in self.file_to_hash:
                        fh = self.file_to_hash[f]
                        if len(self.hash_to_dirs.get(fh, set())) > 1:
                            new_dup += 1
                new_total = len(self.dir_all_files.get(dir_path, []))

                # Update or remove from dir_stats
                if new_total > 0 and new_dup > 0:
                    self.dir_stats[dir_path] = (new_dup, new_total)
                elif dir_path in self.dir_stats:
                    del self.dir_stats[dir_path]

    def remove_directory_from_data(self, dir_path):
        """Remove a directory and all its files from internal data structures."""
        # Get all files in this directory
        files_to_remove = self.dir_all_files.get(dir_path, [])[:]

        # Remove each file
        for file_path in files_to_remove:
            self.remove_file_from_data(file_path)

        # Remove directory from dir_all_files and dir_stats
        if dir_path in self.dir_all_files:
            del self.dir_all_files[dir_path]
        if dir_path in self.dir_stats:
            del self.dir_stats[dir_path]

    def undo_last_trash(self):
        """Undo the most recent trash operation."""
        if not self.trash_stack:
            return False

        original_path_str, trash_path_str, is_dir = self.trash_stack.pop()
        trash_path = Path(trash_path_str)
        original_path = Path(original_path_str)

        # Move back from trash
        try:
            original_path.parent.mkdir(parents=True, exist_ok=True)
            shutil.move(str(trash_path), str(original_path))
        except Exception as e:
            # Put it back on stack if restore failed
            self.trash_stack.append((original_path_str, trash_path_str, is_dir))
            return False

        # Clean up empty directories in trash
        self.cleanup_empty_trash_dirs(trash_path.parent)

        # Rescan to update data structures
        self.scan(quiet=True)

        return True

    def restore_from_trash(self, trash_record):
        """Restore an item from trash by its metadata record."""
        trash_path = Path(trash_record['trash_path'])
        original_path = Path(trash_record['original_path'])

        if not trash_path.exists():
            return False

        try:
            original_path.parent.mkdir(parents=True, exist_ok=True)
            shutil.move(str(trash_path), str(original_path))
        except Exception as e:
            return False

        # Clean up empty directories in trash
        self.cleanup_empty_trash_dirs(trash_path.parent)

        # Remove from trash stack if present
        self.trash_stack = [d for d in self.trash_stack if d[1] != trash_record['trash_path']]

        # Rescan to update data structures
        self.scan(quiet=True)

        return True

    def cleanup_empty_trash_dirs(self, start_dir):
        """Remove empty directories in trash, walking up from start_dir."""
        if not start_dir.exists():
            return

        # Walk up from start_dir, removing empty directories
        current = start_dir
        while current.exists() and current.is_dir():
            # Check if this is a trash directory
            is_trash_root = any(current == self.get_trash_dir_for_root(root) for root in self.root_paths)
            if is_trash_root:
                break

            # Check if directory is empty
            try:
                if not any(current.iterdir()):
                    # Directory is empty, remove it
                    current.rmdir()
                    # Move up to parent
                    current = current.parent
                else:
                    # Directory not empty, stop
                    break
            except (OSError, PermissionError):
                # Can't remove or access, stop
                break

    def format_mtime(self, path):
        """Format modification time compactly."""
        try:
            mtime = path.stat().st_mtime
            dt = datetime.fromtimestamp(mtime)
            now = datetime.now()

            # If today, show time
            if dt.date() == now.date():
                return dt.strftime("%H:%M")
            # If this year, show month-day
            elif dt.year == now.year:
                return dt.strftime("%m-%d")
            # Otherwise show year
            else:
                return dt.strftime("%Y")
        except:
            return "-----"

    def draw_main_view(self, win, height, width, selected_idx, scroll_offset):
        """Draw the main directory list view."""
        win.clear()
        win.border()

        # Show statistics in upper right corner
        total_files, duplicate_files, duplication_percent = self.get_current_stats()
        if duplication_percent == 0.0:
            percent_str = "0%"
        elif duplication_percent < 0.01:
            percent_str = "<0.01%"
        elif duplication_percent < 1.0:
            percent_str = f"{duplication_percent:.2f}%"
        elif duplication_percent < 10.0:
            percent_str = f"{duplication_percent:.1f}%"
        else:
            percent_str = f"{duplication_percent:.0f}%"

        stats_text = f" {total_files} files | {duplicate_files} dupes | {percent_str} "
        stats_x = width - len(stats_text) - 1
        if stats_x > 2:
            try:
                win.addstr(0, stats_x, stats_text, curses.A_DIM)
            except curses.error:
                pass

        title = f" All Directories ({len(self.sorted_dirs)}) "
        try:
            win.addstr(0, 2, title[:width-4], curses.A_BOLD)
        except curses.error:
            pass

        # Show quit message if needed
        if self.show_quit_message:
            msg = " Press 'q' to quit "
            try:
                win.addstr(height - 1, width - len(msg) - 1, msg, curses.A_REVERSE | curses.A_BOLD)
            except curses.error:
                pass

        if not self.sorted_dirs:
            win.addstr(2, 1, "No directories to display")
            win.refresh()
            return

        # Column headers
        header_line = 1
        try:
            win.addstr(header_line, 1, " %Dup", curses.A_BOLD | curses.A_UNDERLINE)
            win.addstr(header_line, 8, "Dup", curses.A_BOLD | curses.A_UNDERLINE)
            win.addstr(header_line, 13, "Total", curses.A_BOLD | curses.A_UNDERLINE)
            win.addstr(header_line, 20, "MTime", curses.A_BOLD | curses.A_UNDERLINE)
            win.addstr(header_line, 28, "Directory Path", curses.A_BOLD | curses.A_UNDERLINE)
        except curses.error:
            pass

        # Display directories
        display_height = height - 3  # Account for border, header, and bottom border
        for i in range(display_height):
            idx = scroll_offset + i
            if idx >= len(self.sorted_dirs):
                break

            dir_path, (duplicates, total) = self.sorted_dirs[idx]
            score = calculate_redundancy_score(duplicates, total)
            path_str = self.get_path_with_root(dir_path)
            mtime_str = self.format_mtime(dir_path)

            # Format columns
            percent_col = f"{score:6.1%}" if score > 0 else "   0% "
            dup_col = f"{duplicates:4d}"
            total_col = f"{total:5d}"

            line = f"{percent_col} {dup_col}  {total_col}  {mtime_str}  {path_str}"

            # Truncate if too long
            max_len = width - 3
            if len(line) > max_len:
                line = line[:max_len-3] + "..."

            y = i + 2  # Start after header
            attr = curses.A_REVERSE if idx == selected_idx else curses.A_NORMAL
            try:
                win.addstr(y, 1, line.ljust(width - 2), attr)
            except curses.error:
                pass

        win.refresh()

    def draw_dir_detail_view(self, win, height, width, view, selected_idx, scroll_offset):
        """Draw directory detail view showing only files in that directory."""
        dir_path = view['data']['dir_path']

        win.clear()
        win.border()

        title = f" {self.get_path_with_root(dir_path)}/ "
        try:
            win.addstr(0, 2, title[:width-4], curses.A_BOLD)
        except curses.error:
            pass

        # Get files in this directory
        files = self.get_all_files_with_counts(dir_path)

        # Headers
        try:
            win.addstr(2, 1, f"Files in Directory ({len(files)}):", curses.A_BOLD)
            win.addstr(3, 1, " Copies", curses.A_BOLD | curses.A_UNDERLINE)
            win.addstr(3, 10, "Filename", curses.A_BOLD | curses.A_UNDERLINE)
        except curses.error:
            pass

        if not files:
            try:
                win.addstr(4, 1, "  (No files)")
            except curses.error:
                pass
            win.refresh()
            return

        # Display files
        display_height = height - 5  # Account for border, title, section header, column header
        for i in range(display_height):
            idx = scroll_offset + i
            if idx >= len(files):
                break

            filename, count, file_path = files[idx]
            count_col = f"{count:5d}"
            line = f"{count_col}   {filename}"

            max_len = width - 3
            if len(line) > max_len:
                line = line[:max_len-3] + "..."

            y = i + 4  # Start after headers
            attr = curses.A_REVERSE if idx == selected_idx else curses.A_NORMAL
            try:
                win.addstr(y, 1, line.ljust(width - 2), attr)
            except curses.error:
                pass

        win.refresh()

    def draw_file_detail_view(self, win, height, width, view, selected_idx, scroll_offset):
        """Draw file detail view showing all directories containing this file."""
        file_path = view['data']['file_path']

        win.clear()
        win.border()

        title = f" {self.get_path_with_root(file_path)} "
        try:
            win.addstr(0, 2, title[:width-4], curses.A_BOLD)
        except curses.error:
            pass

        # Get all directories containing this file
        dirs_with_file = self.get_dirs_containing_file(file_path)

        # Headers
        try:
            win.addstr(2, 1, f"Directories Containing This File ({len(dirs_with_file)}):", curses.A_BOLD)
            win.addstr(3, 1, " %Dup", curses.A_BOLD | curses.A_UNDERLINE)
            win.addstr(3, 8, "Dup", curses.A_BOLD | curses.A_UNDERLINE)
            win.addstr(3, 13, "Total", curses.A_BOLD | curses.A_UNDERLINE)
            win.addstr(3, 20, "MTime", curses.A_BOLD | curses.A_UNDERLINE)
            win.addstr(3, 28, "Directory Path", curses.A_BOLD | curses.A_UNDERLINE)
        except curses.error:
            pass

        # Display directories
        display_height = height - 5
        for i in range(display_height):
            idx = scroll_offset + i
            if idx >= len(dirs_with_file):
                break

            dir_path = dirs_with_file[idx]
            if dir_path in self.dir_stats:
                duplicates, total = self.dir_stats[dir_path]
            else:
                duplicates, total = 0, len(self.dir_all_files.get(dir_path, []))

            score = calculate_redundancy_score(duplicates, total)
            path_str = self.get_path_with_root(dir_path)
            mtime_str = self.format_mtime(dir_path)

            percent_col = f"{score:6.1%}" if score > 0 else "   0% "
            dup_col = f"{duplicates:4d}"
            total_col = f"{total:5d}"

            line = f"{percent_col} {dup_col}  {total_col}  {mtime_str}  {path_str}"
            max_len = width - 3
            if len(line) > max_len:
                line = line[:max_len-3] + "..."

            y = i + 4
            attr = curses.A_REVERSE if idx == selected_idx else curses.A_NORMAL
            try:
                win.addstr(y, 1, line.ljust(width - 2), attr)
            except curses.error:
                pass

        win.refresh()
    def draw_trash_pane(self, win, height, width):
        """Draw the trash viewer in full screen."""
        win.clear()
        win.border()

        title = " Trash (~dedupdir-trash) - 'r' restore, 'v' view, 't' toggle back, Esc exit "
        win.addstr(0, 2, title[:width-4], curses.A_BOLD | curses.A_REVERSE)

        # Show "no duplicates" message if applicable
        if self.show_no_duplicates_message:
            msg = "No duplicate files found. You can restore files from trash below, or press 'q' to quit."
            try:
                win.addstr(2, 2, msg[:width-4], curses.A_BOLD)
            except curses.error:
                pass

        items = self.get_trash_items()

        if not items:
            msg_y = 4 if self.show_no_duplicates_message else 2
            win.addstr(msg_y, 2, "Trash is empty", curses.A_DIM)
            if self.show_no_duplicates_message:
                win.addstr(msg_y + 2, 2, "Press 'q' to quit.", curses.A_DIM)
            win.refresh()
            return

        # Display trash items
        start_y = 4 if self.show_no_duplicates_message else 1
        display_height = (height - start_y - 1) if self.show_no_duplicates_message else (height - 2)
        for i in range(display_height):
            idx = self.trash_offset + i
            if idx >= len(items):
                break

            item = items[idx]
            item_type = item.get('type', 'unknown')
            rel_path = item.get('relative_path', 'unknown')
            root_name = item.get('root_name', '')
            timestamp = item.get('timestamp', '')[:19]  # YYYY-MM-DDTHH:MM:SS

            # Format: [type] root/path with timestamp on right
            type_icon = "üìÑ" if item_type == "file" else "üìÅ"
            path_part = f"{type_icon} {root_name}/{rel_path}"

            # Format timestamp as "MMM DD HH:MM" (e.g., "Jan 20 14:23")
            # This is the ctime (inode change time), which approximates when the file was moved to trash
            if len(timestamp) >= 16:
                try:
                    dt = datetime.fromisoformat(timestamp)
                    time_part = dt.strftime("%b %d %H:%M")  # "Jan 20 14:23"
                except:
                    time_part = timestamp[5:16]  # Fallback: "MM-DD HH:MM"
            else:
                time_part = timestamp

            y = i + start_y
            attr = curses.A_REVERSE if idx == self.trash_selected_idx else curses.A_NORMAL

            try:
                # Calculate available space for path
                timestamp_width = len(time_part) + 2  # Add padding
                path_max_width = width - timestamp_width - 3

                # Truncate path if needed
                if len(path_part) > path_max_width:
                    path_part = path_part[:path_max_width-3] + "..."

                # Draw path on left
                win.addstr(y, 1, path_part, attr)

                # Draw timestamp on right
                time_x = width - timestamp_width - 1
                win.addstr(y, time_x, time_part, attr | curses.A_DIM)
            except curses.error:
                pass

        # Scrollbar indicator
        if len(items) > display_height:
            indicator = f" [{self.trash_offset + 1}-{min(self.trash_offset + display_height, len(items))}/{len(items)}] "
            try:
                win.addstr(height - 1, width - len(indicator) - 1, indicator, curses.A_DIM)
            except curses.error:
                pass

        win.refresh()

    def get_file_type(self, file_path):
        """Detect file type: 'text', 'image', 'binary'."""
        try:
            # Check by extension first
            suffix = file_path.suffix.lower()

            # Image extensions
            image_exts = {'.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.tif', '.webp', '.ico', '.svg'}
            if suffix in image_exts:
                return 'image'

            # Read first chunk to detect text vs binary
            with open(file_path, 'rb') as f:
                chunk = f.read(8192)
                if not chunk:
                    return 'text'  # Empty file

                # Check for null bytes (strong indicator of binary)
                if b'\x00' in chunk:
                    return 'binary'

                # Try to decode as UTF-8
                try:
                    chunk.decode('utf-8')
                    return 'text'
                except UnicodeDecodeError:
                    return 'binary'
        except (IOError, OSError):
            return 'binary'

    def get_file_content_for_viewing(self, file_path):
        """Get file content/info for viewing. Returns (metadata_lines, content_lines, file_type)."""
        file_type = self.get_file_type(file_path)
        metadata_lines = []
        content_lines = []

        try:
            file_size = file_path.stat().st_size
            size_mb = file_size / (1024 * 1024)

            # Add header with file info (metadata)
            metadata_lines.append(f"File: {file_path.name}")
            metadata_lines.append(f"Path: {file_path}")
            metadata_lines.append(f"Size: {file_size:,} bytes ({size_mb:.2f} MB)")
            metadata_lines.append(f"Type: {file_type.upper()}")

            if file_type == 'image':
                # Try to get EXIF data or image info
                content_lines.append("")

                # Try exiftool first
                try:
                    import subprocess
                    result = subprocess.run(['exiftool', str(file_path)],
                                          capture_output=True, text=True, timeout=5)
                    if result.returncode == 0:
                        content_lines.extend(result.stdout.splitlines())
                    else:
                        raise Exception("exiftool failed")
                except:
                    # Try identify (ImageMagick)
                    try:
                        result = subprocess.run(['identify', '-verbose', str(file_path)],
                                              capture_output=True, text=True, timeout=5)
                        if result.returncode == 0:
                            content_lines.extend(result.stdout.splitlines())
                        else:
                            raise Exception("identify failed")
                    except:
                        # Just show basic info
                        content_lines.append("(No image tools available - install exiftool or ImageMagick for details)")
                        content_lines.append("")
                        content_lines.append("This is an image file. Use an image viewer to see it.")

            elif file_type == 'text':

                # Limit reading to 10MB for text files
                max_bytes = 10 * 1024 * 1024

                with open(file_path, 'r', encoding='utf-8', errors='replace') as f:
                    bytes_read = 0
                    for line_num, line in enumerate(f, 1):
                        if bytes_read >= max_bytes:
                            content_lines.append("")
                            content_lines.append(f"... (file truncated at {max_bytes:,} bytes, showing first ~{line_num} lines)")
                            break
                        content_lines.append(line.rstrip('\n\r'))
                        bytes_read += len(line.encode('utf-8'))

            else:  # binary

                # Show hex dump of first 4KB
                max_bytes = 4096
                with open(file_path, 'rb') as f:
                    data = f.read(max_bytes)

                # Create hex dump
                for i in range(0, len(data), 16):
                    chunk = data[i:i+16]
                    hex_part = ' '.join(f'{b:02x}' for b in chunk)
                    ascii_part = ''.join(chr(b) if 32 <= b < 127 else '.' for b in chunk)
                    content_lines.append(f'{i:08x}  {hex_part:<48}  {ascii_part}')

                if file_size > max_bytes:
                    content_lines.append("")
                    content_lines.append(f"... (showing first {max_bytes:,} of {file_size:,} bytes)")

        except Exception as e:
            content_lines.append(f"Error reading file: {e}")

        return metadata_lines, content_lines, file_type

    def draw_file_viewer(self, stdscr, file_path, metadata_lines, content_lines, scroll_offset):
        """Draw file viewer as centered overlay window (75% width, 85% height)."""
        term_height, term_width = stdscr.getmaxyx()

        # Create centered overlay window (75% width, 85% height)
        height = int(term_height * 0.85)
        width = int(term_width * 0.75)
        y = (term_height - height) // 2
        x = (term_width - width) // 2

        # Create window for file viewer
        viewer_win = curses.newwin(height, width, y, x)
        viewer_win.clear()
        viewer_win.border()

        # Title
        title = f" Viewing: {file_path.name} (q/ESC to close, arrows/j/k to scroll) "
        viewer_win.addstr(0, 2, title[:width-4], curses.A_BOLD | curses.A_REVERSE)

        # Draw metadata section (fixed, not scrollable, in dim color)
        metadata_height = len(metadata_lines)
        for i, line in enumerate(metadata_lines):
            display_line = line[:width-3]
            try:
                viewer_win.addstr(1 + i, 1, display_line, curses.A_DIM)
            except curses.error:
                pass

        # Draw separator line
        separator_y = 1 + metadata_height
        try:
            viewer_win.addstr(separator_y, 1, "‚îÄ" * (width - 2))
        except curses.error:
            pass

        # Calculate visible area for content (below metadata and separator)
        content_start_y = separator_y + 1
        content_height = height - content_start_y - 1  # -1 for bottom border
        max_offset = max(0, len(content_lines) - content_height)
        scroll_offset = max(0, min(scroll_offset, max_offset))

        # Draw content lines (scrollable)
        for i in range(content_height):
            line_idx = scroll_offset + i
            if line_idx < len(content_lines):
                line = content_lines[line_idx]
                # Truncate line to fit width
                display_line = line[:width-3]
                try:
                    viewer_win.addstr(content_start_y + i, 1, display_line)
                except curses.error:
                    pass  # Ignore errors from writing to last position

        # Draw scrollbar indicator if needed
        if len(content_lines) > content_height:
            percent = (scroll_offset / max_offset * 100) if max_offset > 0 else 0
            status = f" {percent:.0f}% ({scroll_offset + 1}-{min(scroll_offset + content_height, len(content_lines))} of {len(content_lines)}) "
            try:
                viewer_win.addstr(height - 1, width - len(status) - 2, status, curses.A_REVERSE)
            except curses.error:
                pass

        viewer_win.refresh()
        return scroll_offset, len(content_lines)

    def get_help_text(self, mode):
        """Get context-sensitive help text for the given mode."""
        if mode == 'main':
            return """Main View - Exploring Duplicate Files

Navigation:
  ‚Üë/‚Üì or j/k        Navigate items
  ‚Üê/‚Üí or h/l        Switch panes / navigate filtered view
  Tab               Switch between top and bottom pane
  Enter             Drill down into filtered view
  PgUp/PgDn         Page up/down
  Ctrl-B/Ctrl-F     Page up/down
  Home/End or </>   Jump to first/last item

Actions:
  v                 View selected file
  o                 Open selected file with system default application
  t                 Trash selected file or directory
  u                 Undo last trash operation
  T                 View trash
  q                 Quit

The top pane shows directories by redundancy.
The bottom pane shows files in selected directory.
Selecting a file filters the top pane to show only
directories containing that file."""

        elif mode == 'trash':
            return """Trash Viewer

Navigation:
  ‚Üë/‚Üì or j/k        Navigate trash items
  PgUp/PgDn         Page up/down
  Ctrl-B/Ctrl-F     Page up/down
  Home/End or </>   Jump to first/last item

Actions:
  v                 View selected file
  o                 Open selected file with desktop viewer
  r                 Restore selected item
  t or Esc          Return to main view
  q                 Quit

Files are moved to ~dedupdir-trash/ in each root
directory. They remain there until you manually
delete the trash directories."""

        elif mode == 'viewer':
            return """File Viewer

Navigation:
  ‚Üë/‚Üì or j/k        Scroll up/down one line
  PgUp/PgDn         Scroll up/down one page
  Ctrl-B/Ctrl-F     Page up/down (alternative)
  Home/End or </>   Jump to start/end

Display:
  - Metadata shown at top (file, path, size, type)
  - Horizontal line separates metadata from content
  - Text files: shows content (up to 10MB)
  - Images: shows EXIF data if available
  - Binary files: shows hex dump (first 4KB)

Actions:
  q or Esc          Close viewer and return"""

        elif mode == 'confirm':
            return """Trash Confirmation

You are about to trash an item that is not fully
redundant. If you trash it, you will lose data unless
you restore it from the trash.

Actions:
  y or Y            Confirm - move to trash
  n or N            Cancel
  Esc               Cancel
  q                 Quit application
"""
        else:
            return "Help not available for this mode."

    def draw_help_popup(self, stdscr, mode, scroll_offset=0):
        """Draw help popup as centered overlay with scrolling support."""
        term_height, term_width = stdscr.getmaxyx()

        # Help window size (80% width, 80% height)
        height = int(term_height * 0.80)
        width = int(term_width * 0.80)
        width = min(width, 80)  # Max 80 chars wide
        y = (term_height - height) // 2
        x = (term_width - width) // 2

        # Create help window
        help_win = curses.newwin(height, width, y, x)
        help_win.clear()
        help_win.border()

        # Title
        title = " Help - h/‚Üê/Esc to close, ‚Üë‚Üì/j/k to scroll "
        help_win.addstr(0, (width - len(title)) // 2, title[:width-2], curses.A_BOLD | curses.A_REVERSE)

        # Get help text and display
        help_text = self.get_help_text(mode)
        lines = help_text.split('\n')

        # Calculate visible area and scroll bounds
        visible_height = height - 2
        max_offset = max(0, len(lines) - visible_height)
        scroll_offset = max(0, min(scroll_offset, max_offset))

        # Draw help lines with scrolling
        for i in range(visible_height):
            line_idx = scroll_offset + i
            if line_idx < len(lines):
                display_line = lines[line_idx][:width-3]
                try:
                    help_win.addstr(1 + i, 1, display_line)
                except curses.error:
                    pass

        # Draw scroll indicator if needed
        if len(lines) > visible_height:
            percent = (scroll_offset / max_offset * 100) if max_offset > 0 else 0
            status = f" {percent:.0f}% ({scroll_offset + 1}-{min(scroll_offset + visible_height, len(lines))} of {len(lines)}) "
            try:
                help_win.addstr(height - 1, width - len(status) - 2, status, curses.A_REVERSE)
            except curses.error:
                pass

        help_win.refresh()
        return scroll_offset, len(lines)

    def show_help_viewer(self, stdscr, mode):
        """Show scrollable help viewer and handle navigation until exit."""
        scroll_offset = 0
        while True:
            scroll_offset, total_lines = self.draw_help_popup(stdscr, mode, scroll_offset)
            help_key = stdscr.getch()

            if help_key in (ord('h'), ord('H'), curses.KEY_LEFT, 27):  # h, H, ‚Üê, or ESC
                break
            elif help_key == curses.KEY_RESIZE:
                stdscr.clear()
                stdscr.refresh()
                continue
            elif help_key in (curses.KEY_UP, ord('k')):
                scroll_offset = max(0, scroll_offset - 1)
            elif help_key in (curses.KEY_DOWN, ord('j')):
                help_height = int(stdscr.getmaxyx()[0] * 0.80)
                visible_height = help_height - 2
                max_offset = max(0, total_lines - visible_height)
                scroll_offset = min(max_offset, scroll_offset + 1)
            elif help_key in (curses.KEY_PPAGE, 2):  # Page Up or Ctrl-B
                help_height = int(stdscr.getmaxyx()[0] * 0.80)
                visible_height = help_height - 2
                scroll_offset = max(0, scroll_offset - visible_height)
            elif help_key in (curses.KEY_NPAGE, 6):  # Page Down or Ctrl-F
                help_height = int(stdscr.getmaxyx()[0] * 0.80)
                visible_height = help_height - 2
                max_offset = max(0, total_lines - visible_height)
                scroll_offset = min(max_offset, scroll_offset + visible_height)
            elif help_key in (curses.KEY_HOME, ord('<')):
                scroll_offset = 0
            elif help_key in (curses.KEY_END, ord('>')):
                help_height = int(stdscr.getmaxyx()[0] * 0.80)
                visible_height = help_height - 2
                scroll_offset = max(0, total_lines - visible_height)

    def open_file_with_system_app(self, file_path):
        """Open file with system's default application (cross-platform)."""
        try:
            import subprocess
            import platform
            system = platform.system()
            if system == 'Darwin':  # macOS
                subprocess.Popen(['open', str(file_path)])
            elif system == 'Windows':
                subprocess.Popen(['start', str(file_path)], shell=True)
            else:  # Linux and others
                subprocess.Popen(['xdg-open', str(file_path)])
        except Exception:
            pass  # Silently fail if can't open

    def get_hint_text(self, mode):
        """Get hint bar text for the given mode."""
        if mode == 'main':
            return "‚Üë‚Üì:Navigate  Enter:Drill Down  t:Trash  T:View Trash  q:Quit"
        elif mode == 'dir_detail':
            return "‚Üë‚Üì:Navigate  Enter:Drill Down  v:View  o:Open  t:Trash  Esc:Back"
        elif mode == 'file_detail':
            return "‚Üë‚Üì:Navigate  Enter:Drill Down  v:View  o:Open  t:Trash  Esc:Back"
        elif mode == 'trash':
            return "‚Üë‚Üì:Navigate  v:View  o:Open  r:Restore  T:Back"
        elif mode == 'viewer':
            return "‚Üë‚Üì:Scroll  PgUp/PgDn:Page  q:Close"
        elif mode == 'confirm':
            return "y:Yes  n:No  Esc:Cancel"
        else:
            return ""

    def draw_hint_bar(self, stdscr, mode):
        """Draw hint bar at bottom of screen."""
        height, width = stdscr.getmaxyx()

        hint_text = self.get_hint_text(mode)
        help_text = "[?] Help"

        # Calculate positions
        available_width = width - len(help_text) - 3  # -3 for spacing
        if len(hint_text) > available_width:
            hint_text = hint_text[:available_width-3] + "..."

        # Draw hint bar
        try:
            # Clear the line first with normal color, then draw text
            stdscr.addstr(height - 1, 0, " " * (width - 1))
            # Draw hints on left
            stdscr.addstr(height - 1, 1, hint_text, curses.A_DIM)
            # Draw help on right
            stdscr.addstr(height - 1, width - len(help_text) - 1, help_text, curses.A_DIM)
            stdscr.refresh()  # Explicitly refresh to ensure hint bar is visible
        except curses.error:
            pass  # Ignore errors at edge of screen

    def draw_confirmation_dialog(self, stdscr, message):
        """Draw a confirmation dialog in the center of the screen."""
        height, width = stdscr.getmaxyx()

        # Dialog dimensions
        dialog_height = 9
        dialog_width = min(70, width - 4)
        dialog_y = (height - dialog_height) // 2
        dialog_x = (width - dialog_width) // 2

        # Create dialog window
        dialog = curses.newwin(dialog_height, dialog_width, dialog_y, dialog_x)
        dialog.clear()
        dialog.box()

        # Split message by newlines first, then word wrap each line
        lines = []
        for msg_line in message.split('\n'):
            if not msg_line:
                lines.append("")
            else:
                words = msg_line.split()
                current_line = ""
                for word in words:
                    if len(current_line) + len(word) + 1 <= dialog_width - 4:
                        current_line += (" " if current_line else "") + word
                    else:
                        lines.append(current_line)
                        current_line = word
                if current_line:
                    lines.append(current_line)

        # Draw message lines
        for i, line in enumerate(lines[:5]):  # Max 5 lines
            dialog.addstr(1 + i, 2, line, curses.A_BOLD)

        # Draw prompt
        prompt = "Trash anyway? (y/n)"
        dialog.addstr(dialog_height - 2, (dialog_width - len(prompt)) // 2, prompt, curses.A_REVERSE)

        dialog.refresh()
        return dialog

    def handle_enter_key(self, view):
        """Handle Enter key - drill down into directories or files."""
        if view['type'] == 'main':
            # Drilling into a directory from main view
            if self.selected_idx < len(self.sorted_dirs):
                dir_path, _ = self.sorted_dirs[self.selected_idx]
                self.push_view({'type': 'dir_detail', 'data': {'dir_path': dir_path}})

        elif view['type'] == 'dir_detail':
            # Drilling into a file from directory view
            dir_path = view['data']['dir_path']
            files = self.get_all_files_with_counts(dir_path)

            if self.selected_idx < len(files):
                filename, _, file_path = files[self.selected_idx]
                self.push_view({'type': 'file_detail', 'data': {'file_path': file_path}})

        elif view['type'] == 'file_detail':
            # Drilling into a directory from file detail view
            file_path = view['data']['file_path']
            dirs_with_file = self.get_dirs_containing_file(file_path)
            if self.selected_idx < len(dirs_with_file):
                dir_path = dirs_with_file[self.selected_idx]
                self.push_view({'type': 'dir_detail', 'data': {'dir_path': dir_path}})

    def handle_trash_key(self, view):
        """Handle 't' key - trash selected item."""
        item_to_trash = None
        trash_type = None

        if view['type'] == 'main':
            # Trashing a directory from main view
            if self.selected_idx < len(self.sorted_dirs):
                dir_path, _ = self.sorted_dirs[self.selected_idx]
                item_to_trash = dir_path
                trash_type = 'directory'

        elif view['type'] == 'dir_detail':
            # Trashing a file from directory view
            dir_path = view['data']['dir_path']
            files = self.get_all_files_with_counts(dir_path)

            if self.selected_idx < len(files):
                _, _, file_path = files[self.selected_idx]
                item_to_trash = file_path
                trash_type = 'file'

        elif view['type'] == 'file_detail':
            # Trashing a directory from file detail view
            file_path = view['data']['file_path']
            dirs_with_file = self.get_dirs_containing_file(file_path)
            if self.selected_idx < len(dirs_with_file):
                dir_path = dirs_with_file[self.selected_idx]
                item_to_trash = dir_path
                trash_type = 'directory'

        if item_to_trash:
            # Check if confirmation needed
            needs_confirmation = False
            num_roots = len(self.root_paths)

            if trash_type == 'file':
                count = self.get_file_redundancy_count(item_to_trash)
                if count < num_roots:
                    needs_confirmation = True
            else:  # directory
                if not self.is_dir_fully_redundant(item_to_trash):
                    needs_confirmation = True

            if needs_confirmation:
                self.confirm_trash_item = item_to_trash
                self.confirm_trash_type = trash_type
            else:
                # Trash immediately
                self.trash_item(item_to_trash, trash_type)

    def handle_view_key(self, view, stdscr, height, width):
        """Handle 'v' key - view file content."""
        file_path = None

        if view['type'] == 'dir_detail':
            # Open file from directory view
            dir_path = view['data']['dir_path']
            files = self.get_all_files_with_counts(dir_path)

            if self.selected_idx < len(files):
                _, _, file_path = files[self.selected_idx]

        elif view['type'] == 'file_detail':
            # View the file itself
            file_path = view['data']['file_path']

        if file_path and file_path.is_file():
            # Get file content once before entering viewer loop
            metadata_lines, content_lines, file_type = self.get_file_content_for_viewing(file_path)

            # Enter file viewing mode
            scroll_offset = 0
            while True:
                # Get current terminal dimensions
                height, width = stdscr.getmaxyx()

                # Redraw current view as background
                usable_height = height - 1
                main_win = curses.newwin(usable_height, width, 0, 0)
                if view['type'] == 'main':
                    self.draw_main_view(main_win, usable_height, width)
                elif view['type'] == 'dir_detail':
                    self.draw_dir_detail_view(main_win, usable_height, width)
                elif view['type'] == 'file_detail':
                    self.draw_file_detail_view(main_win, usable_height, width)

                # Draw file viewer overlay on top
                scroll_offset, total_lines = self.draw_file_viewer(stdscr, file_path, metadata_lines, content_lines, scroll_offset)

                # Draw hint bar
                self.draw_hint_bar(stdscr, 'viewer')

                # Handle viewer input
                view_key = stdscr.getch()

                if view_key in (ord('q'), ord('Q'), 27):  # q, Q, or ESC
                    break
                elif view_key == curses.KEY_RESIZE:
                    stdscr.clear()
                    stdscr.refresh()
                    continue
                elif view_key == ord('?'):
                    self.show_help_viewer(stdscr, 'viewer')
                    continue
                elif view_key in (curses.KEY_UP, ord('k')):
                    scroll_offset = max(0, scroll_offset - 1)
                elif view_key in (curses.KEY_DOWN, ord('j')):
                    viewer_height = int(height * 0.85)
                    visible_height = viewer_height - 2
                    max_offset = max(0, total_lines - visible_height)
                    scroll_offset = min(max_offset, scroll_offset + 1)
                elif view_key in (curses.KEY_PPAGE, curses.KEY_NPAGE, 2, 6):  # PgUp/PgDn or Ctrl-B/Ctrl-F
                    viewer_height = int(height * 0.85)
                    visible_height = viewer_height - 2
                    if view_key in (curses.KEY_PPAGE, 2):  # Page Up or Ctrl-B
                        scroll_offset = max(0, scroll_offset - visible_height)
                    else:  # Page Down or Ctrl-F
                        max_offset = max(0, total_lines - visible_height)
                        scroll_offset = min(max_offset, scroll_offset + visible_height)
                elif view_key in (curses.KEY_HOME, ord('<')):
                    scroll_offset = 0
                elif view_key in (curses.KEY_END, ord('>')):
                    viewer_height = int(height * 0.85)
                    visible_height = viewer_height - 2
                    scroll_offset = max(0, total_lines - visible_height)

    def handle_open_key(self, view):
        """Handle 'o' key - open file with system default application."""
        file_path = None

        if view['type'] == 'dir_detail':
            # View file from directory view
            dir_path = view['data']['dir_path']
            files = self.get_all_files_with_counts(dir_path)

            if self.selected_idx < len(files):
                _, _, file_path = files[self.selected_idx]

        elif view['type'] == 'file_detail':
            # Open the file itself
            file_path = view['data']['file_path']

        if file_path and file_path.is_file():
            self.open_file_with_system_app(file_path)

    def draw_all_panes(self, usable_height, width):
        """Draw all panes in the view stack with proper indentation and frozen selections."""
        # First, draw the main view (always at bottom) with its saved selection
        main_win = curses.newwin(usable_height, width, 0, 0)
        main_view = self.view_stack[0]
        if len(self.view_stack) == 1:
            # Main view is current - use live selection
            main_selected = self.selected_idx
            main_scroll = self.scroll_offset
        else:
            # Main view is background - use frozen selection
            main_selected = main_view.get('selected_idx', 0)
            main_scroll = main_view.get('scroll_offset', 0)
        self.draw_main_view(main_win, usable_height, width, main_selected, main_scroll)

        # Then draw each overlay in the stack (skip index 0 which is always 'main')
        for level_idx in range(1, len(self.view_stack)):
            level_view = self.view_stack[level_idx]

            # Each level is indented 4 columns and 1 row from the previous
            indent_x = level_idx * 4
            indent_y = level_idx * 1

            # Calculate overlay size (descend 1 row but extend to bottom)
            overlay_height = usable_height - indent_y
            overlay_width = width - indent_x

            # Make sure we have room
            if overlay_height < 10 or overlay_width < 40:
                break

            # Determine if this is the current view or a background view
            is_current_view = (level_idx == len(self.view_stack) - 1)

            # For background views, use their saved selection; for current view, use live selection
            if is_current_view:
                # Current view - use live selection (responds to arrow keys)
                draw_selected_idx = self.selected_idx
                draw_scroll_offset = self.scroll_offset
            else:
                # Background view - use frozen saved selection
                draw_selected_idx = level_view.get('selected_idx', 0)
                draw_scroll_offset = level_view.get('scroll_offset', 0)

            # Draw the overlay with the appropriate selection
            overlay_win = curses.newwin(overlay_height, overlay_width, indent_y, indent_x)
            if level_view['type'] == 'dir_detail':
                self.draw_dir_detail_view(overlay_win, overlay_height, overlay_width, level_view, draw_selected_idx, draw_scroll_offset)
            elif level_view['type'] == 'file_detail':
                self.draw_file_detail_view(overlay_win, overlay_height, overlay_width, level_view, draw_selected_idx, draw_scroll_offset)


    def run(self, stdscr):
        """Main TUI loop."""
        curses.curs_set(0)  # Hide cursor
        stdscr.clear()

        # Set escape delay to 25ms to make ESC key responsive
        if hasattr(curses, 'set_escdelay'):
            curses.set_escdelay(25)

        # Initialize colors if available
        if curses.has_colors():
            curses.init_pair(1, curses.COLOR_WHITE, curses.COLOR_BLUE)

        # Show loading message
        height, width = stdscr.getmaxyx()
        stdscr.addstr(height // 2, width // 2 - 10, "Starting TUI...", curses.A_BOLD)
        stdscr.refresh()

        if not self.sorted_dirs:
            # No duplicates found - show trash viewer
            self.viewing_trash = True
            self.trash_selected_idx = 0
            self.trash_offset = 0
            self.show_no_duplicates_message = True
        else:
            self.show_no_duplicates_message = False

        # Main loop
        while True:
            height, width = stdscr.getmaxyx()
            usable_height = height - 1  # Reserve last line for hint bar

            # Handle different display modes
            if self.viewing_trash:
                # Draw trash viewer overlay
                view = self.get_current_view()
                if view['type'] == 'main':
                    main_win = curses.newwin(usable_height, width, 0, 0)
                    self.draw_main_view(main_win, usable_height, width, self.selected_idx, self.scroll_offset)

                # Draw trash viewer as centered overlay (85% width, 92% height)
                trash_height = int(usable_height * 0.92)
                trash_width = int(width * 0.85)
                trash_y = (usable_height - trash_height) // 2
                trash_x = (width - trash_width) // 2
                trash_win = curses.newwin(trash_height, trash_width, trash_y, trash_x)
                self.draw_trash_pane(trash_win, trash_height, trash_width)
                self.draw_hint_bar(stdscr, 'trash')

            elif self.confirm_trash_item is not None:
                # Draw confirmation dialog - draw all panes then overlay the dialog
                self.draw_all_panes(usable_height, width)

                # Draw confirmation dialog on top of all panes
                rel_path = self.get_path_with_root(self.confirm_trash_item)
                message = f"There is only one copy of\n\n{rel_path}\n\nIf you trash it, you will lose data."
                self.draw_confirmation_dialog(stdscr, message)
                self.draw_hint_bar(stdscr, 'confirm')

            else:
                # Normal view - draw all panes in the stack
                self.draw_all_panes(usable_height, width)

                view = self.get_current_view()
                self.draw_hint_bar(stdscr, view['type'])

            # Handle input
            key = stdscr.getch()

            # Handle terminal resize
            if key == curses.KEY_RESIZE:
                stdscr.clear()
                stdscr.refresh()
                continue

            # Handle confirmation dialog first (takes priority)
            if self.confirm_trash_item is not None:
                if key in (ord('q'), ord('Q')):
                    break
                if key in (ord('y'), ord('Y')):
                    item_path, item_type = self.confirm_trash_item, self.confirm_trash_type
                    self.trash_item(item_path, item_type)
                    self.confirm_trash_item = None
                    self.confirm_trash_type = None
                    continue
                elif key in (ord('n'), ord('N'), 27):  # n, N, or ESC
                    self.confirm_trash_item = None
                    self.confirm_trash_type = None
                    continue
                elif key == ord('?'):
                    self.show_help_viewer(stdscr, 'confirm')
                    continue
                else:
                    continue

            # Handle trash viewing mode
            if self.viewing_trash:
                if key in (ord('q'), ord('Q')):
                    break
                elif key in (ord('T'),):
                    if not self.show_no_duplicates_message:
                        self.viewing_trash = False
                    continue
                elif key == 27:  # ESC
                    if not self.show_no_duplicates_message:
                        self.viewing_trash = False
                    continue
                elif key == ord('?'):
                    self.show_help_viewer(stdscr, 'trash')
                    continue
                elif key in (ord('o'), ord('O')):
                    items = self.get_trash_items()
                    if items and self.trash_selected_idx < len(items):
                        item_dict = items[self.trash_selected_idx]
                        trash_path = Path(item_dict['trash_path'])
                        if trash_path.is_file():
                            self.open_file_with_system_app(trash_path)
                    continue
                elif key in (curses.KEY_UP, ord('k')):
                    items = self.get_trash_items()
                    if self.trash_selected_idx > 0:
                        self.trash_selected_idx -= 1
                        if self.trash_selected_idx < self.trash_offset:
                            self.trash_offset = self.trash_selected_idx
                elif key in (curses.KEY_DOWN, ord('j')):
                    items = self.get_trash_items()
                    if self.trash_selected_idx < len(items) - 1:
                        self.trash_selected_idx += 1
                        if self.trash_selected_idx >= self.trash_offset + (height - 2):
                            self.trash_offset = self.trash_selected_idx - (height - 2) + 1
                elif key in (ord('r'), ord('R')):
                    items = self.get_trash_items()
                    if items and self.trash_selected_idx < len(items):
                        if self.restore_from_trash(items[self.trash_selected_idx]):
                            items = self.get_trash_items()
                            if self.trash_selected_idx >= len(items) and len(items) > 0:
                                self.trash_selected_idx = len(items) - 1
                            if self.show_no_duplicates_message and self.sorted_dirs:
                                self.show_no_duplicates_message = False
                                self.viewing_trash = False
                continue

            # Normal navigation and actions
            view = self.get_current_view()
            list_size = self.get_current_list_size()

            # Q key - quit
            if key in (ord('q'), ord('Q')):
                break

            # ESC / Left arrow - go back
            elif key in (27, curses.KEY_LEFT, ord('h')):
                if not self.pop_view():
                    self.show_quit_message = True
                continue

            # ? key - help
            elif key == ord('?'):
                self.show_help_viewer(stdscr, view['type'])
                continue

            # T key - view trash
            elif key in (ord('T'),):
                if not self.viewing_trash:
                    self.viewing_trash = True
                    self.trash_selected_idx = 0
                    self.trash_offset = 0
                continue

            # U key - undo last trash
            elif key in (ord('u'), ord('U')):
                self.undo_last_trash()
                continue

            # Navigation keys
            elif key in (curses.KEY_UP, ord('k')):
                if self.selected_idx > 0:
                    self.selected_idx -= 1
                    if self.selected_idx < self.scroll_offset:
                        self.scroll_offset = self.selected_idx
            elif key in (curses.KEY_DOWN, ord('j')):
                if self.selected_idx < list_size - 1:
                    self.selected_idx += 1
                    visible_lines = usable_height - 5
                    if self.selected_idx >= self.scroll_offset + visible_lines:
                        self.scroll_offset = self.selected_idx - visible_lines + 1
            elif key in (curses.KEY_PPAGE, 2):  # Page Up / Ctrl-B
                visible_lines = usable_height - 5
                self.selected_idx = max(0, self.selected_idx - visible_lines)
                self.scroll_offset = max(0, self.scroll_offset - visible_lines)
            elif key in (curses.KEY_NPAGE, 6):  # Page Down / Ctrl-F
                visible_lines = usable_height - 5
                self.selected_idx = min(list_size - 1, self.selected_idx + visible_lines)
                self.scroll_offset = min(self.scroll_offset + visible_lines, max(0, list_size - visible_lines))
            elif key in (curses.KEY_HOME, ord('g')):
                self.selected_idx = 0
                self.scroll_offset = 0
            elif key in (curses.KEY_END, ord('G')):
                self.selected_idx = list_size - 1
                visible_lines = usable_height - 5
                self.scroll_offset = max(0, list_size - visible_lines)

            # Enter key - drill down
            elif key in (curses.KEY_ENTER, ord('\n'), ord('\r')):
                self.handle_enter_key(view)
                continue

            # 't' key - trash item
            elif key == ord('t'):
                self.handle_trash_key(view)
                continue

            # 'v' key - view file
            elif key in (ord('v'), ord('V')):
                self.handle_view_key(view, stdscr, height, width)
                continue

            # 'o' key - open file
            elif key in (ord('o'), ord('O')):
                self.handle_open_key(view)
                continue

def main():
    import argparse

    parser = argparse.ArgumentParser(
        prog='dedupdir-tui',
        description='Interactive TUI for exploring redundant directories.'
    )
    parser.add_argument(
        'directories',
        nargs='*',
        default=['.'],
        metavar='directory',
        help='Directories to scan (default: current directory)'
    )
    parser.add_argument(
        '-a', '--algorithm',
        default='blake2b',
        choices=['md5', 'sha1', 'sha256', 'blake2b', 'blake2s'],
        help='Hash algorithm to use (default: blake2b)'
    )
    parser.add_argument(
        '-j', '--jobs',
        type=int,
        default=4,
        metavar='N',
        help='Number of parallel hashing jobs (default: 4, use 1 to disable)'
    )

    args = parser.parse_args()

    # Handle both single directory and multiple directories
    roots = []
    for directory in args.directories:
        root = Path(directory).resolve()
        if not root.exists():
            print(f"Error: '{directory}' does not exist", file=sys.stderr)
            sys.exit(1)
        if not root.is_dir():
            print(f"Error: '{directory}' is not a directory", file=sys.stderr)
            sys.exit(1)
        roots.append(root)

    tui = DedupdirTUI(roots, algorithm=args.algorithm, jobs=args.jobs)

    # Scan with progress output before starting TUI
    if len(roots) == 1:
        print(f"Scanning {roots[0]}...")
    else:
        print(f"Scanning {len(roots)} directories...")
        for root in roots:
            print(f"  {root}")
    tui.scan(quiet=False)

    if not tui.sorted_dirs:
        print("No duplicate files found.")
        sys.exit(0)

    try:
        curses.wrapper(tui.run)
    except KeyboardInterrupt:
        pass


if __name__ == '__main__':
    main()
