#!/usr/bin/env python3
"""
dedupdir-tui - Interactive TUI for exploring redundant directories
version 0.2.XX

This script provides a TUI to help quickly deduplicate files. It shows the
redundancies scores for all directories in a tree and lets you temporarily
remove files and immediately see the effect on the scores.
"""

import curses
import sys
import os
import shutil
import threading
import queue
from pathlib import Path
from datetime import datetime

# Import core functions from dedupdir by loading it directly
def load_dedupdir():
    """Load dedupdir module from same directory or PATH."""
    import types

    # Try to find dedupdir in same directory as this script
    # Check multiple possible locations
    possible_paths = [
        Path(__file__).parent / "dedupdir",  # Same directory
        Path.cwd() / "dedupdir",  # Current working directory
        Path(sys.argv[0]).parent / "dedupdir",  # Script directory from argv
    ]

    for dedupdir_path in possible_paths:
        if dedupdir_path.exists() and dedupdir_path.is_file():
            try:
                # Read and execute the file directly since it has no .py extension
                with open(dedupdir_path, 'r') as f:
                    code = f.read()

                # Create a module to hold the executed code
                dedupdir = types.ModuleType('dedupdir')
                dedupdir.__file__ = str(dedupdir_path)
                sys.modules['dedupdir'] = dedupdir

                # Execute the code in the module's namespace
                exec(code, dedupdir.__dict__)

                # Verify required functions exist
                if hasattr(dedupdir, 'find_duplicates') and hasattr(dedupdir, 'calculate_redundancy_score'):
                    return dedupdir
            except Exception as e:
                print(f"Error loading {dedupdir_path}: {e}", file=sys.stderr)
                continue

    # Try regular import as fallback
    try:
        import dedupdir
        return dedupdir
    except ImportError:
        pass

    print("Error: Could not find dedupdir script", file=sys.stderr)
    print("Tried locations:", file=sys.stderr)
    for p in possible_paths:
        print(f"  {p} (exists: {p.exists()})", file=sys.stderr)
    sys.exit(1)

dedupdir_module = load_dedupdir()
find_duplicates = dedupdir_module.find_duplicates
calculate_redundancy_score = dedupdir_module.calculate_redundancy_score
hash_file = dedupdir_module.hash_file
CACHE_FILE_NAME = dedupdir_module.CACHE_FILE_NAME


class DedupdirTUI:
    def __init__(self, root_paths, algorithm='blake2b', jobs=4):
        # Normalize to list
        if isinstance(root_paths, (str, Path)):
            root_paths = [root_paths]
        self.root_paths = [Path(p).resolve() for p in root_paths]
        self.algorithm = algorithm
        self.jobs = jobs

        # Navigation state
        self.selected_idx = 0
        self.scroll_offset = 0
        self.show_quit_message = False

        # View stack for drill-down navigation
        # Each entry is a dict: {'type': 'main'|'dir_detail'|'file_detail', 'data': {...}}
        self.view_stack = [{'type': 'main'}]

        # Trash system (trash dirs are per-root, not in cwd)
        self.trash_stack = []  # Stack for undo: [(original_path, trash_path, is_dir), ...]
        self.viewing_trash = False  # Whether we're in trash viewing mode
        self.trash_selected_idx = 0
        self.trash_offset = 0
        self.confirm_trash_item = None  # Item pending confirmation
        self.confirm_trash_type = None  # 'file' or 'directory'
        self.confirm_quit = False  # Whether quit confirmation is pending
        self.show_no_duplicates_message = False  # Show message when no duplicates found

        # Collapsed directory groups - set of parent dir paths that are collapsed
        self.expanded_groups = set()  # Groups that have been explicitly expanded
        self._display_list_cache = None  # Cached display list for performance
        self._dir_sizes_cache = {}  # Cache for directory sizes to avoid repeated stat() calls
        self._relationship_cache = None  # Cache for parent-child relationships (expensive to compute)

        # Data will be populated by scan()
        self.sorted_dirs = []
        self.dir_stats = {}
        self.file_to_hash = {}
        self.hash_to_dirs = {}
        self.dir_all_files = {}
        self.total_duplicates = 0
        self.total_files = 0

        # Background verification state
        self.cached_hashes = {}  # file_path -> hash for files loaded from cache
        self.verification_thread = None
        self.verification_error = None  # Set if verification fails
        self.verification_queue = queue.Queue()  # For communicating errors from thread
        self.verification_complete = False
        self.verification_progress = (0, 0)  # (verified, total)

    def scan(self, quiet=False):
        """Scan the directory tree for duplicates."""
        result = find_duplicates(
            self.root_paths,
            algorithm=self.algorithm,
            jobs=self.jobs,
            quiet=quiet
        )
        self.dir_stats, self.total_duplicates, self.total_files, \
            self.file_to_hash, self.hash_to_dirs, self.dir_all_files, \
            self.cached_hashes = result

        # Recalculate sorted_dirs with all directories
        self.recalculate_sorted_dirs()
        self.invalidate_display_cache()

        # Start background verification if we used cached data
        if self.cached_hashes:
            self.start_background_verification()

    def start_background_verification(self):
        """Start a background thread to verify cached hashes."""
        if not self.cached_hashes:
            self.verification_complete = True
            return

        self.verification_progress = (0, len(self.cached_hashes))

        def verify_worker():
            """Background worker that verifies cached hashes one at a time."""
            files_to_verify = list(self.cached_hashes.items())
            total = len(files_to_verify)
            verified = 0

            for fpath, expected_hash in files_to_verify:
                verified += 1
                self.verification_progress = (verified, total)

                try:
                    actual_hash = hash_file(fpath, self.algorithm)
                    if actual_hash is None:
                        # File unreadable - skip
                        continue
                    if actual_hash != expected_hash:
                        error_msg = f"Cache verification failed!\n\nFile: {fpath}\nExpected: {expected_hash[:16]}...\nActual: {actual_hash[:16]}...\n\nThe file was modified but the cache wasn't updated.\nRemove {CACHE_FILE_NAME} files and restart."
                        self.verification_queue.put(('error', error_msg))
                        return
                except Exception:
                    # Skip files that can't be read
                    continue

            # Verification complete with no errors
            self.verification_queue.put(('complete', None))

        self.verification_thread = threading.Thread(target=verify_worker, daemon=True)
        self.verification_thread.start()

    def check_verification_status(self):
        """Check for verification errors from background thread. Returns error message or None."""
        try:
            while True:
                msg_type, msg_data = self.verification_queue.get_nowait()
                if msg_type == 'error':
                    self.verification_error = msg_data
                    return msg_data
                elif msg_type == 'complete':
                    self.verification_complete = True
        except queue.Empty:
            pass
        return None

    def recalculate_sorted_dirs(self):
        """Recalculate sorted_dirs including ALL directories, even those with 0% redundancy."""
        all_dirs_with_stats = []
        for dir_path, files in self.dir_all_files.items():
            if dir_path in self.dir_stats:
                # Directory has duplicates
                all_dirs_with_stats.append((dir_path, self.dir_stats[dir_path]))
            else:
                # Directory has no duplicates - add with 0/N stats
                total_files = len(files)
                all_dirs_with_stats.append((dir_path, (0, total_files)))

        # Sort directories by redundancy score
        self.sorted_dirs = sorted(
            all_dirs_with_stats,
            key=lambda x: (-calculate_redundancy_score(x[1][0], x[1][1]), str(x[0]))
        )

    def invalidate_display_cache(self):
        """Invalidate the display list cache, forcing a rebuild on next access."""
        self._display_list_cache = None

    def invalidate_relationship_cache(self):
        """Invalidate the relationship cache, forcing a rebuild on next access."""
        self._relationship_cache = None
        self._display_list_cache = None  # Display list depends on relationships

    def invalidate_size_cache(self):
        """Invalidate the directory sizes cache."""
        self._dir_sizes_cache = {}

    def get_dir_size(self, dir_path):
        """Get total size of files in a directory (cached)."""
        if dir_path in self._dir_sizes_cache:
            return self._dir_sizes_cache[dir_path]

        total_size = 0
        for fpath in self.dir_all_files.get(dir_path, []):
            try:
                total_size += fpath.stat().st_size
            except:
                pass

        self._dir_sizes_cache[dir_path] = total_size
        return total_size

    def build_relationship_cache(self):
        """Build and cache parent-child relationships (expensive operation)."""
        if self._relationship_cache is not None:
            return self._relationship_cache

        if not self.sorted_dirs:
            self._relationship_cache = (set(), {})
            return self._relationship_cache

        # First pass: identify which directories are 100% redundant
        fully_redundant = set()
        for dir_path, (dups, total) in self.sorted_dirs:
            if total > 0 and dups == total:
                fully_redundant.add(dir_path)

        # Second pass: find parent-child relationships among sorted_dirs
        # A child is a subdirectory of a parent if parent is a prefix of child
        children_map = {}  # parent_path -> [(child_path, stats), ...]

        for i, (dir_path, stats) in enumerate(self.sorted_dirs):
            # Find the closest parent in the list
            for j, (potential_parent, _) in enumerate(self.sorted_dirs):
                if i != j and self.is_subdir(dir_path, potential_parent):
                    # Check if there's a closer parent
                    is_closest = True
                    for k, (other_parent, _) in enumerate(self.sorted_dirs):
                        if k != i and k != j and self.is_subdir(dir_path, other_parent) and self.is_subdir(other_parent, potential_parent):
                            is_closest = False
                            break
                    if is_closest:
                        if potential_parent not in children_map:
                            children_map[potential_parent] = []
                        children_map[potential_parent].append((dir_path, stats))
                        break

        self._relationship_cache = (fully_redundant, children_map)
        return self._relationship_cache

    def build_display_list(self):
        """Build display list with collapsible groups for 100% redundant subdirectories.

        Returns list of display items, each is either:
        - ('dir', dir_path, stats, is_child) - a regular directory entry (is_child=True if under a collapse)
        - ('collapse', parent_path, child_dirs, total_files, total_dups) - a collapse line
        """
        # Return cached version if available
        if self._display_list_cache is not None:
            return self._display_list_cache

        if not self.sorted_dirs:
            return []

        # Get cached relationship data (expensive to compute)
        fully_redundant, children_map = self.build_relationship_cache()

        # Build display list using cached relationships
        display_list = []
        skip_dirs = set()  # Dirs to skip because they're in a collapse
        child_of_collapse = set()  # Dirs that are children of an expanded collapse

        for dir_path, stats in self.sorted_dirs:
            if dir_path in skip_dirs:
                continue

            # Check if this is a child of an expanded collapse
            is_child = dir_path in child_of_collapse

            # Add the directory itself
            display_list.append(('dir', dir_path, stats, is_child))

            # Check if this directory has collapsible children
            if dir_path in children_map and dir_path in fully_redundant:
                children = children_map[dir_path]
                # Check if ALL children are 100% redundant
                all_children_redundant = all(
                    child_path in fully_redundant
                    for child_path, _ in children
                )

                if all_children_redundant and children:
                    # Calculate totals for the collapse
                    total_files = sum(s[1] for _, s in children)
                    total_dups = sum(s[0] for _, s in children)

                    # Calculate total size of files in collapsed directories (using cache)
                    total_size = sum(self.get_dir_size(child_path) for child_path, _ in children)

                    # Add collapse line
                    child_paths = [cp for cp, _ in children]
                    display_list.append(('collapse', dir_path, child_paths, total_files, total_dups, total_size))

                    # If not expanded, skip the children
                    if dir_path not in self.expanded_groups:
                        for child_path, _ in children:
                            skip_dirs.add(child_path)
                            # Also skip grandchildren
                            if child_path in children_map:
                                for grandchild_path, _ in children_map[child_path]:
                                    skip_dirs.add(grandchild_path)
                    else:
                        # Mark children as belonging to this collapse (for indentation)
                        for child_path, _ in children:
                            child_of_collapse.add(child_path)

        self._display_list_cache = display_list
        return display_list

    def is_subdir(self, child, parent):
        """Check if child is a subdirectory of parent."""
        try:
            child.relative_to(parent)
            return child != parent
        except ValueError:
            return False

    def get_path_with_root(self, path):
        """Get path including root prefix (e.g., 'pix/subdir/file.jpg')."""
        path = Path(path)
        # Find which root this path belongs to
        for root in self.root_paths:
            try:
                rel = path.relative_to(root.parent)
                return str(rel)
            except ValueError:
                continue
        # Fallback to just the path
        return str(path)

    def get_relative_path(self, path):
        """Convert absolute path to relative display path."""
        # Try each root path
        for root_path in self.root_paths:
            try:
                rel = path.relative_to(root_path)
                display = str(root_path.name / rel) if str(rel) != '.' else str(root_path.name)
                return display
            except ValueError:
                continue
        # If not relative to any root, use absolute path
        return str(path)

    def get_related_dirs(self, dir_path):
        """Get related directories and their hypothetical redundancy scores.

        Returns list of (related_dir_path, shared_files, duplicates, total_files) tuples.
        """
        # Find all hashes in this directory
        dir_hashes = set()
        for fpath in self.dir_all_files.get(dir_path, []):
            if fpath in self.file_to_hash:
                dir_hashes.add(self.file_to_hash[fpath])

        # Find related directories and count shared files
        related_dirs_info = {}
        for h in dir_hashes:
            for d in self.hash_to_dirs[h]:
                if d != dir_path:
                    if d not in related_dirs_info:
                        related_dirs_info[d] = 0
                    related_dirs_info[d] += 1  # Count shared files

        # Calculate hypothetical redundancy for each related directory
        related_info = []
        for related_dir, shared_count in related_dirs_info.items():
            related_files = self.dir_all_files.get(related_dir, [])
            total_related = len(related_files)

            hypothetical_duplicates = 0
            for fpath in related_files:
                if fpath in self.file_to_hash:
                    h = self.file_to_hash[fpath]
                    other_dirs = self.hash_to_dirs[h] - {dir_path, related_dir}
                    if len(other_dirs) > 0:
                        hypothetical_duplicates += 1

            related_info.append((related_dir, shared_count, hypothetical_duplicates, total_related))

        # Sort by shared files descending, then by hypothetical duplicates descending
        related_info.sort(key=lambda x: (-x[1], -x[2]))
        return related_info

    def get_duplicate_files(self, dir_path):
        """Get list of duplicate files in the directory."""
        dup_files = []
        for fpath in self.dir_all_files.get(dir_path, []):
            if fpath in self.file_to_hash:
                dup_files.append(fpath.name)
        return sorted(dup_files)

    def get_all_files_with_counts(self, dir_path):
        """Get list of all files in directory with count of dirs containing each.

        Returns list of (filename, dir_count, file_path) tuples, sorted by
        dir_count descending (most duplicated first), then by filename.
        """
        file_info = []
        for fpath in self.dir_all_files.get(dir_path, []):
            fname = fpath.name
            # Count how many directories contain this file (by hash)
            if fpath in self.file_to_hash:
                fhash = self.file_to_hash[fpath]
                dir_count = len(self.hash_to_dirs.get(fhash, set()))
            else:
                # Unique file (not hashed, only in this directory)
                dir_count = 1
            file_info.append((fname, dir_count, fpath))

        # Sort by count descending, then by filename
        file_info.sort(key=lambda x: (-x[1], x[0]))
        return file_info

    def get_dirs_containing_file(self, file_path):
        """Get list of directories that contain the given file (by hash)."""
        if file_path not in self.file_to_hash:
            # Unique file, only in its own directory
            return [file_path.parent]

        fhash = self.file_to_hash[file_path]
        return list(self.hash_to_dirs.get(fhash, set()))

    def get_filename_in_dir(self, file_path, dir_path):
        """Get the actual filename for a file's hash in a specific directory.

        Since duplicate files can have different names in different directories,
        we need to look up the actual filename in each directory.
        """
        if file_path not in self.file_to_hash:
            # Unique file, just return its name
            return file_path.name

        fhash = self.file_to_hash[file_path]

        # Search through all files in the target directory for one with matching hash
        for fpath in self.dir_all_files.get(dir_path, []):
            if fpath in self.file_to_hash and self.file_to_hash[fpath] == fhash:
                return fpath.name

        # Fallback to original filename if not found
        return file_path.name

    def get_trash_dir_for_root(self, root_path):
        """Get the trash directory for a specific root."""
        return root_path / '~dedupdir-trash'

    def init_trash_dir_for_root(self, root_path):
        """Initialize trash directory for a specific root if it doesn't exist."""
        trash_dir = self.get_trash_dir_for_root(root_path)
        if not trash_dir.exists():
            trash_dir.mkdir(parents=True)
        return trash_dir

    def get_trash_items(self):
        """Scan trash directories in all roots and return list of items with metadata."""
        items = []

        for root_path in self.root_paths:
            trash_dir = self.get_trash_dir_for_root(root_path)
            if not trash_dir.exists():
                continue

            # Walk through all files/dirs in this trash dir
            for item in trash_dir.rglob('*'):
                if item.is_file() or (item.is_dir() and not any(item.iterdir())):
                    # It's a file or empty directory
                    rel_to_trash = item.relative_to(trash_dir)
                    original_path = root_path / rel_to_trash

                    items.append({
                        'original_path': str(original_path),
                        'trash_path': str(item),
                        'root_name': root_path.name,
                        'relative_path': str(rel_to_trash),
                        'type': 'file' if item.is_file() else 'directory',
                        'timestamp': datetime.fromtimestamp(item.stat().st_ctime).isoformat()
                    })

        # Sort by timestamp (newest first)
        items.sort(key=lambda x: x['timestamp'], reverse=True)
        return items

    def get_current_view(self):
        """Get the current view from the view stack."""
        return self.view_stack[-1] if self.view_stack else {'type': 'main'}

    def push_view(self, view):
        """Push a new view onto the stack."""
        # Save current selection state in the current view
        if self.view_stack:
            current = self.view_stack[-1]
            current['selected_idx'] = self.selected_idx
            current['scroll_offset'] = self.scroll_offset

        self.view_stack.append(view)
        self.selected_idx = 0
        self.scroll_offset = 0

    def pop_view(self):
        """Pop the current view and return to the previous one."""
        if len(self.view_stack) > 1:
            self.view_stack.pop()
            # Restore selection state from the previous view
            prev_view = self.view_stack[-1]
            self.selected_idx = prev_view.get('selected_idx', 0)
            self.scroll_offset = prev_view.get('scroll_offset', 0)
            return True
        return False

    def get_current_list_size(self):
        """Get the size of the current list being displayed."""
        view = self.get_current_view()
        if view['type'] == 'main':
            return len(self.build_display_list())
        elif view['type'] == 'dir_detail':
            dir_path = view['data']['dir_path']
            files = self.get_all_files_with_counts(dir_path)
            return len(files)
        elif view['type'] == 'file_detail':
            file_path = view['data']['file_path']
            return len(self.get_dirs_containing_file(file_path))
        return 0

    def get_current_visible_lines(self, usable_height):
        """Get the number of visible content lines for the current view.

        This accounts for view type and stack depth (overlay indentation).
        """
        view = self.get_current_view()
        level_idx = len(self.view_stack) - 1

        if view['type'] == 'main':
            # Main view: height - 3 for border/header, but navigation uses -5
            return usable_height - 5
        else:
            # Overlay views are indented by level_idx rows
            overlay_height = usable_height - level_idx
            # dir_detail and file_detail both use height - 5 for display_height
            return overlay_height - 5

    def get_current_stats(self):
        """Calculate current statistics: total files, duplicate files, and duplication percentage.

        Returns a tuple: (total_files, duplicate_files, duplication_percent)
        """
        # Count all unique files across all directories
        all_files = set()
        for dir_path, files in self.dir_all_files.items():
            all_files.update(files)

        total_files = len(all_files)

        if total_files == 0:
            return 0, 0, 0.0

        # Count duplicate files (files that exist in more than one directory)
        duplicate_files = 0
        for file_path in all_files:
            if file_path in self.file_to_hash:
                file_hash = self.file_to_hash[file_path]
                num_dirs = len(self.hash_to_dirs.get(file_hash, set()))
                if num_dirs > 1:
                    duplicate_files += 1

        # Calculate percentage - ensure we don't show 0% if there are duplicates
        if duplicate_files > 0:
            duplication_percent = (duplicate_files / total_files) * 100
            # If percentage rounds to 0 but there are duplicates, show at least 0.01%
            if duplication_percent < 0.01:
                duplication_percent = 0.01
        else:
            duplication_percent = 0.0

        return total_files, duplicate_files, duplication_percent

    def get_file_redundancy_count(self, file_path):
        """Get how many directories contain this file (based on hash)."""
        if file_path not in self.file_to_hash:
            return 0
        file_hash = self.file_to_hash[file_path]
        return len(self.hash_to_dirs.get(file_hash, set()))

    def is_dir_fully_redundant(self, dir_path):
        """Check if all files in directory exist in other directories."""
        files = self.dir_all_files.get(dir_path, [])
        if not files:
            return True

        num_roots = len(self.root_paths)
        for fpath in files:
            count = self.get_file_redundancy_count(fpath)
            if count < num_roots:
                return False
        return True

    def trash_item(self, item_path, item_type):
        """Move item to trash and update data structures."""
        item_path = Path(item_path)

        # Find which root this item belongs to
        root_for_item = None
        for root in self.root_paths:
            try:
                item_path.relative_to(root)
                root_for_item = root
                break
            except ValueError:
                continue

        if not root_for_item:
            return False

        # Initialize trash dir for this root
        trash_dir = self.init_trash_dir_for_root(root_for_item)

        # Create relative path from root
        rel_path = item_path.relative_to(root_for_item)

        # Create trash path (directly under trash dir, preserving structure)
        trash_path = trash_dir / rel_path
        trash_path.parent.mkdir(parents=True, exist_ok=True)

        # Move to trash
        try:
            shutil.move(str(item_path), str(trash_path))
        except Exception as e:
            return False

        # Add to undo stack (store simple tuple)
        self.trash_stack.append((str(item_path), str(trash_path), item_type == 'directory'))

        # Update data structures
        if item_type == 'file':
            self.remove_file_from_data(item_path)
        else:  # directory
            self.remove_directory_from_data(item_path)

        # Recalculate sorted_dirs with all directories
        self.recalculate_sorted_dirs()
        self.invalidate_relationship_cache()
        self.invalidate_size_cache()

        return True

    def remove_file_from_data(self, file_path):
        """Remove a file from internal data structures."""
        if file_path not in self.file_to_hash:
            return

        file_hash = self.file_to_hash[file_path]
        parent_dir = file_path.parent

        # Get all directories that will be affected by this trashing
        # (all directories that have files with this hash)
        affected_dirs = set()
        if file_hash in self.hash_to_dirs:
            affected_dirs = self.hash_to_dirs[file_hash].copy()

        # Remove file from dir_all_files
        if parent_dir in self.dir_all_files:
            if file_path in self.dir_all_files[parent_dir]:
                self.dir_all_files[parent_dir].remove(file_path)

        # Remove the directory from hash_to_dirs
        if file_hash in self.hash_to_dirs:
            self.hash_to_dirs[file_hash].discard(parent_dir)

            # If no more directories have this hash, remove it
            if not self.hash_to_dirs[file_hash]:
                del self.hash_to_dirs[file_hash]

        # Remove from file_to_hash
        del self.file_to_hash[file_path]

        # Recalculate stats for ALL affected directories
        # (not just the one we trashed from, but all that had this hash)
        for dir_path in affected_dirs:
            if dir_path in self.dir_stats or dir_path in self.dir_all_files:
                # Recalculate duplicates for this directory
                new_dup = 0
                for f in self.dir_all_files.get(dir_path, []):
                    if f in self.file_to_hash:
                        fh = self.file_to_hash[f]
                        if len(self.hash_to_dirs.get(fh, set())) > 1:
                            new_dup += 1
                new_total = len(self.dir_all_files.get(dir_path, []))

                # Update or remove from dir_stats
                if new_total > 0 and new_dup > 0:
                    self.dir_stats[dir_path] = (new_dup, new_total)
                elif dir_path in self.dir_stats:
                    del self.dir_stats[dir_path]

    def remove_directory_from_data(self, dir_path):
        """Remove a directory and all its files from internal data structures.

        Also removes any child directories that are inside the removed directory.
        """
        # Find all directories that are children of dir_path (including dir_path itself)
        dirs_to_remove = [dir_path]
        for other_dir in list(self.dir_all_files.keys()):
            if other_dir != dir_path and self.is_subdir(other_dir, dir_path):
                dirs_to_remove.append(other_dir)

        # Also check dir_stats for directories that might not be in dir_all_files
        for other_dir in list(self.dir_stats.keys()):
            if other_dir != dir_path and other_dir not in dirs_to_remove and self.is_subdir(other_dir, dir_path):
                dirs_to_remove.append(other_dir)

        # Remove each directory and its files
        for dir_to_remove in dirs_to_remove:
            # Get all files in this directory
            files_to_remove = self.dir_all_files.get(dir_to_remove, [])[:]

            # Remove each file
            for file_path in files_to_remove:
                self.remove_file_from_data(file_path)

            # Remove directory from dir_all_files and dir_stats
            if dir_to_remove in self.dir_all_files:
                del self.dir_all_files[dir_to_remove]
            if dir_to_remove in self.dir_stats:
                del self.dir_stats[dir_to_remove]

        # Clean up expanded_groups if the removed directory was expanded
        self.expanded_groups.discard(dir_path)

    def undo_last_trash(self):
        """Undo the most recent trash operation."""
        if not self.trash_stack:
            return False

        original_path_str, trash_path_str, is_dir = self.trash_stack.pop()
        trash_path = Path(trash_path_str)
        original_path = Path(original_path_str)

        # Move back from trash
        try:
            original_path.parent.mkdir(parents=True, exist_ok=True)
            shutil.move(str(trash_path), str(original_path))
        except Exception as e:
            # Put it back on stack if restore failed
            self.trash_stack.append((original_path_str, trash_path_str, is_dir))
            return False

        # Clean up empty directories in trash
        self.cleanup_empty_trash_dirs(trash_path.parent)

        # Rescan to update data structures
        self.scan(quiet=True)
        self.invalidate_relationship_cache()
        self.invalidate_size_cache()

        return True

    def restore_from_trash(self, trash_record):
        """Restore an item from trash by its metadata record."""
        trash_path = Path(trash_record['trash_path'])
        original_path = Path(trash_record['original_path'])

        if not trash_path.exists():
            return False

        try:
            original_path.parent.mkdir(parents=True, exist_ok=True)
            shutil.move(str(trash_path), str(original_path))
        except Exception as e:
            return False

        # Clean up empty directories in trash
        self.cleanup_empty_trash_dirs(trash_path.parent)

        # Remove from trash stack if present
        self.trash_stack = [d for d in self.trash_stack if d[1] != trash_record['trash_path']]

        # Rescan to update data structures
        self.scan(quiet=True)

        return True

    def cleanup_empty_trash_dirs(self, start_dir):
        """Remove empty directories in trash, walking up from start_dir."""
        if not start_dir.exists():
            return

        # Walk up from start_dir, removing empty directories
        current = start_dir
        while current.exists() and current.is_dir():
            # Check if this is a trash directory
            is_trash_root = any(current == self.get_trash_dir_for_root(root) for root in self.root_paths)
            if is_trash_root:
                break

            # Check if directory is empty
            try:
                if not any(current.iterdir()):
                    # Directory is empty, remove it
                    current.rmdir()
                    # Move up to parent
                    current = current.parent
                else:
                    # Directory not empty, stop
                    break
            except (OSError, PermissionError):
                # Can't remove or access, stop
                break

    def format_mtime(self, path):
        """Format modification time compactly."""
        try:
            mtime = path.stat().st_mtime
            dt = datetime.fromtimestamp(mtime)
            now = datetime.now()

            # If today, show time
            if dt.date() == now.date():
                return dt.strftime("%H:%M")
            # If this year, show month-day
            elif dt.year == now.year:
                return dt.strftime("%m-%d")
            # Otherwise show year
            else:
                return dt.strftime("%Y")
        except:
            return "-----"

    def needs_scroll_indicators(self, scroll_offset, total_items, visible_height):
        """Check if scroll indicators are needed.

        Returns (needs_top, needs_bottom) tuple.
        Indicators overlay content, so they don't reduce visible space.
        """
        if total_items <= visible_height:
            return False, False
        needs_top = scroll_offset > 0
        needs_bottom = scroll_offset + visible_height < total_items
        return needs_top, needs_bottom

    def draw_position_indicator(self, win, height, width, scroll_offset, total_items, visible_height):
        """Draw position indicator like '0% (1-18 of 23)' in bottom right."""
        if total_items <= 0:
            return

        # Indicators overlay content, so visible_height is the actual visible count
        if total_items <= visible_height:
            # All items visible
            status = f" 1-{total_items} of {total_items} "
        else:
            max_offset = total_items - visible_height
            # Clamp percent to 0-100 range
            percent = min(100, max(0, (scroll_offset / max_offset * 100))) if max_offset > 0 else 0
            first = scroll_offset + 1
            last = min(scroll_offset + visible_height, total_items)
            status = f" {percent:.0f}% ({first}-{last} of {total_items}) "

        try:
            win.addstr(height - 1, width - len(status) - 1, status, curses.A_DIM)
        except curses.error:
            pass

    def draw_scroll_indicators(self, win, height, width, scroll_offset, total_items, visible_height, content_start_y=1, show_position=True):
        """Draw scroll bar and more-content arrows.

        Args:
            win: curses window
            height: window height
            width: window width
            scroll_offset: current scroll position
            total_items: total number of items
            visible_height: number of visible lines for content
            content_start_y: y position where content starts (for top arrow)
        """
        needs_top, needs_bottom = self.needs_scroll_indicators(scroll_offset, total_items, visible_height)

        if not needs_top and not needs_bottom:
            return  # No scrolling needed

        # Draw up indicator on its own line if content above
        if needs_top:
            try:
                indicator = "    ▲▲▲ more ▲▲▲   "
                win.addstr(content_start_y, 1, indicator, curses.A_DIM)
            except curses.error:
                pass

        # Draw down indicator on its own line if content below
        if needs_bottom:
            try:
                indicator = "    ▼▼▼ more ▼▼▼   "
                win.addstr(height - 2, 1, indicator, curses.A_DIM)
            except curses.error:
                pass

        # Calculate scrollbar area (full content height, inclusive of last row before border)
        scrollbar_start_y = content_start_y
        scrollbar_end_y = height - 1  # exclusive end (height - 2 is last drawable row)
        scrollbar_height = scrollbar_end_y - scrollbar_start_y

        if scrollbar_height < 3:
            return  # Not enough room for scroll bar

        # Calculate thumb size and position
        visible_ratio = visible_height / total_items
        thumb_size = max(1, int(scrollbar_height * visible_ratio))

        scroll_range = total_items - visible_height
        if scroll_range > 0:
            scroll_ratio = scroll_offset / scroll_range
            thumb_pos = round((scrollbar_height - thumb_size) * scroll_ratio)
        else:
            thumb_pos = 0

        # Draw scroll bar track and thumb
        for i in range(scrollbar_height):
            y = scrollbar_start_y + i
            try:
                if i >= thumb_pos and i < thumb_pos + thumb_size:
                    win.addstr(y, width - 2, "█", curses.A_DIM)
                else:
                    win.addstr(y, width - 2, "│", curses.A_DIM)
            except curses.error:
                pass

        # Draw position indicator for non-help windows
        if show_position:
            self.draw_position_indicator(win, height, width, scroll_offset, total_items, visible_height)

    def draw_main_view(self, win, height, width, selected_idx, scroll_offset):
        """Draw the main directory list view."""
        win.clear()
        win.border()

        # Show statistics in upper right corner
        total_files, duplicate_files, duplication_percent = self.get_current_stats()
        if duplication_percent == 0.0:
            percent_str = "0%"
        elif duplication_percent < 0.01:
            percent_str = "<0.01%"
        elif duplication_percent < 1.0:
            percent_str = f"{duplication_percent:.2f}%"
        elif duplication_percent < 10.0:
            percent_str = f"{duplication_percent:.1f}%"
        else:
            percent_str = f"{duplication_percent:.0f}%"

        stats_text = f" {total_files} files | {duplicate_files} dupes | {percent_str} "
        stats_x = width - len(stats_text) - 1
        if stats_x > 2:
            try:
                win.addstr(0, stats_x, stats_text, curses.A_DIM)
            except curses.error:
                pass

        # Build display list with collapsible groups
        display_list = self.build_display_list()

        title = f" All Directories ({len(self.sorted_dirs)}) "
        try:
            win.addstr(0, 2, title[:width-4], curses.A_BOLD)
        except curses.error:
            pass

        # Show quit message if needed
        if self.show_quit_message:
            msg = " Press 'q' to quit "
            try:
                win.addstr(height - 1, width - len(msg) - 1, msg, curses.A_REVERSE | curses.A_BOLD)
            except curses.error:
                pass

        if not display_list:
            win.addstr(2, 1, "No directories to display")
            win.noutrefresh()
            return

        # Column headers with full-width underline
        header_line = 1
        try:
            # Draw full-width underline first
            win.addstr(header_line, 1, " " * (width - 2), curses.A_UNDERLINE)
            # Then draw headers on top
            win.addstr(header_line, 1, " %Dup", curses.A_BOLD | curses.A_UNDERLINE)
            win.addstr(header_line, 8, "#Dup", curses.A_BOLD | curses.A_UNDERLINE)
            win.addstr(header_line, 14, "Total", curses.A_BOLD | curses.A_UNDERLINE)
            win.addstr(header_line, 21, "Directory Path", curses.A_BOLD | curses.A_UNDERLINE)
            # Right-aligned headers
            if width > 60:
                right_header = "Size  MTime"
                win.addstr(header_line, width - len(right_header) - 2, right_header, curses.A_BOLD | curses.A_UNDERLINE)
        except curses.error:
            pass

        # Display items
        display_height = height - 3  # Account for border, header, and bottom border

        # Check if we need scroll indicators (they take up content lines)
        needs_top, needs_bottom = self.needs_scroll_indicators(scroll_offset, len(display_list), display_height)
        content_lines = display_height - (1 if needs_top else 0) - (1 if needs_bottom else 0)
        start_offset = 1 if needs_top else 0

        for i in range(content_lines):
            idx = scroll_offset + i
            if idx >= len(display_list):
                break

            item = display_list[idx]

            if item[0] == 'dir':
                # Regular directory entry
                _, dir_path, (duplicates, total), is_child = item
                score = calculate_redundancy_score(duplicates, total)
                path_str = self.get_path_with_root(dir_path)
                mtime_str = self.format_mtime(dir_path)
                dir_size = self.get_dir_size(dir_path)

                # Format size
                if dir_size < 1024:
                    size_str = f"{dir_size}B"
                elif dir_size < 1024 * 1024:
                    size_str = f"{dir_size/1024:.1f}K"
                elif dir_size < 1024 * 1024 * 1024:
                    size_str = f"{dir_size/(1024*1024):.1f}M"
                else:
                    size_str = f"{dir_size/(1024*1024*1024):.1f}G"

                # Format columns - stats always aligned, only path is indented
                percent_col = f"{score:6.1%}" if score > 0 else "   0% "
                dup_col = f"{duplicates:5d}"
                total_col = f"{total:5d}"

                # Left part: stats always aligned, path indented for children
                indent = "  " if is_child else ""
                left_part = f"{percent_col} {dup_col}  {total_col}  {indent}{path_str}"

                # Right part: size and mtime
                right_part = f"{size_str:>6s}  {mtime_str}"

                # Calculate available space
                max_len = width - 3
                right_len = len(right_part) + 2  # +2 for spacing

                if len(left_part) + right_len <= max_len:
                    # Enough space for both - pad middle with spaces
                    padding = max_len - len(left_part) - len(right_part)
                    line = left_part + " " * padding + right_part
                elif len(left_part) <= max_len:
                    # Not enough for right part, just show left (truncate if needed)
                    line = left_part[:max_len]
                else:
                    # Truncate left part
                    line = left_part[:max_len-3] + "..."

            elif item[0] == 'collapse':
                # Collapse line
                _, parent_path, child_dirs, total_files, total_dups, total_size = item
                num_dirs = len(child_dirs)
                is_expanded = parent_path in self.expanded_groups

                # Proper pluralization
                dir_word = "subdir" if num_dirs == 1 else "subdirs"
                file_word = "file" if total_files == 1 else "files"

                # Format size
                if total_size < 1024:
                    size_str = f"{total_size}B"
                elif total_size < 1024 * 1024:
                    size_str = f"{total_size/1024:.1f}K"
                elif total_size < 1024 * 1024 * 1024:
                    size_str = f"{total_size/(1024*1024):.1f}M"
                else:
                    size_str = f"{total_size/(1024*1024*1024):.1f}G"

                if is_expanded:
                    line = f"       ▼  {num_dirs} {dir_word}, {total_files} {file_word}, {size_str}"
                else:
                    line = f"       ▶  {num_dirs} {dir_word}, {total_files} {file_word}, {size_str}"

            # For collapse lines, truncate if too long
            if item[0] == 'collapse':
                max_len = width - 3
                if len(line) > max_len:
                    line = line[:max_len-3] + "..."

            y = i + 2 + start_offset  # Start after header (and top indicator if present)
            attr = curses.A_REVERSE if idx == selected_idx else curses.A_NORMAL
            try:
                win.addstr(y, 1, line.ljust(width - 4), attr)  # Leave room for scroll bar
            except curses.error:
                pass

        # Draw scroll indicators
        self.draw_scroll_indicators(win, height, width, scroll_offset, len(display_list), display_height, content_start_y=2)

        win.noutrefresh()

    def draw_dir_detail_view(self, win, height, width, view, selected_idx, scroll_offset):
        """Draw directory detail view showing only files in that directory."""
        dir_path = view['data']['dir_path']

        win.clear()
        win.border()

        title = f" {self.get_path_with_root(dir_path)}/ "
        try:
            win.addstr(0, 2, title[:width-4], curses.A_BOLD)
        except curses.error:
            pass

        # Get files in this directory
        files = self.get_all_files_with_counts(dir_path)

        # Headers
        try:
            win.addstr(2, 1, f"Files in Directory ({len(files)}):", curses.A_BOLD)
            win.addstr(3, 1, " Copies", curses.A_BOLD | curses.A_UNDERLINE)
            win.addstr(3, 10, "Filename", curses.A_BOLD | curses.A_UNDERLINE)
            # Right-aligned headers
            if width > 50:
                right_header = "Size  MTime"
                win.addstr(3, width - len(right_header) - 2, right_header, curses.A_BOLD | curses.A_UNDERLINE)
        except curses.error:
            pass

        if not files:
            try:
                win.addstr(4, 1, "  (No files)")
            except curses.error:
                pass
            win.noutrefresh()
            return

        # Display files
        display_height = height - 5  # Account for border, title, section header, column header

        # Draw files (indicators will overlay first/last lines)
        for i in range(display_height):
            idx = scroll_offset + i
            if idx >= len(files):
                break

            filename, count, file_path = files[idx]
            count_col = f"{count:5d}"

            # Get file size
            try:
                size_bytes = file_path.stat().st_size
                if size_bytes < 1024:
                    size_str = f"{size_bytes}B"
                elif size_bytes < 1024 * 1024:
                    size_str = f"{size_bytes/1024:.1f}K"
                elif size_bytes < 1024 * 1024 * 1024:
                    size_str = f"{size_bytes/(1024*1024):.1f}M"
                else:
                    size_str = f"{size_bytes/(1024*1024*1024):.1f}G"
            except:
                size_str = "---"

            mtime_str = self.format_mtime(file_path)

            # Left part: count and filename
            left_part = f"{count_col}  {filename}"

            # Right part: size and mtime
            right_part = f"{size_str:>6s}  {mtime_str}"

            # Calculate available space
            max_len = width - 3
            right_len = len(right_part) + 2  # +2 for spacing

            if len(left_part) + right_len <= max_len:
                # Enough space for both - pad middle with spaces
                padding = max_len - len(left_part) - len(right_part)
                line = left_part + " " * padding + right_part
            elif len(left_part) <= max_len:
                # Not enough for right part, just show left
                line = left_part[:max_len]
            else:
                # Truncate left part
                line = left_part[:max_len-3] + "..."

            y = i + 4  # Start after headers
            attr = curses.A_REVERSE if idx == selected_idx else curses.A_NORMAL
            try:
                win.addstr(y, 1, line.ljust(width - 4), attr)  # Leave room for scroll bar
            except curses.error:
                pass

        # Draw scroll indicators
        self.draw_scroll_indicators(win, height, width, scroll_offset, len(files), display_height, content_start_y=4)

        win.noutrefresh()

    def draw_file_detail_view(self, win, height, width, view, selected_idx, scroll_offset):
        """Draw file detail view showing all directories containing this file."""
        file_path = view['data']['file_path']

        win.clear()
        win.border()

        title = f" {self.get_path_with_root(file_path)} "
        try:
            win.addstr(0, 2, title[:width-4], curses.A_BOLD)
        except curses.error:
            pass

        # Get all directories containing this file
        dirs_with_file = self.get_dirs_containing_file(file_path)

        # Headers
        try:
            win.addstr(2, 1, f"Directories Containing This File ({len(dirs_with_file)}):", curses.A_BOLD)
            win.addstr(3, 1, " %Dup", curses.A_BOLD | curses.A_UNDERLINE)
            win.addstr(3, 8, "Dup", curses.A_BOLD | curses.A_UNDERLINE)
            win.addstr(3, 13, "Total", curses.A_BOLD | curses.A_UNDERLINE)
            win.addstr(3, 20, "MTime", curses.A_BOLD | curses.A_UNDERLINE)
            win.addstr(3, 28, "Directory Path", curses.A_BOLD | curses.A_UNDERLINE)
        except curses.error:
            pass

        # Display directories
        display_height = height - 5

        # Draw directories (indicators will overlay first/last lines)
        for i in range(display_height):
            idx = self.scroll_offset + i
            if idx >= len(dirs_with_file):
                break

            dir_path = dirs_with_file[idx]
            if dir_path in self.dir_stats:
                duplicates, total = self.dir_stats[dir_path]
            else:
                duplicates, total = 0, len(self.dir_all_files.get(dir_path, []))

            score = calculate_redundancy_score(duplicates, total)
            path_str = self.get_path_with_root(dir_path)
            mtime_str = self.format_mtime(dir_path)

            percent_col = f"{score:6.1%}" if score > 0 else "   0% "
            dup_col = f"{duplicates:4d}"
            total_col = f"{total:5d}"

            line = f"{percent_col} {dup_col}  {total_col}  {mtime_str}  {path_str}"
            max_len = width - 3
            if len(line) > max_len:
                line = line[:max_len-3] + "..."

            y = i + 4  # Start after headers
            attr = curses.A_REVERSE if idx == selected_idx else curses.A_NORMAL
            try:
                win.addstr(y, 1, line.ljust(width - 4), attr)  # Leave room for scroll bar
            except curses.error:
                pass

        # Draw scroll indicators
        self.draw_scroll_indicators(win, height, width, self.scroll_offset, len(dirs_with_file), display_height, content_start_y=4)

        win.noutrefresh()
    def draw_trash_pane(self, win, height, width):
        """Draw the trash viewer in full screen."""
        win.clear()
        win.border()

        title = " Trash (~dedupdir-trash) - 'r' restore, 'v' view, 't' toggle back, Esc exit "
        win.addstr(0, 2, title[:width-4], curses.A_BOLD | curses.A_REVERSE)

        # Show "no duplicates" message if applicable
        if self.show_no_duplicates_message:
            msg = "No duplicate files found. You can restore files from trash below, or press 'q' to quit."
            try:
                win.addstr(2, 2, msg[:width-4], curses.A_BOLD)
            except curses.error:
                pass

        items = self.get_trash_items()

        if not items:
            msg_y = 4 if self.show_no_duplicates_message else 2
            win.addstr(msg_y, 2, "Trash is empty", curses.A_DIM)
            if self.show_no_duplicates_message:
                win.addstr(msg_y + 2, 2, "Press 'q' to quit.", curses.A_DIM)
            win.noutrefresh()
            return

        # Display trash items
        start_y = 4 if self.show_no_duplicates_message else 1
        display_height = (height - start_y - 1) if self.show_no_duplicates_message else (height - 2)

        # Check if we need scroll indicators (they take up content lines)
        needs_top, needs_bottom = self.needs_scroll_indicators(self.trash_offset, len(items), display_height)
        content_lines = display_height - (1 if needs_top else 0) - (1 if needs_bottom else 0)
        indicator_offset = 1 if needs_top else 0

        for i in range(content_lines):
            idx = self.trash_offset + i
            if idx >= len(items):
                break

            item = items[idx]
            item_type = item.get('type', 'unknown')
            rel_path = item.get('relative_path', 'unknown')
            root_name = item.get('root_name', '')
            timestamp = item.get('timestamp', '')[:19]  # YYYY-MM-DDTHH:MM:SS

            # Format: [type] root/path with timestamp on right
            type_icon = "📄" if item_type == "file" else "📁"
            path_part = f"{type_icon} {root_name}/{rel_path}"

            # Format timestamp as "MMM DD HH:MM" (e.g., "Jan 20 14:23")
            # This is the ctime (inode change time), which approximates when the file was moved to trash
            if len(timestamp) >= 16:
                try:
                    dt = datetime.fromisoformat(timestamp)
                    time_part = dt.strftime("%b %d %H:%M")  # "Jan 20 14:23"
                except:
                    time_part = timestamp[5:16]  # Fallback: "MM-DD HH:MM"
            else:
                time_part = timestamp

            y = i + start_y + indicator_offset  # Account for top indicator if present
            attr = curses.A_REVERSE if idx == self.trash_selected_idx else curses.A_NORMAL

            try:
                # Calculate available space for path
                timestamp_width = len(time_part) + 2  # Add padding
                path_max_width = width - timestamp_width - 3

                # Truncate path if needed
                if len(path_part) > path_max_width:
                    path_part = path_part[:path_max_width-3] + "..."

                # Draw path on left
                win.addstr(y, 1, path_part, attr)

                # Draw timestamp on right
                time_x = width - timestamp_width - 1
                win.addstr(y, time_x, time_part, attr | curses.A_DIM)
            except curses.error:
                pass

        # Draw scroll indicators
        self.draw_scroll_indicators(win, height, width, self.trash_offset, len(items), display_height, content_start_y=start_y)

        win.noutrefresh()

    def get_file_type(self, file_path):
        """Detect file type: 'text', 'image', 'binary'."""
        try:
            # Check by extension first
            suffix = file_path.suffix.lower()

            # Image extensions
            image_exts = {'.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.tif', '.webp', '.ico', '.svg'}
            if suffix in image_exts:
                return 'image'

            # Read first chunk to detect text vs binary
            with open(file_path, 'rb') as f:
                chunk = f.read(8192)
                if not chunk:
                    return 'text'  # Empty file

                # Check for null bytes (strong indicator of binary)
                if b'\x00' in chunk:
                    return 'binary'

                # Try to decode as UTF-8
                try:
                    chunk.decode('utf-8')
                    return 'text'
                except UnicodeDecodeError:
                    return 'binary'
        except (IOError, OSError):
            return 'binary'

    def get_file_content_for_viewing(self, file_path):
        """Get file content/info for viewing. Returns (metadata_lines, content_lines, file_type)."""
        file_type = self.get_file_type(file_path)
        metadata_lines = []
        content_lines = []

        try:
            file_size = file_path.stat().st_size
            size_mb = file_size / (1024 * 1024)

            # Add header with file info (metadata)
            metadata_lines.append(f"File: {file_path.name}")
            metadata_lines.append(f"Path: {file_path}")
            metadata_lines.append(f"Size: {file_size:,} bytes ({size_mb:.2f} MB)")
            metadata_lines.append(f"Type: {file_type.upper()}")

            if file_type == 'image':
                # Try to get EXIF data or image info
                content_lines.append("")

                # Try exiftool first
                try:
                    import subprocess
                    result = subprocess.run(['exiftool', str(file_path)],
                                          capture_output=True, text=True, timeout=5)
                    if result.returncode == 0:
                        content_lines.extend(result.stdout.splitlines())
                    else:
                        raise Exception("exiftool failed")
                except:
                    # Try identify (ImageMagick)
                    try:
                        result = subprocess.run(['identify', '-verbose', str(file_path)],
                                              capture_output=True, text=True, timeout=5)
                        if result.returncode == 0:
                            content_lines.extend(result.stdout.splitlines())
                        else:
                            raise Exception("identify failed")
                    except:
                        # Just show basic info
                        content_lines.append("(No image tools available - install exiftool or ImageMagick for details)")
                        content_lines.append("")
                        content_lines.append("This is an image file. Use an image viewer to see it.")

            elif file_type == 'text':

                # Limit reading to 10MB for text files
                max_bytes = 10 * 1024 * 1024

                with open(file_path, 'r', encoding='utf-8', errors='replace') as f:
                    bytes_read = 0
                    for line_num, line in enumerate(f, 1):
                        if bytes_read >= max_bytes:
                            content_lines.append("")
                            content_lines.append(f"... (file truncated at {max_bytes:,} bytes, showing first ~{line_num} lines)")
                            break
                        content_lines.append(line.rstrip('\n\r'))
                        bytes_read += len(line.encode('utf-8'))

            else:  # binary

                # Show hex dump of first 4KB
                max_bytes = 4096
                with open(file_path, 'rb') as f:
                    data = f.read(max_bytes)

                # Create hex dump
                for i in range(0, len(data), 16):
                    chunk = data[i:i+16]
                    hex_part = ' '.join(f'{b:02x}' for b in chunk)
                    ascii_part = ''.join(chr(b) if 32 <= b < 127 else '.' for b in chunk)
                    content_lines.append(f'{i:08x}  {hex_part:<48}  {ascii_part}')

                if file_size > max_bytes:
                    content_lines.append("")
                    content_lines.append(f"... (showing first {max_bytes:,} of {file_size:,} bytes)")

        except Exception as e:
            content_lines.append(f"Error reading file: {e}")

        return metadata_lines, content_lines, file_type

    def draw_file_viewer(self, stdscr, file_path, metadata_lines, content_lines, scroll_offset):
        """Draw file viewer as centered overlay window (75% width, 85% height)."""
        term_height, term_width = stdscr.getmaxyx()

        # Create centered overlay window (75% width, 85% height)
        height = int(term_height * 0.85)
        width = int(term_width * 0.75)
        y = (term_height - height) // 2
        x = (term_width - width) // 2

        # Create window for file viewer
        viewer_win = curses.newwin(height, width, y, x)
        viewer_win.clear()
        viewer_win.border()

        # Title
        title = f" Viewing: {file_path.name} (q/ESC to close, arrows/j/k to scroll) "
        viewer_win.addstr(0, 2, title[:width-4], curses.A_BOLD | curses.A_REVERSE)

        # Draw metadata section (fixed, not scrollable, in dim color)
        metadata_height = len(metadata_lines)
        for i, line in enumerate(metadata_lines):
            display_line = line[:width-3]
            try:
                viewer_win.addstr(1 + i, 1, display_line, curses.A_DIM)
            except curses.error:
                pass

        # Draw separator line
        separator_y = 1 + metadata_height
        try:
            viewer_win.addstr(separator_y, 1, "─" * (width - 2))
        except curses.error:
            pass

        # Calculate visible area for content (below metadata and separator)
        content_start_y = separator_y + 1
        content_height = height - content_start_y - 1  # -1 for bottom border
        # When scrolled, top indicator takes one line, reducing content area by 1
        if len(content_lines) <= content_height:
            max_offset = 0
        else:
            max_offset = max(0, len(content_lines) - content_height + 1)
        scroll_offset = max(0, min(scroll_offset, max_offset))

        # Draw content lines (scrollable, indicators will overlay first/last lines)
        for i in range(content_height):
            line_idx = scroll_offset + i
            if line_idx < len(content_lines):
                line = content_lines[line_idx]
                # Truncate line to fit width (leave room for scroll bar)
                display_line = line[:width-5]
                try:
                    viewer_win.addstr(content_start_y + i, 1, display_line)
                except curses.error:
                    pass  # Ignore errors from writing to last position

        # Draw scroll indicators
        self.draw_scroll_indicators(viewer_win, height, width, scroll_offset, len(content_lines), content_height, content_start_y=content_start_y)

        viewer_win.noutrefresh()
        curses.doupdate()
        return scroll_offset, len(content_lines), max_offset

    def get_help_text(self, mode):
        """Get context-sensitive help text for the given mode."""
        if mode == 'main':
            return """Main View - Exploring Duplicate Files

Navigation:
  ↑/↓ or j/k        Navigate items
  ←/→ or h/l        Switch panes / navigate filtered view
  Tab               Switch between top and bottom pane
  Enter             Drill down into filtered view
  PgUp/PgDn         Page up/down
  Ctrl-B/Ctrl-F     Page up/down
  Home/End or </>   Jump to first/last item

Actions:
  v                 View selected file
  o                 Open selected file with system default application
  t                 Trash selected file or directory
  u                 Undo last trash operation
  T                 View trash
  q                 Quit

The top pane shows directories by redundancy.
The bottom pane shows files in selected directory.
Selecting a file filters the top pane to show only
directories containing that file."""

        elif mode == 'trash':
            return """Trash Viewer

Navigation:
  ↑/↓ or j/k        Navigate trash items
  PgUp/PgDn         Page up/down
  Ctrl-B/Ctrl-F     Page up/down
  Home/End or </>   Jump to first/last item

Actions:
  v                 View selected file
  o                 Open selected file with desktop viewer
  r                 Restore selected item
  t or Esc          Return to main view
  q                 Quit

Files are moved to ~dedupdir-trash/ in each root
directory. They remain there until you manually
delete the trash directories."""

        elif mode == 'viewer':
            return """File Viewer

Navigation:
  ↑/↓ or j/k        Scroll up/down one line
  PgUp/PgDn         Scroll up/down one page
  Ctrl-B/Ctrl-F     Page up/down (alternative)
  Home/End or </>   Jump to start/end

Display:
  - Metadata shown at top (file, path, size, type)
  - Horizontal line separates metadata from content
  - Text files: shows content (up to 10MB)
  - Images: shows EXIF data if available
  - Binary files: shows hex dump (first 4KB)

Actions:
  q or Esc          Close viewer and return"""

        elif mode == 'confirm':
            return """Trash Confirmation

You are about to trash an item that is not fully
redundant. If you trash it, you will lose data unless
you restore it from the trash.

Actions:
  y or Y            Confirm - move to trash
  n or N            Cancel
  Esc               Cancel
  q                 Quit application
"""
        else:
            return "Help not available for this mode."

    def draw_help_popup(self, stdscr, mode, scroll_offset=0):
        """Draw help popup as centered overlay with scrolling support."""
        term_height, term_width = stdscr.getmaxyx()

        # Help window size (80% width, 80% height)
        height = int(term_height * 0.80)
        width = int(term_width * 0.80)
        width = min(width, 80)  # Max 80 chars wide
        y = (term_height - height) // 2
        x = (term_width - width) // 2

        # Create help window
        help_win = curses.newwin(height, width, y, x)
        help_win.clear()
        help_win.border()

        # Title
        title = " Help - h/←/Esc to close, ↑↓/j/k to scroll "
        help_win.addstr(0, (width - len(title)) // 2, title[:width-2], curses.A_BOLD | curses.A_REVERSE)

        # Get help text and display
        help_text = self.get_help_text(mode)
        lines = help_text.split('\n')

        # Calculate visible area and scroll bounds
        visible_height = height - 2
        # When scrolled, top indicator takes one line, so we can show one less content line
        # max_offset is the scroll position where the last line is visible
        if len(lines) <= visible_height:
            max_offset = 0
        else:
            # Once scrolled, top indicator appears, reducing content area by 1
            max_offset = max(0, len(lines) - visible_height + 1)
        scroll_offset = max(0, min(scroll_offset, max_offset))

        # Draw help lines with scrolling (indicators will overlay first/last lines)
        for i in range(visible_height):
            line_idx = scroll_offset + i
            if line_idx < len(lines):
                display_line = lines[line_idx][:width-5]  # Leave room for scroll bar
                try:
                    help_win.addstr(1 + i, 1, display_line)
                except curses.error:
                    pass

        # Draw scroll indicators
        self.draw_scroll_indicators(help_win, height, width, scroll_offset, len(lines), visible_height, content_start_y=1, show_position=True)

        help_win.noutrefresh()
        curses.doupdate()
        return scroll_offset, len(lines)

    def show_help_viewer(self, stdscr, mode):
        """Show scrollable help viewer and handle navigation until exit."""
        scroll_offset = 0
        while True:
            scroll_offset, total_lines = self.draw_help_popup(stdscr, mode, scroll_offset)
            help_key = stdscr.getch()

            if help_key in (ord('h'), ord('H'), curses.KEY_LEFT, 27):  # h, H, ←, or ESC
                break
            elif help_key == curses.KEY_RESIZE:
                stdscr.clear()
                stdscr.refresh()
                continue
            elif help_key in (curses.KEY_UP, ord('k')):
                scroll_offset = max(0, scroll_offset - 1)
            elif help_key in (curses.KEY_DOWN, ord('j')):
                help_height = int(stdscr.getmaxyx()[0] * 0.80)
                visible_height = help_height - 2
                max_offset = max(0, total_lines - visible_height + 1) if total_lines > visible_height else 0
                scroll_offset = min(max_offset, scroll_offset + 1)
            elif help_key in (curses.KEY_PPAGE, 2):  # Page Up or Ctrl-B
                help_height = int(stdscr.getmaxyx()[0] * 0.80)
                visible_height = help_height - 2
                scroll_offset = max(0, scroll_offset - visible_height)
            elif help_key in (curses.KEY_NPAGE, 6):  # Page Down or Ctrl-F
                help_height = int(stdscr.getmaxyx()[0] * 0.80)
                visible_height = help_height - 2
                max_offset = max(0, total_lines - visible_height + 1) if total_lines > visible_height else 0
                scroll_offset = min(max_offset, scroll_offset + visible_height)
            elif help_key in (curses.KEY_HOME, ord('<')):
                scroll_offset = 0
            elif help_key in (curses.KEY_END, ord('>')):
                help_height = int(stdscr.getmaxyx()[0] * 0.80)
                visible_height = help_height - 2
                scroll_offset = max(0, total_lines - visible_height + 1) if total_lines > visible_height else 0

    def open_file_with_system_app(self, file_path):
        """Open file with system's default application (cross-platform)."""
        try:
            import subprocess
            import platform
            system = platform.system()
            if system == 'Darwin':  # macOS
                subprocess.Popen(['open', str(file_path)])
            elif system == 'Windows':
                subprocess.Popen(['start', str(file_path)], shell=True)
            else:  # Linux and others
                subprocess.Popen(['xdg-open', str(file_path)])
        except Exception:
            pass  # Silently fail if can't open

    def get_hint_text(self, mode):
        """Get hint bar text for the given mode."""
        if mode == 'main':
            return "↑↓:Navigate  Enter:Drill Down  o:Open  t:Trash  T:View Trash  q:Quit"
        elif mode == 'dir_detail':
            return "↑↓:Navigate  Enter:Drill Down  v:View  o:Open  t:Trash  Esc:Back"
        elif mode == 'file_detail':
            return "↑↓:Navigate  Enter:Drill Down  v:View  o:Open  t:Trash  Esc:Back"
        elif mode == 'trash':
            return "↑↓:Navigate  v:View  o:Open  r:Restore  T:Back"
        elif mode == 'viewer':
            return "↑↓:Scroll  PgUp/PgDn:Page  q:Close"
        elif mode == 'confirm':
            return "y:Yes  n:No  Esc:Cancel"
        else:
            return ""

    def draw_hint_bar(self, stdscr, mode):
        """Draw hint bar at bottom of screen."""
        height, width = stdscr.getmaxyx()

        hint_text = self.get_hint_text(mode)
        help_text = "[?] Help"

        # Add verification status if running
        verify_text = ""
        if self.cached_hashes and not self.verification_complete and not self.verification_error:
            verified, total = self.verification_progress
            if total > 0:
                percent = (verified * 100) // total
                verify_text = f" [Verifying: {percent}%]"

        # Calculate positions
        available_width = width - len(help_text) - len(verify_text) - 4  # -4 for spacing
        if len(hint_text) > available_width:
            hint_text = hint_text[:available_width-3] + "..."

        # Draw hint bar
        try:
            # Clear the line first with normal color, then draw text
            stdscr.addstr(height - 1, 0, " " * (width - 1))
            # Draw hints on left
            stdscr.addstr(height - 1, 1, hint_text, curses.A_DIM)
            # Draw verification status in middle (if present)
            if verify_text:
                verify_x = 1 + len(hint_text) + 1
                stdscr.addstr(height - 1, verify_x, verify_text, curses.A_DIM)
            # Draw help on right
            stdscr.addstr(height - 1, width - len(help_text) - 1, help_text, curses.A_DIM)
            stdscr.noutrefresh()
        except curses.error:
            pass  # Ignore errors at edge of screen

    def show_verification_error(self, stdscr, error_message):
        """Display a fatal verification error and wait for user to acknowledge."""
        while True:
            height, width = stdscr.getmaxyx()
            stdscr.clear()

            # Draw error box
            box_width = min(70, width - 4)
            lines = []
            for line in error_message.split('\n'):
                # Word wrap long lines
                while len(line) > box_width - 4:
                    lines.append(line[:box_width - 4])
                    line = line[box_width - 4:]
                lines.append(line)

            box_height = len(lines) + 6  # Title, blank, lines, blank, instruction, border
            box_y = (height - box_height) // 2
            box_x = (width - box_width) // 2

            # Create dialog window
            try:
                dialog_win = curses.newwin(box_height, box_width, box_y, box_x)
                dialog_win.clear()
                dialog_win.border()

                # Title
                title = " CACHE VERIFICATION FAILED "
                dialog_win.addstr(0, (box_width - len(title)) // 2, title, curses.A_BOLD | curses.A_REVERSE)

                # Error message
                for i, line in enumerate(lines):
                    try:
                        dialog_win.addstr(2 + i, 2, line[:box_width - 4])
                    except curses.error:
                        pass

                # Instruction
                instruction = "Press any key to exit"
                dialog_win.addstr(box_height - 2, (box_width - len(instruction)) // 2, instruction, curses.A_DIM)

                dialog_win.refresh()
            except curses.error:
                pass

            # Wait for key
            key = stdscr.getch()
            if key == curses.KEY_RESIZE:
                stdscr.clear()
                stdscr.refresh()
                continue
            else:
                break

    def draw_confirmation_dialog(self, stdscr, message, prompt="Confirm? (y/n)"):
        """Draw a confirmation dialog in the center of the screen."""
        height, width = stdscr.getmaxyx()

        # Dialog dimensions
        dialog_height = 9
        dialog_width = min(70, width - 4)
        dialog_y = (height - dialog_height) // 2
        dialog_x = (width - dialog_width) // 2

        # Create dialog window
        dialog = curses.newwin(dialog_height, dialog_width, dialog_y, dialog_x)
        dialog.clear()
        dialog.box()

        # Split message by newlines first, then word wrap each line
        lines = []
        for msg_line in message.split('\n'):
            if not msg_line:
                lines.append("")
            else:
                words = msg_line.split()
                current_line = ""
                for word in words:
                    if len(current_line) + len(word) + 1 <= dialog_width - 4:
                        current_line += (" " if current_line else "") + word
                    else:
                        lines.append(current_line)
                        current_line = word
                if current_line:
                    lines.append(current_line)

        # Draw message lines
        for i, line in enumerate(lines[:5]):  # Max 5 lines
            dialog.addstr(1 + i, 2, line, curses.A_BOLD)

        # Draw prompt
        dialog.addstr(dialog_height - 2, (dialog_width - len(prompt)) // 2, prompt, curses.A_REVERSE)

        dialog.noutrefresh()
        return dialog

    def handle_enter_key(self, view):
        """Handle Enter key - drill down into directories or files."""
        if view['type'] == 'main':
            # Get the display list to find what's selected
            display_list = self.build_display_list()
            if self.selected_idx < len(display_list):
                item = display_list[self.selected_idx]

                if item[0] == 'dir':
                    # Drilling into a directory
                    _, dir_path, _, _ = item
                    self.push_view({'type': 'dir_detail', 'data': {'dir_path': dir_path}})

                elif item[0] == 'collapse':
                    # Toggle collapse/expand
                    _, parent_path, _, _, _, _ = item
                    if parent_path in self.expanded_groups:
                        self.expanded_groups.discard(parent_path)
                    else:
                        self.expanded_groups.add(parent_path)
                    self.invalidate_display_cache()

        elif view['type'] == 'dir_detail':
            # Drilling into a file from directory view
            dir_path = view['data']['dir_path']
            files = self.get_all_files_with_counts(dir_path)

            if self.selected_idx < len(files):
                filename, _, file_path = files[self.selected_idx]
                self.push_view({'type': 'file_detail', 'data': {'file_path': file_path}})

        elif view['type'] == 'file_detail':
            # Drilling into a directory from file detail view
            file_path = view['data']['file_path']
            dirs_with_file = self.get_dirs_containing_file(file_path)
            if self.selected_idx < len(dirs_with_file):
                dir_path = dirs_with_file[self.selected_idx]
                self.push_view({'type': 'dir_detail', 'data': {'dir_path': dir_path}})

    def clamp_selection_after_trash(self):
        """Ensure selected_idx is still valid after an item was trashed.

        The selection should stay at the same index (so the next item becomes selected),
        unless we deleted the last item, in which case we need to move up.
        """
        list_size = self.get_current_list_size()
        if list_size == 0:
            self.selected_idx = 0
        elif self.selected_idx >= list_size:
            self.selected_idx = list_size - 1

    def handle_trash_key(self, view):
        """Handle 't' key - trash selected item."""
        item_to_trash = None
        trash_type = None

        if view['type'] == 'main':
            # Get the display list to find what's selected
            display_list = self.build_display_list()
            if self.selected_idx < len(display_list):
                item = display_list[self.selected_idx]
                if item[0] == 'dir':
                    _, dir_path, _, _ = item
                    item_to_trash = dir_path
                    trash_type = 'directory'
                # Can't trash a collapse line

        elif view['type'] == 'dir_detail':
            # Trashing a file from directory view
            dir_path = view['data']['dir_path']
            files = self.get_all_files_with_counts(dir_path)

            if self.selected_idx < len(files):
                _, _, file_path = files[self.selected_idx]
                item_to_trash = file_path
                trash_type = 'file'

        elif view['type'] == 'file_detail':
            # Trashing a directory from file detail view
            file_path = view['data']['file_path']
            dirs_with_file = self.get_dirs_containing_file(file_path)
            if self.selected_idx < len(dirs_with_file):
                dir_path = dirs_with_file[self.selected_idx]
                item_to_trash = dir_path
                trash_type = 'directory'

        if item_to_trash:
            # Check if confirmation needed
            needs_confirmation = False
            num_roots = len(self.root_paths)

            if trash_type == 'file':
                count = self.get_file_redundancy_count(item_to_trash)
                if count < num_roots:
                    needs_confirmation = True
            else:  # directory
                if not self.is_dir_fully_redundant(item_to_trash):
                    needs_confirmation = True

            if needs_confirmation:
                self.confirm_trash_item = item_to_trash
                self.confirm_trash_type = trash_type
            else:
                # Trash immediately
                self.trash_item(item_to_trash, trash_type)
                self.clamp_selection_after_trash()

    def handle_view_key(self, view, stdscr, height, width):
        """Handle 'v' key - view file content."""
        file_path = None

        if view['type'] == 'dir_detail':
            # Open file from directory view
            dir_path = view['data']['dir_path']
            files = self.get_all_files_with_counts(dir_path)

            if self.selected_idx < len(files):
                _, _, file_path = files[self.selected_idx]

        elif view['type'] == 'file_detail':
            # View the file itself
            file_path = view['data']['file_path']

        if file_path and file_path.is_file():
            # Get file content once before entering viewer loop
            metadata_lines, content_lines, file_type = self.get_file_content_for_viewing(file_path)

            # Enter file viewing mode
            scroll_offset = 0
            while True:
                # Get current terminal dimensions
                height, width = stdscr.getmaxyx()

                # Redraw current view as background
                usable_height = height - 1
                main_win = curses.newwin(usable_height, width, 0, 0)
                if view['type'] == 'main':
                    self.draw_main_view(main_win, usable_height, width)
                elif view['type'] == 'dir_detail':
                    self.draw_dir_detail_view(main_win, usable_height, width)
                elif view['type'] == 'file_detail':
                    self.draw_file_detail_view(main_win, usable_height, width)

                # Draw file viewer overlay on top
                scroll_offset, total_lines, max_offset = self.draw_file_viewer(stdscr, file_path, metadata_lines, content_lines, scroll_offset)

                # Draw hint bar
                self.draw_hint_bar(stdscr, 'viewer')

                # Handle viewer input
                view_key = stdscr.getch()

                if view_key in (ord('q'), ord('Q'), 27):  # q, Q, or ESC
                    break
                elif view_key == curses.KEY_RESIZE:
                    stdscr.clear()
                    stdscr.refresh()
                    continue
                elif view_key == ord('?'):
                    self.show_help_viewer(stdscr, 'viewer')
                    continue
                elif view_key in (curses.KEY_UP, ord('k')):
                    scroll_offset = max(0, scroll_offset - 1)
                elif view_key in (curses.KEY_DOWN, ord('j')):
                    scroll_offset = min(max_offset, scroll_offset + 1)
                elif view_key in (curses.KEY_PPAGE, curses.KEY_NPAGE, 2, 6):  # PgUp/PgDn or Ctrl-B/Ctrl-F
                    # Use a page size that accounts for metadata area
                    viewer_height = int(height * 0.85)
                    page_size = max(1, viewer_height - 8)  # Approximate content area
                    if view_key in (curses.KEY_PPAGE, 2):  # Page Up or Ctrl-B
                        scroll_offset = max(0, scroll_offset - page_size)
                    else:  # Page Down or Ctrl-F
                        scroll_offset = min(max_offset, scroll_offset + page_size)
                elif view_key in (curses.KEY_HOME, ord('<')):
                    scroll_offset = 0
                elif view_key in (curses.KEY_END, ord('>')):
                    scroll_offset = max_offset

    def handle_open_key(self, view):
        """Handle 'o' key - open file or directory with system default application."""
        path_to_open = None

        if view['type'] == 'main':
            # Open directory from main view
            display_list = self.build_display_list()
            if self.selected_idx < len(display_list):
                item = display_list[self.selected_idx]
                if item[0] == 'dir':
                    _, dir_path, _, _ = item
                    path_to_open = dir_path

        elif view['type'] == 'dir_detail':
            # Open file from directory view
            dir_path = view['data']['dir_path']
            files = self.get_all_files_with_counts(dir_path)

            if self.selected_idx < len(files):
                _, _, file_path = files[self.selected_idx]
                path_to_open = file_path

        elif view['type'] == 'file_detail':
            # Open directory from file detail view
            file_path = view['data']['file_path']
            dirs_with_file = self.get_dirs_containing_file(file_path)
            if self.selected_idx < len(dirs_with_file):
                path_to_open = dirs_with_file[self.selected_idx]

        if path_to_open and path_to_open.exists():
            self.open_file_with_system_app(path_to_open)

    def draw_all_panes(self, usable_height, width, do_update=True):
        """Draw all panes in the view stack with proper indentation and frozen selections.

        Args:
            usable_height: Available height for drawing
            width: Available width for drawing
            do_update: If True, call curses.doupdate() after drawing (default True)
        """
        # First, draw the main view (always at bottom) with its saved selection
        main_win = curses.newwin(usable_height, width, 0, 0)
        main_view = self.view_stack[0]
        if len(self.view_stack) == 1:
            # Main view is current - use live selection
            main_selected = self.selected_idx
            main_scroll = self.scroll_offset
        else:
            # Main view is background - use frozen selection
            main_selected = main_view.get('selected_idx', 0)
            main_scroll = main_view.get('scroll_offset', 0)
        self.draw_main_view(main_win, usable_height, width, main_selected, main_scroll)

        # Then draw each overlay in the stack (skip index 0 which is always 'main')
        for level_idx in range(1, len(self.view_stack)):
            level_view = self.view_stack[level_idx]

            # Each level is indented 4 columns and 1 row from the previous
            indent_x = level_idx * 4
            indent_y = level_idx * 1

            # Calculate overlay size (descend 1 row but extend to bottom)
            overlay_height = usable_height - indent_y
            overlay_width = width - indent_x

            # Make sure we have room
            if overlay_height < 10 or overlay_width < 40:
                break

            # Determine if this is the current view or a background view
            is_current_view = (level_idx == len(self.view_stack) - 1)

            # For background views, use their saved selection; for current view, use live selection
            if is_current_view:
                # Current view - use live selection (responds to arrow keys)
                draw_selected_idx = self.selected_idx
                draw_scroll_offset = self.scroll_offset
            else:
                # Background view - use frozen saved selection
                draw_selected_idx = level_view.get('selected_idx', 0)
                draw_scroll_offset = level_view.get('scroll_offset', 0)

            # Draw the overlay with the appropriate selection
            overlay_win = curses.newwin(overlay_height, overlay_width, indent_y, indent_x)
            if level_view['type'] == 'dir_detail':
                self.draw_dir_detail_view(overlay_win, overlay_height, overlay_width, level_view, draw_selected_idx, draw_scroll_offset)
            elif level_view['type'] == 'file_detail':
                self.draw_file_detail_view(overlay_win, overlay_height, overlay_width, level_view, draw_selected_idx, draw_scroll_offset)

        if do_update:
            curses.doupdate()

    def run(self, stdscr):
        """Main TUI loop."""
        curses.curs_set(0)  # Hide cursor
        stdscr.clear()

        # Set escape delay to 25ms to make ESC key responsive
        if hasattr(curses, 'set_escdelay'):
            curses.set_escdelay(25)

        # Initialize colors if available
        if curses.has_colors():
            curses.init_pair(1, curses.COLOR_WHITE, curses.COLOR_BLUE)

        # Show loading message
        height, width = stdscr.getmaxyx()
        stdscr.addstr(height // 2, width // 2 - 10, "Starting TUI...", curses.A_BOLD)
        stdscr.refresh()

        if not self.sorted_dirs:
            # No duplicates found - show trash viewer
            self.viewing_trash = True
            self.trash_selected_idx = 0
            self.trash_offset = 0
            self.show_no_duplicates_message = True
        else:
            self.show_no_duplicates_message = False

        # Main loop
        while True:
            # Set timeout for getch() - use 500ms during verification for progress updates
            if self.cached_hashes and not self.verification_complete and not self.verification_error:
                stdscr.timeout(500)  # 500ms timeout during verification
            else:
                stdscr.timeout(-1)  # Blocking mode when verification complete

            # Check for background verification errors
            verification_error = self.check_verification_status()
            if verification_error:
                # Show fatal error and exit
                self.show_verification_error(stdscr, verification_error)
                return  # Exit the TUI

            height, width = stdscr.getmaxyx()
            usable_height = height - 1  # Reserve last line for hint bar

            # Handle different display modes
            if self.viewing_trash:
                # Draw trash viewer overlay
                view = self.get_current_view()
                if view['type'] == 'main':
                    main_win = curses.newwin(usable_height, width, 0, 0)
                    self.draw_main_view(main_win, usable_height, width, self.selected_idx, self.scroll_offset)

                # Draw trash viewer as centered overlay (85% width, 92% height)
                trash_height = int(usable_height * 0.92)
                trash_width = int(width * 0.85)
                trash_y = (usable_height - trash_height) // 2
                trash_x = (width - trash_width) // 2
                trash_win = curses.newwin(trash_height, trash_width, trash_y, trash_x)
                self.draw_trash_pane(trash_win, trash_height, trash_width)
                self.draw_hint_bar(stdscr, 'trash')
                curses.doupdate()

            elif self.confirm_quit:
                # Draw quit confirmation dialog
                self.draw_all_panes(usable_height, width, do_update=False)
                message = "You have drilled down into the directory tree.\n\nAre you sure you want to quit?"
                self.draw_confirmation_dialog(stdscr, message, "Quit? (y/n)")
                self.draw_hint_bar(stdscr, 'confirm')
                curses.doupdate()

            elif self.confirm_trash_item is not None:
                # Draw confirmation dialog - draw all panes then overlay the dialog
                self.draw_all_panes(usable_height, width, do_update=False)

                # Draw confirmation dialog on top of all panes
                rel_path = self.get_path_with_root(self.confirm_trash_item)
                message = f"There is only one copy of\n\n{rel_path}\n\nIf you trash it, you will lose data."
                self.draw_confirmation_dialog(stdscr, message, "Trash anyway? (y/n)")
                self.draw_hint_bar(stdscr, 'confirm')
                curses.doupdate()

            else:
                # Normal view - draw all panes in the stack
                self.draw_all_panes(usable_height, width, do_update=False)

                view = self.get_current_view()
                self.draw_hint_bar(stdscr, view['type'])
                curses.doupdate()

            # Handle input
            key = stdscr.getch()

            # Handle timeout (no key pressed) - just redraw to update verification progress
            if key == -1:
                continue

            # Handle terminal resize
            if key == curses.KEY_RESIZE:
                stdscr.clear()
                stdscr.refresh()
                continue

            # Handle quit confirmation first (takes priority)
            if self.confirm_quit:
                if key in (ord('y'), ord('Y')):
                    break
                elif key in (ord('n'), ord('N'), 27):  # n, N, or ESC
                    self.confirm_quit = False
                    continue
                elif key == ord('?'):
                    self.show_help_viewer(stdscr, 'confirm')
                    continue
                else:
                    continue

            # Handle trash confirmation dialog
            if self.confirm_trash_item is not None:
                if key in (ord('q'), ord('Q')):
                    break
                if key in (ord('y'), ord('Y')):
                    item_path, item_type = self.confirm_trash_item, self.confirm_trash_type
                    self.trash_item(item_path, item_type)
                    self.clamp_selection_after_trash()
                    self.confirm_trash_item = None
                    self.confirm_trash_type = None
                    continue
                elif key in (ord('n'), ord('N'), 27):  # n, N, or ESC
                    self.confirm_trash_item = None
                    self.confirm_trash_type = None
                    continue
                elif key == ord('?'):
                    self.show_help_viewer(stdscr, 'confirm')
                    continue
                else:
                    continue

            # Handle trash viewing mode
            if self.viewing_trash:
                if key in (ord('q'), ord('Q')):
                    break
                elif key in (ord('T'),):
                    if not self.show_no_duplicates_message:
                        self.viewing_trash = False
                    continue
                elif key == 27:  # ESC
                    if not self.show_no_duplicates_message:
                        self.viewing_trash = False
                    continue
                elif key == ord('?'):
                    self.show_help_viewer(stdscr, 'trash')
                    continue
                elif key in (ord('o'), ord('O')):
                    items = self.get_trash_items()
                    if items and self.trash_selected_idx < len(items):
                        item_dict = items[self.trash_selected_idx]
                        trash_path = Path(item_dict['trash_path'])
                        if trash_path.is_file():
                            self.open_file_with_system_app(trash_path)
                    continue
                elif key in (curses.KEY_UP, ord('k')):
                    items = self.get_trash_items()
                    if self.trash_selected_idx > 0:
                        self.trash_selected_idx -= 1
                        if self.trash_selected_idx < self.trash_offset:
                            self.trash_offset = self.trash_selected_idx
                elif key in (curses.KEY_DOWN, ord('j')):
                    items = self.get_trash_items()
                    if self.trash_selected_idx < len(items) - 1:
                        self.trash_selected_idx += 1
                        if self.trash_selected_idx >= self.trash_offset + (height - 2):
                            self.trash_offset = self.trash_selected_idx - (height - 2) + 1
                elif key in (ord('r'), ord('R')):
                    items = self.get_trash_items()
                    if items and self.trash_selected_idx < len(items):
                        if self.restore_from_trash(items[self.trash_selected_idx]):
                            items = self.get_trash_items()
                            if self.trash_selected_idx >= len(items) and len(items) > 0:
                                self.trash_selected_idx = len(items) - 1
                            if self.show_no_duplicates_message and self.sorted_dirs:
                                self.show_no_duplicates_message = False
                                self.viewing_trash = False
                continue

            # Normal navigation and actions
            view = self.get_current_view()
            list_size = self.get_current_list_size()

            # Q key - quit (with confirmation if not at top level)
            if key in (ord('q'), ord('Q')):
                if len(self.view_stack) > 1:
                    self.confirm_quit = True
                else:
                    break

            # ESC / Left arrow / h - go back (or collapse if on expanded collapse line)
            elif key in (27, curses.KEY_LEFT, ord('h')):
                # Check if we're on an expanded collapse line in main view
                if view['type'] == 'main':
                    display_list = self.build_display_list()
                    if self.selected_idx < len(display_list):
                        item = display_list[self.selected_idx]
                        if item[0] == 'collapse':
                            _, parent_path, _, _, _, _ = item
                            if parent_path in self.expanded_groups:
                                # Collapse the group instead of going back
                                self.expanded_groups.discard(parent_path)
                                self.invalidate_display_cache()
                                continue

                if not self.pop_view():
                    self.show_quit_message = True
                continue

            # ? key - help
            elif key == ord('?'):
                self.show_help_viewer(stdscr, view['type'])
                continue

            # T key - view trash
            elif key in (ord('T'),):
                if not self.viewing_trash:
                    self.viewing_trash = True
                    self.trash_selected_idx = 0
                    self.trash_offset = 0
                continue

            # U key - undo last trash
            elif key in (ord('u'), ord('U')):
                self.undo_last_trash()
                continue

            # Navigation keys
            elif key in (curses.KEY_UP, ord('k')):
                if self.selected_idx > 0:
                    self.selected_idx -= 1
                    # If selection went off screen (above), scroll to show it
                    if self.selected_idx < self.scroll_offset:
                        self.scroll_offset = self.selected_idx
                    # If selection is on first line and there's a top indicator, scroll early
                    elif self.selected_idx == self.scroll_offset and self.scroll_offset > 0:
                        self.scroll_offset -= 1
            elif key in (curses.KEY_DOWN, ord('j')):
                if self.selected_idx < list_size - 1:
                    self.selected_idx += 1
                    visible_lines = self.get_current_visible_lines(usable_height)
                    last_visible_idx = self.scroll_offset + visible_lines - 1
                    more_below = self.scroll_offset + visible_lines < list_size
                    # If selection went off screen, scroll to show it
                    if self.selected_idx > last_visible_idx:
                        self.scroll_offset = self.selected_idx - visible_lines + 1
                    # If selection is on last line and there's a bottom indicator, scroll early
                    elif self.selected_idx == last_visible_idx and more_below:
                        self.scroll_offset += 1
            elif key in (curses.KEY_PPAGE, 2):  # Page Up / Ctrl-B
                visible_lines = self.get_current_visible_lines(usable_height)
                self.selected_idx = max(0, self.selected_idx - visible_lines)
                self.scroll_offset = max(0, self.scroll_offset - visible_lines)
            elif key in (curses.KEY_NPAGE, 6):  # Page Down / Ctrl-F
                visible_lines = self.get_current_visible_lines(usable_height)
                self.selected_idx = min(list_size - 1, self.selected_idx + visible_lines)
                self.scroll_offset = min(self.scroll_offset + visible_lines, max(0, list_size - visible_lines))
            elif key in (curses.KEY_HOME, ord('g')):
                self.selected_idx = 0
                self.scroll_offset = 0
            elif key in (curses.KEY_END, ord('G')):
                self.selected_idx = list_size - 1
                visible_lines = self.get_current_visible_lines(usable_height)
                self.scroll_offset = max(0, list_size - visible_lines)

            # Enter / Right arrow / l key - drill down or expand collapse
            elif key in (curses.KEY_ENTER, ord('\n'), ord('\r'), curses.KEY_RIGHT, ord('l')):
                self.handle_enter_key(view)
                continue

            # 't' key - trash item
            elif key == ord('t'):
                self.handle_trash_key(view)
                continue

            # 'v' key - view file
            elif key in (ord('v'), ord('V')):
                self.handle_view_key(view, stdscr, height, width)
                continue

            # 'o' key - open file
            elif key in (ord('o'), ord('O')):
                self.handle_open_key(view)
                continue

def main():
    import argparse

    parser = argparse.ArgumentParser(
        prog='dedupdir-tui',
        description='Interactive TUI for exploring redundant directories.'
    )
    parser.add_argument(
        'directories',
        nargs='*',
        default=['.'],
        metavar='directory',
        help='Directories to scan (default: current directory)'
    )
    parser.add_argument(
        '-a', '--algorithm',
        default='blake2b',
        choices=['md5', 'sha1', 'sha256', 'blake2b', 'blake2s'],
        help='Hash algorithm to use (default: blake2b)'
    )
    parser.add_argument(
        '-j', '--jobs',
        type=int,
        default=4,
        metavar='N',
        help='Number of parallel hashing jobs (default: 4, use 1 to disable)'
    )

    args = parser.parse_args()

    # Handle both single directory and multiple directories
    roots = []
    for directory in args.directories:
        root = Path(directory).resolve()
        if not root.exists():
            print(f"Error: '{directory}' does not exist", file=sys.stderr)
            sys.exit(1)
        if not root.is_dir():
            print(f"Error: '{directory}' is not a directory", file=sys.stderr)
            sys.exit(1)
        roots.append(root)

    tui = DedupdirTUI(roots, algorithm=args.algorithm, jobs=args.jobs)

    # Scan with progress output before starting TUI
    if len(roots) == 1:
        print(f"Scanning {roots[0]}...")
    else:
        print(f"Scanning {len(roots)} directories...")
        for root in roots:
            print(f"  {root}")
    tui.scan(quiet=False)

    if not tui.sorted_dirs:
        print("No duplicate files found.")
        sys.exit(0)

    try:
        curses.wrapper(tui.run)
    except KeyboardInterrupt:
        pass


if __name__ == '__main__':
    main()
