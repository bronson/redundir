#!/usr/bin/env python3
"""
dedupdir-tui - Interactive TUI for exploring redundant directories

This provides a split-pane interface for browsing duplicate files:
- Top pane: List of directories with redundancy scores
- Bottom pane: Related directories and duplicate files for selected directory
"""

import curses
import sys
import os
import shutil
from pathlib import Path
from datetime import datetime

# Import core functions from dedupdir by loading it directly
def load_dedupdir():
    """Load dedupdir module from same directory or PATH."""
    import types

    # Try to find dedupdir in same directory as this script
    # Check multiple possible locations
    possible_paths = [
        Path(__file__).parent / "dedupdir",  # Same directory
        Path.cwd() / "dedupdir",  # Current working directory
        Path(sys.argv[0]).parent / "dedupdir",  # Script directory from argv
    ]

    for dedupdir_path in possible_paths:
        if dedupdir_path.exists() and dedupdir_path.is_file():
            try:
                # Read and execute the file directly since it has no .py extension
                with open(dedupdir_path, 'r') as f:
                    code = f.read()

                # Create a module to hold the executed code
                dedupdir = types.ModuleType('dedupdir')
                dedupdir.__file__ = str(dedupdir_path)
                sys.modules['dedupdir'] = dedupdir

                # Execute the code in the module's namespace
                exec(code, dedupdir.__dict__)

                # Verify required functions exist
                if hasattr(dedupdir, 'find_duplicates') and hasattr(dedupdir, 'calculate_redundancy_score'):
                    return dedupdir
            except Exception as e:
                print(f"Error loading {dedupdir_path}: {e}", file=sys.stderr)
                continue

    # Try regular import as fallback
    try:
        import dedupdir
        return dedupdir
    except ImportError:
        pass

    print("Error: Could not find dedupdir script", file=sys.stderr)
    print("Tried locations:", file=sys.stderr)
    for p in possible_paths:
        print(f"  {p} (exists: {p.exists()})", file=sys.stderr)
    sys.exit(1)

dedupdir_module = load_dedupdir()
find_duplicates = dedupdir_module.find_duplicates
calculate_redundancy_score = dedupdir_module.calculate_redundancy_score


class DedupdirTUI:
    def __init__(self, root_paths, algorithm='blake2b', jobs=4):
        # Normalize to list
        if isinstance(root_paths, (str, Path)):
            root_paths = [root_paths]
        self.root_paths = [Path(p).resolve() for p in root_paths]
        self.algorithm = algorithm
        self.jobs = jobs
        self.selected_idx = 0
        self.top_offset = 0
        self.bottom_offset = 0
        self.bottom_selected_idx = 0
        self.active_pane = 'top'  # 'top' or 'bottom'
        self.last_bottom_dir_idx = None  # Track which directory's details we're showing
        self.show_quit_message = False  # Show "press q to quit" message
        self.navigation_stack = []  # Stack of directory indices for back navigation
        self.selected_file = None  # Currently selected file for filtering top pane
        self.current_filtered_dirs = []  # Filtered directory list when a file is selected
        self.current_bottom_dir = None  # The directory whose files are shown in bottom pane (doesn't change when navigating within bottom pane)

        # Trash/deletion system (trash dirs are per-root, not in cwd)
        self.deletion_stack = []  # Stack for undo: [(original_path, trash_path, is_dir), ...]
        self.viewing_trash = False  # Whether we're in trash viewing mode
        self.trash_selected_idx = 0
        self.trash_offset = 0
        self.confirm_delete_item = None  # Item pending confirmation
        self.confirm_delete_type = None  # 'file' or 'directory'
        self.show_no_duplicates_message = False  # Show message when no duplicates found

        # Data will be populated by scan()
        self.sorted_dirs = []
        self.dir_stats = {}
        self.file_to_hash = {}
        self.hash_to_dirs = {}
        self.dir_all_files = {}
        self.total_duplicates = 0
        self.total_files = 0

    def scan(self, quiet=False):
        """Scan the directory tree for duplicates."""
        result = find_duplicates(
            self.root_paths,
            algorithm=self.algorithm,
            jobs=self.jobs,
            quiet=quiet
        )
        self.dir_stats, self.total_duplicates, self.total_files, \
            self.file_to_hash, self.hash_to_dirs, self.dir_all_files = result

        # Recalculate sorted_dirs with all directories
        self.recalculate_sorted_dirs()

    def recalculate_sorted_dirs(self):
        """Recalculate sorted_dirs including ALL directories, even those with 0% redundancy."""
        all_dirs_with_stats = []
        for dir_path, files in self.dir_all_files.items():
            if dir_path in self.dir_stats:
                # Directory has duplicates
                all_dirs_with_stats.append((dir_path, self.dir_stats[dir_path]))
            else:
                # Directory has no duplicates - add with 0/N stats
                total_files = len(files)
                all_dirs_with_stats.append((dir_path, (0, total_files)))

        # Sort directories by redundancy score
        self.sorted_dirs = sorted(
            all_dirs_with_stats,
            key=lambda x: (-calculate_redundancy_score(x[1][0], x[1][1]), str(x[0]))
        )

    def get_relative_path(self, path):
        """Convert absolute path to relative display path."""
        # Try each root path
        for root_path in self.root_paths:
            try:
                rel = path.relative_to(root_path)
                display = str(root_path.name / rel) if str(rel) != '.' else str(root_path.name)
                return display
            except ValueError:
                continue
        # If not relative to any root, use absolute path
        return str(path)

    def get_related_dirs(self, dir_path):
        """Get related directories and their hypothetical redundancy scores."""
        # Find all hashes in this directory
        dir_hashes = set()
        for fpath in self.dir_all_files.get(dir_path, []):
            if fpath in self.file_to_hash:
                dir_hashes.add(self.file_to_hash[fpath])

        # Find related directories
        related_dirs = set()
        for h in dir_hashes:
            for d in self.hash_to_dirs[h]:
                if d != dir_path:
                    related_dirs.add(d)

        # Calculate hypothetical redundancy
        related_info = []
        for related_dir in related_dirs:
            related_files = self.dir_all_files.get(related_dir, [])
            total_related = len(related_files)

            hypothetical_duplicates = 0
            for fpath in related_files:
                if fpath in self.file_to_hash:
                    h = self.file_to_hash[fpath]
                    other_dirs = self.hash_to_dirs[h] - {dir_path, related_dir}
                    if len(other_dirs) > 0:
                        hypothetical_duplicates += 1

            hyp_score = calculate_redundancy_score(hypothetical_duplicates, total_related)
            rel_display = self.get_relative_path(related_dir)
            related_info.append((hyp_score, hypothetical_duplicates, total_related, rel_display))

        # Sort by hypothetical redundancy score
        related_info.sort(key=lambda x: (-x[0], str(x[3])))
        return related_info

    def get_duplicate_files(self, dir_path):
        """Get list of duplicate files in the directory."""
        dup_files = []
        for fpath in self.dir_all_files.get(dir_path, []):
            if fpath in self.file_to_hash:
                dup_files.append(fpath.name)
        return sorted(dup_files)

    def get_all_files_with_counts(self, dir_path):
        """Get list of all files in directory with count of dirs containing each.

        Returns list of (filename, dir_count, file_path) tuples, sorted by
        dir_count descending (most duplicated first), then by filename.
        """
        file_info = []
        for fpath in self.dir_all_files.get(dir_path, []):
            fname = fpath.name
            # Count how many directories contain this file (by hash)
            if fpath in self.file_to_hash:
                fhash = self.file_to_hash[fpath]
                dir_count = len(self.hash_to_dirs.get(fhash, set()))
            else:
                # Unique file (not hashed, only in this directory)
                dir_count = 1
            file_info.append((fname, dir_count, fpath))

        # Sort by count descending, then by filename
        file_info.sort(key=lambda x: (-x[1], x[0]))
        return file_info

    def get_dirs_containing_file(self, file_path):
        """Get list of directories that contain the given file (by hash)."""
        if file_path not in self.file_to_hash:
            # Unique file, only in its own directory
            return [file_path.parent]

        fhash = self.file_to_hash[file_path]
        return list(self.hash_to_dirs.get(fhash, set()))

    def get_filename_in_dir(self, file_path, dir_path):
        """Get the actual filename for a file's hash in a specific directory.

        Since duplicate files can have different names in different directories,
        we need to look up the actual filename in each directory.
        """
        if file_path not in self.file_to_hash:
            # Unique file, just return its name
            return file_path.name

        fhash = self.file_to_hash[file_path]

        # Search through all files in the target directory for one with matching hash
        for fpath in self.dir_all_files.get(dir_path, []):
            if fpath in self.file_to_hash and self.file_to_hash[fpath] == fhash:
                return fpath.name

        # Fallback to original filename if not found
        return file_path.name

    def get_trash_dir_for_root(self, root_path):
        """Get the trash directory for a specific root."""
        return root_path / '~dedupdir-trash'

    def init_trash_dir_for_root(self, root_path):
        """Initialize trash directory for a specific root if it doesn't exist."""
        trash_dir = self.get_trash_dir_for_root(root_path)
        if not trash_dir.exists():
            trash_dir.mkdir(parents=True)
        return trash_dir

    def get_trash_items(self):
        """Scan trash directories in all roots and return list of items with metadata."""
        items = []

        for root_path in self.root_paths:
            trash_dir = self.get_trash_dir_for_root(root_path)
            if not trash_dir.exists():
                continue

            # Walk through all files/dirs in this trash dir
            for item in trash_dir.rglob('*'):
                if item.is_file() or (item.is_dir() and not any(item.iterdir())):
                    # It's a file or empty directory
                    rel_to_trash = item.relative_to(trash_dir)
                    original_path = root_path / rel_to_trash

                    items.append({
                        'original_path': str(original_path),
                        'trash_path': str(item),
                        'root_name': root_path.name,
                        'relative_path': str(rel_to_trash),
                        'type': 'file' if item.is_file() else 'directory',
                        'timestamp': datetime.fromtimestamp(item.stat().st_ctime).isoformat()
                    })

        # Sort by timestamp (newest first)
        items.sort(key=lambda x: x['timestamp'], reverse=True)
        return items

    def get_file_redundancy_count(self, file_path):
        """Get how many directories contain this file (based on hash)."""
        if file_path not in self.file_to_hash:
            return 0
        file_hash = self.file_to_hash[file_path]
        return len(self.hash_to_dirs.get(file_hash, set()))

    def is_dir_fully_redundant(self, dir_path):
        """Check if all files in directory exist in other directories."""
        files = self.dir_all_files.get(dir_path, [])
        if not files:
            return True

        num_roots = len(self.root_paths)
        for fpath in files:
            count = self.get_file_redundancy_count(fpath)
            if count < num_roots:
                return False
        return True

    def delete_item(self, item_path, item_type):
        """Move item to trash and update data structures."""
        item_path = Path(item_path)

        # Find which root this item belongs to
        root_for_item = None
        for root in self.root_paths:
            try:
                item_path.relative_to(root)
                root_for_item = root
                break
            except ValueError:
                continue

        if not root_for_item:
            return False

        # Initialize trash dir for this root
        trash_dir = self.init_trash_dir_for_root(root_for_item)

        # Create relative path from root
        rel_path = item_path.relative_to(root_for_item)

        # Create trash path (directly under trash dir, preserving structure)
        trash_path = trash_dir / rel_path
        trash_path.parent.mkdir(parents=True, exist_ok=True)

        # Move to trash
        try:
            shutil.move(str(item_path), str(trash_path))
        except Exception as e:
            return False

        # Add to undo stack (store simple tuple)
        self.deletion_stack.append((str(item_path), str(trash_path), item_type == 'directory'))

        # Update data structures
        if item_type == 'file':
            # If we're deleting the selected file, we need to update the selection
            # to point to another copy (if any exist) or clear it
            if self.selected_file == item_path:
                # Get the hash before we remove the file
                file_hash = self.file_to_hash.get(item_path)

                # Remove the file
                self.remove_file_from_data(item_path)

                # Try to find another file with the same hash
                if file_hash and file_hash in self.hash_to_dirs:
                    # Find any remaining file with this hash
                    for remaining_dir in self.hash_to_dirs[file_hash]:
                        for remaining_file in self.dir_all_files.get(remaining_dir, []):
                            if remaining_file in self.file_to_hash and self.file_to_hash[remaining_file] == file_hash:
                                # Found a replacement - update selected_file
                                self.selected_file = remaining_file
                                break
                        if self.selected_file != item_path:
                            break
                    else:
                        # No remaining copies found, clear the filter
                        self.selected_file = None
                else:
                    # No hash or no remaining directories, clear the filter
                    self.selected_file = None
            else:
                self.remove_file_from_data(item_path)
        else:  # directory
            self.remove_directory_from_data(item_path)

        # Recalculate sorted_dirs with all directories
        self.recalculate_sorted_dirs()

        return True

    def remove_file_from_data(self, file_path):
        """Remove a file from internal data structures."""
        if file_path not in self.file_to_hash:
            return

        file_hash = self.file_to_hash[file_path]
        parent_dir = file_path.parent

        # Get all directories that will be affected by this deletion
        # (all directories that have files with this hash)
        affected_dirs = set()
        if file_hash in self.hash_to_dirs:
            affected_dirs = self.hash_to_dirs[file_hash].copy()

        # Remove file from dir_all_files
        if parent_dir in self.dir_all_files:
            if file_path in self.dir_all_files[parent_dir]:
                self.dir_all_files[parent_dir].remove(file_path)

        # Remove the directory from hash_to_dirs
        if file_hash in self.hash_to_dirs:
            self.hash_to_dirs[file_hash].discard(parent_dir)

            # If no more directories have this hash, remove it
            if not self.hash_to_dirs[file_hash]:
                del self.hash_to_dirs[file_hash]

        # Remove from file_to_hash
        del self.file_to_hash[file_path]

        # Recalculate stats for ALL affected directories
        # (not just the one we deleted from, but all that had this hash)
        for dir_path in affected_dirs:
            if dir_path in self.dir_stats or dir_path in self.dir_all_files:
                # Recalculate duplicates for this directory
                new_dup = 0
                for f in self.dir_all_files.get(dir_path, []):
                    if f in self.file_to_hash:
                        fh = self.file_to_hash[f]
                        if len(self.hash_to_dirs.get(fh, set())) > 1:
                            new_dup += 1
                new_total = len(self.dir_all_files.get(dir_path, []))

                # Update or remove from dir_stats
                if new_total > 0 and new_dup > 0:
                    self.dir_stats[dir_path] = (new_dup, new_total)
                elif dir_path in self.dir_stats:
                    del self.dir_stats[dir_path]

    def remove_directory_from_data(self, dir_path):
        """Remove a directory and all its files from internal data structures."""
        # Get all files in this directory
        files_to_remove = self.dir_all_files.get(dir_path, [])[:]

        # Remove each file
        for file_path in files_to_remove:
            self.remove_file_from_data(file_path)

        # Remove directory from dir_all_files and dir_stats
        if dir_path in self.dir_all_files:
            del self.dir_all_files[dir_path]
        if dir_path in self.dir_stats:
            del self.dir_stats[dir_path]

    def undo_last_deletion(self):
        """Undo the most recent deletion."""
        if not self.deletion_stack:
            return False

        original_path_str, trash_path_str, is_dir = self.deletion_stack.pop()
        trash_path = Path(trash_path_str)
        original_path = Path(original_path_str)

        # Move back from trash
        try:
            original_path.parent.mkdir(parents=True, exist_ok=True)
            shutil.move(str(trash_path), str(original_path))
        except Exception as e:
            # Put it back on stack if restore failed
            self.deletion_stack.append((original_path_str, trash_path_str, is_dir))
            return False

        # Clean up empty directories in trash
        self.cleanup_empty_trash_dirs(trash_path.parent)

        # Rescan to update data structures
        self.scan(quiet=True)

        return True

    def restore_from_trash(self, trash_record):
        """Restore an item from trash by its metadata record."""
        trash_path = Path(trash_record['trash_path'])
        original_path = Path(trash_record['original_path'])

        if not trash_path.exists():
            return False

        try:
            original_path.parent.mkdir(parents=True, exist_ok=True)
            shutil.move(str(trash_path), str(original_path))
        except Exception as e:
            return False

        # Clean up empty directories in trash
        self.cleanup_empty_trash_dirs(trash_path.parent)

        # Remove from deletion stack if present
        self.deletion_stack = [d for d in self.deletion_stack if d[1] != trash_record['trash_path']]

        # Rescan to update data structures
        self.scan(quiet=True)

        return True

    def cleanup_empty_trash_dirs(self, start_dir):
        """Remove empty directories in trash, walking up from start_dir."""
        if not start_dir.exists():
            return

        # Walk up from start_dir, removing empty directories
        current = start_dir
        while current.exists() and current.is_dir():
            # Check if this is a trash directory (don't delete the trash root itself)
            is_trash_root = any(current == self.get_trash_dir_for_root(root) for root in self.root_paths)
            if is_trash_root:
                break

            # Check if directory is empty
            try:
                if not any(current.iterdir()):
                    # Directory is empty, remove it
                    current.rmdir()
                    # Move up to parent
                    current = current.parent
                else:
                    # Directory not empty, stop
                    break
            except (OSError, PermissionError):
                # Can't remove or access, stop
                break

    def draw_top_pane(self, win, height, width):
        """Draw the directory list in the top pane."""
        win.clear()

        # Border with highlight if active
        if self.active_pane == 'top':
            win.attron(curses.A_BOLD)
        win.border()
        if self.active_pane == 'top':
            win.attroff(curses.A_BOLD)

        # Determine which directories to show (filter if a file is selected)
        if self.selected_file:
            # Show only directories containing the selected file
            dirs_to_show = self.get_dirs_containing_file(self.selected_file)
            filtered_dirs = [(dp, stats) for dp, stats in self.sorted_dirs if dp in dirs_to_show]
            title = f" Directories containing {self.selected_file.name} ({len(filtered_dirs)}) "
        else:
            # Show all directories with redundancy
            filtered_dirs = self.sorted_dirs
            title = f" All Directories ({len(filtered_dirs)}) "

        # Store filtered dirs for navigation
        self.current_filtered_dirs = filtered_dirs

        title_attr = curses.A_BOLD | curses.A_REVERSE if self.active_pane == 'top' else curses.A_BOLD
        win.addstr(0, 2, title[:width-4], title_attr)

        # Show quit message if needed
        if self.show_quit_message:
            msg = " Press 'q' to quit "
            try:
                win.addstr(height - 1, width - len(msg) - 1, msg, curses.A_REVERSE | curses.A_BOLD)
            except curses.error:
                pass

        if not filtered_dirs:
            win.addstr(1, 1, "No directories to display")
            win.refresh()
            return

        # Calculate column width for count
        max_count_width = max(
            len(f"{dup}/{total}")
            for _, (dup, total) in filtered_dirs
        ) if filtered_dirs else 3

        # Display directories
        display_height = height - 2
        for i in range(display_height):
            idx = self.top_offset + i
            if idx >= len(filtered_dirs):
                break

            dir_path, (duplicates, total) = filtered_dirs[idx]
            score = calculate_redundancy_score(duplicates, total)
            rel_path = self.get_relative_path(dir_path)

            # Format line - include filename if filtering by file
            if self.selected_file:
                # Show directory/filename when filtering
                # Get the actual filename in this directory (may differ from selected file's name)
                actual_filename = self.get_filename_in_dir(self.selected_file, dir_path)

                # Get file-specific stats: how many directories contain this file
                file_hash = self.file_to_hash.get(self.selected_file)
                if file_hash:
                    num_dirs_with_file = len(self.hash_to_dirs.get(file_hash, set()))
                    # Calculate redundancy: redundant copies / total copies
                    # (if file appears in 3 dirs, 2 are redundant copies, 1 is "original")
                    redundant_copies = max(0, num_dirs_with_file - 1)
                    file_score = calculate_redundancy_score(redundant_copies, num_dirs_with_file)
                    percent_str = f"{file_score:7.2%}"
                    count_str = f"{redundant_copies}/{num_dirs_with_file}".rjust(max_count_width)
                else:
                    percent_str = "  0.00%"
                    count_str = "0/1".rjust(max_count_width)

                line = f"{percent_str}  {count_str}  {rel_path}/{actual_filename}"
            else:
                # Show directory stats when not filtering
                percent_str = f"{score:7.2%}"
                count_str = f"{duplicates}/{total}".rjust(max_count_width)
                line = f"{percent_str}  {count_str}  {rel_path}"

            # Truncate if too long
            max_len = width - 3
            if len(line) > max_len:
                line = line[:max_len-3] + "..."

            y = i + 1
            if idx == self.selected_idx:
                if self.active_pane == 'top':
                    attr = curses.A_REVERSE
                else:
                    # Inactive pane - show selection as bright/bold and underlined
                    attr = curses.A_BOLD | curses.A_UNDERLINE
            else:
                attr = curses.A_NORMAL
            win.addstr(y, 1, line.ljust(width - 2), attr)

        win.refresh()

    def draw_bottom_pane(self, win, height, width):
        """Draw the details for selected directory in the bottom pane."""
        win.clear()

        # Border with highlight if active
        if self.active_pane == 'bottom':
            win.attron(curses.A_BOLD)
        win.border()
        if self.active_pane == 'bottom':
            win.attroff(curses.A_BOLD)

        if not self.sorted_dirs:
            win.addstr(1, 1, "No duplicate files found.")
            win.refresh()
            return

        # Use current_bottom_dir if set, otherwise use selected directory from sorted_dirs
        if self.current_bottom_dir is not None:
            dir_path = self.current_bottom_dir
            # Find the stats for this directory
            duplicates, total = 0, 0
            for dp, (d, t) in self.sorted_dirs:
                if dp == dir_path:
                    duplicates, total = d, t
                    break
        else:
            dir_path, (duplicates, total) = self.sorted_dirs[self.selected_idx]
        rel_path = self.get_relative_path(dir_path)

        # Title
        title = f" Files in: {rel_path} "
        if len(title) > width - 4:
            title = " " + title[-(width-5):] + " "
        title_attr = curses.A_BOLD | curses.A_REVERSE if self.active_pane == 'bottom' else curses.A_BOLD
        win.addstr(0, 2, title, title_attr)

        # Get related directories and all files with counts
        related_dirs = self.get_related_dirs(dir_path)
        all_files = self.get_all_files_with_counts(dir_path)

        # Calculate max count width for alignment
        max_count_width = 3
        if related_dirs:
            max_count_width = max(max_count_width, max(
                len(f"{dup}/{total}")
                for _, dup, total, _ in related_dirs
            ))
        if all_files:
            max_file_count_width = max(len(str(count)) for _, count, _ in all_files)
            max_count_width = max(max_count_width, max_file_count_width)

        lines = []
        selectable_indices = []  # Track which line indices are selectable
        line_to_dir = {}  # Map line index to directory index for related directories
        line_to_file = {}  # Map line index to file path

        # Related directories section
        if related_dirs:
            lines.append(("Related directories (if this dir didn't exist):", curses.A_BOLD))
            for hyp_score, hyp_dup, hyp_total, rel_display in related_dirs:
                percent_str = f"{hyp_score:7.2%}"
                count_str = f"{hyp_dup}/{hyp_total}".rjust(max_count_width)
                line = f"  {percent_str}  {count_str}  {rel_display}"
                line_idx = len(lines)
                selectable_indices.append(line_idx)
                # Store the actual directory path for this line
                for idx, (dp, _) in enumerate(self.sorted_dirs):
                    if self.get_relative_path(dp) == rel_display:
                        line_to_dir[line_idx] = idx
                        break
                lines.append((line, curses.A_NORMAL))
            lines.append(("", curses.A_NORMAL))

        # Files section - show all files with directory count
        if all_files:
            lines.append((f"Files ({len(all_files)}):", curses.A_BOLD))
            for fname, dir_count, fpath in all_files:
                line_idx = len(lines)
                selectable_indices.append(line_idx)
                line_to_file[line_idx] = fpath
                # Format: count right-justified, then filename
                count_str = str(dir_count).rjust(max_count_width)
                line = f"  {count_str}  {fname}"
                lines.append((line, curses.A_NORMAL))

        # Display with scrolling
        display_height = height - 2
        for i in range(display_height):
            idx = self.bottom_offset + i
            if idx >= len(lines):
                break

            line, attr = lines[idx]
            y = i + 1

            # Truncate if too long
            max_len = width - 3
            if len(line) > max_len:
                line = line[:max_len-3] + "..."

            # Highlight selected line
            if idx == self.bottom_selected_idx:
                if self.active_pane == 'bottom':
                    attr = curses.A_REVERSE
                else:
                    # Inactive pane - show selection as bright/bold and underlined
                    attr = curses.A_BOLD | curses.A_UNDERLINE

            try:
                win.addstr(y, 1, line, attr)
            except curses.error:
                pass  # Ignore errors from writing to last line

        # Scrollbar indicator
        if len(lines) > display_height:
            indicator = f" [{self.bottom_offset + 1}-{min(self.bottom_offset + display_height, len(lines))}/{len(lines)}] "
            try:
                win.addstr(height - 1, width - len(indicator) - 1, indicator, curses.A_DIM)
            except curses.error:
                pass

        win.refresh()

        # Store lines count and selectable indices for navigation
        self.bottom_lines_count = len(lines)
        self.bottom_selectable_indices = selectable_indices
        self.bottom_line_to_dir = line_to_dir
        self.bottom_line_to_file = line_to_file

    def draw_trash_pane(self, win, height, width):
        """Draw the trash viewer in full screen."""
        win.clear()
        win.border()

        title = " Trash (~dedupdir-trash) - 'r' restore, 'v' view, 't' toggle back, Esc exit "
        win.addstr(0, 2, title[:width-4], curses.A_BOLD | curses.A_REVERSE)

        # Show "no duplicates" message if applicable
        if self.show_no_duplicates_message:
            msg = "No duplicate files found. You can restore files from trash below, or press 'q' to quit."
            try:
                win.addstr(2, 2, msg[:width-4], curses.A_BOLD)
            except curses.error:
                pass

        items = self.get_trash_items()

        if not items:
            msg_y = 4 if self.show_no_duplicates_message else 2
            win.addstr(msg_y, 2, "Trash is empty", curses.A_DIM)
            if self.show_no_duplicates_message:
                win.addstr(msg_y + 2, 2, "Press 'q' to quit.", curses.A_DIM)
            win.refresh()
            return

        # Display trash items
        start_y = 4 if self.show_no_duplicates_message else 1
        display_height = (height - start_y - 1) if self.show_no_duplicates_message else (height - 2)
        for i in range(display_height):
            idx = self.trash_offset + i
            if idx >= len(items):
                break

            item = items[idx]
            item_type = item.get('type', 'unknown')
            rel_path = item.get('relative_path', 'unknown')
            root_name = item.get('root_name', '')
            timestamp = item.get('timestamp', '')[:19]  # YYYY-MM-DDTHH:MM:SS

            # Format: [type] root/path with timestamp on right
            type_icon = "üìÑ" if item_type == "file" else "üìÅ"
            path_part = f"{type_icon} {root_name}/{rel_path}"

            # Format timestamp as "MMM DD HH:MM" (e.g., "Jan 20 14:23")
            # This is the ctime (inode change time), which approximates when the file was moved to trash
            if len(timestamp) >= 16:
                try:
                    dt = datetime.fromisoformat(timestamp)
                    time_part = dt.strftime("%b %d %H:%M")  # "Jan 20 14:23"
                except:
                    time_part = timestamp[5:16]  # Fallback: "MM-DD HH:MM"
            else:
                time_part = timestamp

            y = i + start_y
            attr = curses.A_REVERSE if idx == self.trash_selected_idx else curses.A_NORMAL

            try:
                # Calculate available space for path
                timestamp_width = len(time_part) + 2  # Add padding
                path_max_width = width - timestamp_width - 3

                # Truncate path if needed
                if len(path_part) > path_max_width:
                    path_part = path_part[:path_max_width-3] + "..."

                # Draw path on left
                win.addstr(y, 1, path_part, attr)

                # Draw timestamp on right
                time_x = width - timestamp_width - 1
                win.addstr(y, time_x, time_part, attr | curses.A_DIM)
            except curses.error:
                pass

        # Scrollbar indicator
        if len(items) > display_height:
            indicator = f" [{self.trash_offset + 1}-{min(self.trash_offset + display_height, len(items))}/{len(items)}] "
            try:
                win.addstr(height - 1, width - len(indicator) - 1, indicator, curses.A_DIM)
            except curses.error:
                pass

        win.refresh()

    def get_file_type(self, file_path):
        """Detect file type: 'text', 'image', 'binary'."""
        try:
            # Check by extension first
            suffix = file_path.suffix.lower()

            # Image extensions
            image_exts = {'.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.tif', '.webp', '.ico', '.svg'}
            if suffix in image_exts:
                return 'image'

            # Read first chunk to detect text vs binary
            with open(file_path, 'rb') as f:
                chunk = f.read(8192)
                if not chunk:
                    return 'text'  # Empty file

                # Check for null bytes (strong indicator of binary)
                if b'\x00' in chunk:
                    return 'binary'

                # Try to decode as UTF-8
                try:
                    chunk.decode('utf-8')
                    return 'text'
                except UnicodeDecodeError:
                    return 'binary'
        except (IOError, OSError):
            return 'binary'

    def get_file_content_for_viewing(self, file_path):
        """Get file content/info for viewing. Returns (metadata_lines, content_lines, file_type)."""
        file_type = self.get_file_type(file_path)
        metadata_lines = []
        content_lines = []

        try:
            file_size = file_path.stat().st_size
            size_mb = file_size / (1024 * 1024)

            # Add header with file info (metadata)
            metadata_lines.append(f"File: {file_path.name}")
            metadata_lines.append(f"Path: {file_path}")
            metadata_lines.append(f"Size: {file_size:,} bytes ({size_mb:.2f} MB)")
            metadata_lines.append(f"Type: {file_type.upper()}")

            if file_type == 'image':
                # Try to get EXIF data or image info
                content_lines.append("")

                # Try exiftool first
                try:
                    import subprocess
                    result = subprocess.run(['exiftool', str(file_path)],
                                          capture_output=True, text=True, timeout=5)
                    if result.returncode == 0:
                        content_lines.extend(result.stdout.splitlines())
                    else:
                        raise Exception("exiftool failed")
                except:
                    # Try identify (ImageMagick)
                    try:
                        result = subprocess.run(['identify', '-verbose', str(file_path)],
                                              capture_output=True, text=True, timeout=5)
                        if result.returncode == 0:
                            content_lines.extend(result.stdout.splitlines())
                        else:
                            raise Exception("identify failed")
                    except:
                        # Just show basic info
                        content_lines.append("(No image tools available - install exiftool or ImageMagick for details)")
                        content_lines.append("")
                        content_lines.append("This is an image file. Use an image viewer to see it.")

            elif file_type == 'text':

                # Limit reading to 10MB for text files
                max_bytes = 10 * 1024 * 1024

                with open(file_path, 'r', encoding='utf-8', errors='replace') as f:
                    bytes_read = 0
                    for line_num, line in enumerate(f, 1):
                        if bytes_read >= max_bytes:
                            content_lines.append("")
                            content_lines.append(f"... (file truncated at {max_bytes:,} bytes, showing first ~{line_num} lines)")
                            break
                        content_lines.append(line.rstrip('\n\r'))
                        bytes_read += len(line.encode('utf-8'))

            else:  # binary

                # Show hex dump of first 4KB
                max_bytes = 4096
                with open(file_path, 'rb') as f:
                    data = f.read(max_bytes)

                # Create hex dump
                for i in range(0, len(data), 16):
                    chunk = data[i:i+16]
                    hex_part = ' '.join(f'{b:02x}' for b in chunk)
                    ascii_part = ''.join(chr(b) if 32 <= b < 127 else '.' for b in chunk)
                    content_lines.append(f'{i:08x}  {hex_part:<48}  {ascii_part}')

                if file_size > max_bytes:
                    content_lines.append("")
                    content_lines.append(f"... (showing first {max_bytes:,} of {file_size:,} bytes)")

        except Exception as e:
            content_lines.append(f"Error reading file: {e}")

        return metadata_lines, content_lines, file_type

    def draw_file_viewer(self, stdscr, file_path, scroll_offset):
        """Draw file viewer as centered overlay window (75% width, 85% height)."""
        term_height, term_width = stdscr.getmaxyx()

        # Create centered overlay window (75% width, 85% height)
        height = int(term_height * 0.85)
        width = int(term_width * 0.75)
        y = (term_height - height) // 2
        x = (term_width - width) // 2

        # Create window for file viewer
        viewer_win = curses.newwin(height, width, y, x)
        viewer_win.clear()
        viewer_win.border()

        # Title
        title = f" Viewing: {file_path.name} (q/ESC to close, arrows/j/k to scroll) "
        viewer_win.addstr(0, 2, title[:width-4], curses.A_BOLD | curses.A_REVERSE)

        # Get content
        metadata_lines, content_lines, file_type = self.get_file_content_for_viewing(file_path)

        # Draw metadata section (fixed, not scrollable, in dim color)
        metadata_height = len(metadata_lines)
        for i, line in enumerate(metadata_lines):
            display_line = line[:width-3]
            try:
                viewer_win.addstr(1 + i, 1, display_line, curses.A_DIM)
            except curses.error:
                pass

        # Draw separator line
        separator_y = 1 + metadata_height
        try:
            viewer_win.addstr(separator_y, 1, "‚îÄ" * (width - 2))
        except curses.error:
            pass

        # Calculate visible area for content (below metadata and separator)
        content_start_y = separator_y + 1
        content_height = height - content_start_y - 1  # -1 for bottom border
        max_offset = max(0, len(content_lines) - content_height)
        scroll_offset = max(0, min(scroll_offset, max_offset))

        # Draw content lines (scrollable)
        for i in range(content_height):
            line_idx = scroll_offset + i
            if line_idx < len(content_lines):
                line = content_lines[line_idx]
                # Truncate line to fit width
                display_line = line[:width-3]
                try:
                    viewer_win.addstr(content_start_y + i, 1, display_line)
                except curses.error:
                    pass  # Ignore errors from writing to last position

        # Draw scrollbar indicator if needed
        if len(content_lines) > content_height:
            percent = (scroll_offset / max_offset * 100) if max_offset > 0 else 0
            status = f" {percent:.0f}% ({scroll_offset + 1}-{min(scroll_offset + content_height, len(content_lines))} of {len(content_lines)}) "
            try:
                viewer_win.addstr(height - 1, width - len(status) - 2, status, curses.A_REVERSE)
            except curses.error:
                pass

        viewer_win.refresh()
        return scroll_offset, len(content_lines)

    def get_help_text(self, mode):
        """Get context-sensitive help text for the given mode."""
        if mode == 'main':
            return """Main View - Exploring Duplicate Files

Navigation:
  ‚Üë/‚Üì or j/k        Navigate items
  ‚Üê/‚Üí or h/l        Switch panes / navigate filtered view
  Tab               Switch between top and bottom pane
  Enter             Drill down into filtered view
  PgUp/PgDn         Page up/down
  Ctrl-B/Ctrl-F     Page up/down
  Home/End or </>   Jump to first/last item

Actions:
  v                 View selected file
  d                 Delete selected file or directory
  u                 Undo last deletion
  t                 Toggle trash viewer
  q                 Quit

The top pane shows directories by redundancy.
The bottom pane shows files in selected directory.
Selecting a file filters the top pane to show only
directories containing that file."""

        elif mode == 'trash':
            return """Trash Viewer

Navigation:
  ‚Üë/‚Üì or j/k        Navigate trash items
  PgUp/PgDn         Page up/down
  Ctrl-B/Ctrl-F     Page up/down
  Home/End or </>   Jump to first/last item

Actions:
  v                 View selected file
  r                 Restore selected item
  t or Esc          Return to main view
  q                 Quit

Files are moved to ~dedupdir-trash/ in each root
directory. They remain there until you manually
delete the trash directories."""

        elif mode == 'viewer':
            return """File Viewer

Navigation:
  ‚Üë/‚Üì or j/k        Scroll up/down one line
  PgUp/PgDn         Scroll up/down one page
  Ctrl-B/Ctrl-F     Page up/down (alternative)
  Home/End or </>   Jump to start/end

Display:
  - Metadata shown at top (file, path, size, type)
  - Horizontal line separates metadata from content
  - Text files: shows content (up to 10MB)
  - Images: shows EXIF data if available
  - Binary files: shows hex dump (first 4KB)

Actions:
  q or Esc          Close viewer and return"""

        elif mode == 'confirm':
            return """Deletion Confirmation

You are about to delete an item that is not fully
redundant. If you delete it, you may lose data.

Actions:
  y or Y            Confirm deletion
  n or N            Cancel
  Esc               Cancel
  q                 Quit application"""

        else:
            return "Help not available for this mode."

    def draw_help_popup(self, stdscr, mode, scroll_offset=0):
        """Draw help popup as centered overlay with scrolling support."""
        term_height, term_width = stdscr.getmaxyx()

        # Help window size (80% width, 80% height)
        height = int(term_height * 0.80)
        width = int(term_width * 0.80)
        width = min(width, 80)  # Max 80 chars wide
        y = (term_height - height) // 2
        x = (term_width - width) // 2

        # Create help window
        help_win = curses.newwin(height, width, y, x)
        help_win.clear()
        help_win.border()

        # Title
        title = " Help - h/‚Üê/Esc to close, ‚Üë‚Üì/j/k to scroll "
        help_win.addstr(0, (width - len(title)) // 2, title[:width-2], curses.A_BOLD | curses.A_REVERSE)

        # Get help text and display
        help_text = self.get_help_text(mode)
        lines = help_text.split('\n')

        # Calculate visible area and scroll bounds
        visible_height = height - 2
        max_offset = max(0, len(lines) - visible_height)
        scroll_offset = max(0, min(scroll_offset, max_offset))

        # Draw help lines with scrolling
        for i in range(visible_height):
            line_idx = scroll_offset + i
            if line_idx < len(lines):
                display_line = lines[line_idx][:width-3]
                try:
                    help_win.addstr(1 + i, 1, display_line)
                except curses.error:
                    pass

        # Draw scroll indicator if needed
        if len(lines) > visible_height:
            percent = (scroll_offset / max_offset * 100) if max_offset > 0 else 0
            status = f" {percent:.0f}% ({scroll_offset + 1}-{min(scroll_offset + visible_height, len(lines))} of {len(lines)}) "
            try:
                help_win.addstr(height - 1, width - len(status) - 2, status, curses.A_REVERSE)
            except curses.error:
                pass

        help_win.refresh()
        return scroll_offset, len(lines)

    def show_help_viewer(self, stdscr, mode):
        """Show scrollable help viewer and handle navigation until exit."""
        scroll_offset = 0
        while True:
            scroll_offset, total_lines = self.draw_help_popup(stdscr, mode, scroll_offset)
            help_key = stdscr.getch()

            if help_key in (ord('h'), ord('H'), curses.KEY_LEFT, 27):  # h, H, ‚Üê, or ESC
                break
            elif help_key == curses.KEY_RESIZE:
                stdscr.clear()
                stdscr.refresh()
                continue
            elif help_key in (curses.KEY_UP, ord('k')):
                scroll_offset = max(0, scroll_offset - 1)
            elif help_key in (curses.KEY_DOWN, ord('j')):
                help_height = int(stdscr.getmaxyx()[0] * 0.80)
                visible_height = help_height - 2
                max_offset = max(0, total_lines - visible_height)
                scroll_offset = min(max_offset, scroll_offset + 1)
            elif help_key in (curses.KEY_PPAGE, 2):  # Page Up or Ctrl-B
                help_height = int(stdscr.getmaxyx()[0] * 0.80)
                visible_height = help_height - 2
                scroll_offset = max(0, scroll_offset - visible_height)
            elif help_key in (curses.KEY_NPAGE, 6):  # Page Down or Ctrl-F
                help_height = int(stdscr.getmaxyx()[0] * 0.80)
                visible_height = help_height - 2
                max_offset = max(0, total_lines - visible_height)
                scroll_offset = min(max_offset, scroll_offset + visible_height)
            elif help_key in (curses.KEY_HOME, ord('<')):
                scroll_offset = 0
            elif help_key in (curses.KEY_END, ord('>')):
                help_height = int(stdscr.getmaxyx()[0] * 0.80)
                visible_height = help_height - 2
                scroll_offset = max(0, total_lines - visible_height)

    def get_hint_text(self, mode):
        """Get hint bar text for the given mode."""
        if mode == 'main':
            return "‚Üë‚Üì:Navigate  v:View  d:Delete  t:Trash"
        elif mode == 'trash':
            return "‚Üë‚Üì:Navigate  v:View  r:Restore  t:Back"
        elif mode == 'viewer':
            return "‚Üë‚Üì:Scroll  PgUp/PgDn:Page  q:Close"
        elif mode == 'confirm':
            return "y:Yes  n:No  Esc:Cancel"
        else:
            return ""

    def draw_hint_bar(self, stdscr, mode):
        """Draw hint bar at bottom of screen."""
        height, width = stdscr.getmaxyx()

        hint_text = self.get_hint_text(mode)
        help_text = "[?] Help"

        # Calculate positions
        available_width = width - len(help_text) - 3  # -3 for spacing
        if len(hint_text) > available_width:
            hint_text = hint_text[:available_width-3] + "..."

        # Draw hint bar
        try:
            # Clear the line first with normal color, then draw text
            stdscr.addstr(height - 1, 0, " " * (width - 1))
            # Draw hints on left
            stdscr.addstr(height - 1, 1, hint_text, curses.A_DIM)
            # Draw help on right
            stdscr.addstr(height - 1, width - len(help_text) - 1, help_text, curses.A_DIM)
            stdscr.refresh()  # Explicitly refresh to ensure hint bar is visible
        except curses.error:
            pass  # Ignore errors at edge of screen

    def draw_confirmation_dialog(self, stdscr, message):
        """Draw a confirmation dialog in the center of the screen."""
        height, width = stdscr.getmaxyx()

        # Dialog dimensions
        dialog_height = 9
        dialog_width = min(70, width - 4)
        dialog_y = (height - dialog_height) // 2
        dialog_x = (width - dialog_width) // 2

        # Create dialog window
        dialog = curses.newwin(dialog_height, dialog_width, dialog_y, dialog_x)
        dialog.clear()
        dialog.box()

        # Split message by newlines first, then word wrap each line
        lines = []
        for msg_line in message.split('\n'):
            if not msg_line:
                lines.append("")
            else:
                words = msg_line.split()
                current_line = ""
                for word in words:
                    if len(current_line) + len(word) + 1 <= dialog_width - 4:
                        current_line += (" " if current_line else "") + word
                    else:
                        lines.append(current_line)
                        current_line = word
                if current_line:
                    lines.append(current_line)

        # Draw message lines
        for i, line in enumerate(lines[:5]):  # Max 5 lines
            dialog.addstr(1 + i, 2, line, curses.A_BOLD)

        # Draw prompt
        prompt = "Delete anyway? (y/n)"
        dialog.addstr(dialog_height - 2, (dialog_width - len(prompt)) // 2, prompt, curses.A_REVERSE)

        dialog.refresh()
        return dialog

    def run(self, stdscr):
        """Main TUI loop."""
        curses.curs_set(0)  # Hide cursor
        stdscr.clear()

        # Set escape delay to 25ms to make ESC key responsive
        # (curses waits to see if ESC is part of an escape sequence)
        if hasattr(curses, 'set_escdelay'):
            curses.set_escdelay(25)

        # Initialize colors if available
        if curses.has_colors():
            curses.init_pair(1, curses.COLOR_WHITE, curses.COLOR_BLUE)

        # Show loading message
        height, width = stdscr.getmaxyx()
        stdscr.addstr(height // 2, width // 2 - 10, "Starting TUI...", curses.A_BOLD)
        stdscr.refresh()

        if not self.sorted_dirs:
            # No duplicates found - show trash viewer instead of exiting
            # This allows user to restore files if they deleted too much
            self.viewing_trash = True
            self.trash_selected_idx = 0
            self.trash_offset = 0
            self.show_no_duplicates_message = True
        else:
            self.show_no_duplicates_message = False

        # Main loop
        while True:
            height, width = stdscr.getmaxyx()

            # Draw based on current mode
            # Reserve last line for hint bar
            usable_height = height - 1

            if self.viewing_trash:
                # Trash viewer mode - draw main screen first, then overlay
                top_height = max(5, usable_height * 2 // 5)
                bottom_height = usable_height - top_height
                top_win = curses.newwin(top_height, width, 0, 0)
                bottom_win = curses.newwin(bottom_height, width, top_height, 0)
                self.draw_top_pane(top_win, top_height, width)
                self.draw_bottom_pane(bottom_win, bottom_height, width)

                # Draw trash viewer as centered overlay (85% width, 92% height)
                trash_height = int(usable_height * 0.92)
                trash_width = int(width * 0.85)
                trash_y = (usable_height - trash_height) // 2
                trash_x = (width - trash_width) // 2
                trash_win = curses.newwin(trash_height, trash_width, trash_y, trash_x)
                self.draw_trash_pane(trash_win, trash_height, trash_width)

                # Draw hint bar
                self.draw_hint_bar(stdscr, 'trash')
            elif self.confirm_delete_item is not None:
                # Confirmation dialog mode - draw normal panes + dialog
                top_height = max(5, usable_height * 2 // 5)
                bottom_height = usable_height - top_height
                top_win = curses.newwin(top_height, width, 0, 0)
                bottom_win = curses.newwin(bottom_height, width, top_height, 0)
                self.draw_top_pane(top_win, top_height, width)
                self.draw_bottom_pane(bottom_win, bottom_height, width)
                # Draw confirmation dialog on top
                rel_path = self.get_relative_path(self.confirm_delete_item)
                message = f"There is only one copy of\n\n{rel_path}\n\nIf you delete it, you will lose data."
                self.draw_confirmation_dialog(stdscr, message)

                # Draw hint bar
                self.draw_hint_bar(stdscr, 'confirm')
            else:
                # Normal mode - split screen
                top_height = max(5, usable_height * 2 // 5)
                bottom_height = usable_height - top_height
                top_win = curses.newwin(top_height, width, 0, 0)
                bottom_win = curses.newwin(bottom_height, width, top_height, 0)
                self.draw_top_pane(top_win, top_height, width)
                self.draw_bottom_pane(bottom_win, bottom_height, width)

                # Draw hint bar
                self.draw_hint_bar(stdscr, 'main')

            # Handle input
            key = stdscr.getch()

            # Handle terminal resize
            if key == curses.KEY_RESIZE:
                stdscr.clear()
                stdscr.refresh()
                continue

            # Handle confirmation dialog first (takes priority)
            if self.confirm_delete_item is not None:
                if key in (ord('q'), ord('Q')):  # Q key - quit immediately
                    break
                elif key in (ord('y'), ord('Y')):
                    # Confirmed - proceed with deletion
                    item_path, item_type = self.confirm_delete_item, self.confirm_delete_type
                    self.delete_item(item_path, item_type)
                    self.confirm_delete_item = None
                    self.confirm_delete_type = None
                    continue
                elif key in (ord('n'), ord('N'), 27):  # n, N, or ESC
                    # Cancelled
                    self.confirm_delete_item = None
                    self.confirm_delete_type = None
                    continue
                elif key == ord('?'):
                    # Show help
                    self.show_help_viewer(stdscr, 'confirm')
                    continue
                else:
                    # Ignore other keys in confirmation mode
                    continue

            # Handle trash viewing mode (takes priority)
            if self.viewing_trash:
                if key in (ord('q'), ord('Q')):  # Q key - quit immediately
                    break
                elif key in (ord('t'), ord('T')):  # t to toggle back to main view
                    # If no duplicates found, don't allow toggle back (nothing to show)
                    if not self.show_no_duplicates_message:
                        self.viewing_trash = False
                    continue
                elif key == 27:  # ESC to exit trash view
                    # If no duplicates found, don't allow toggle back (nothing to show)
                    if not self.show_no_duplicates_message:
                        self.viewing_trash = False
                    continue
                elif key == ord('?'):
                    # Show help
                    self.show_help_viewer(stdscr, 'trash')
                    continue
                elif key in (curses.KEY_UP, ord('k')):
                    items = self.get_trash_items()
                    if self.trash_selected_idx > 0:
                        self.trash_selected_idx -= 1
                        if self.trash_selected_idx < self.trash_offset:
                            self.trash_offset = self.trash_selected_idx
                elif key in (curses.KEY_DOWN, ord('j')):
                    items = self.get_trash_items()
                    if self.trash_selected_idx < len(items) - 1:
                        self.trash_selected_idx += 1
                        if self.trash_selected_idx >= self.trash_offset + (height - 2):
                            self.trash_offset = self.trash_selected_idx - (height - 2) + 1
                elif key in (ord('r'), ord('R')):  # Restore selected item
                    items = self.get_trash_items()
                    if items and self.trash_selected_idx < len(items):
                        if self.restore_from_trash(items[self.trash_selected_idx]):
                            # Adjust selection if needed
                            items = self.get_trash_items()
                            if self.trash_selected_idx >= len(items) and len(items) > 0:
                                self.trash_selected_idx = len(items) - 1

                            # Check if we now have duplicates after restoration
                            if self.show_no_duplicates_message and self.sorted_dirs:
                                # Duplicates found again! Exit trash mode and show main view
                                self.show_no_duplicates_message = False
                                self.viewing_trash = False
                                continue
                elif key in (curses.KEY_PPAGE, 2):  # Page Up or Ctrl-B
                    items = self.get_trash_items()
                    display_height = height - 2
                    self.trash_selected_idx = max(0, self.trash_selected_idx - display_height)
                    self.trash_offset = max(0, self.trash_offset - display_height)
                elif key in (curses.KEY_NPAGE, 6):  # Page Down or Ctrl-F
                    items = self.get_trash_items()
                    display_height = height - 2
                    self.trash_selected_idx = min(len(items) - 1, self.trash_selected_idx + display_height)
                    if self.trash_selected_idx >= self.trash_offset + display_height:
                        self.trash_offset = self.trash_selected_idx - display_height + 1
                elif key in (curses.KEY_HOME, ord('<')):
                    self.trash_selected_idx = 0
                    self.trash_offset = 0
                elif key in (curses.KEY_END, ord('>')):
                    items = self.get_trash_items()
                    self.trash_selected_idx = max(0, len(items) - 1)
                    self.trash_offset = max(0, len(items) - (height - 2))
                elif key in (ord('v'), ord('V')):  # View file in trash
                    items = self.get_trash_items()
                    if items and self.trash_selected_idx < len(items):
                        item_dict = items[self.trash_selected_idx]
                        trash_path = Path(item_dict['trash_path'])
                        if trash_path.is_file():
                            # Enter file viewing mode
                            scroll_offset = 0
                            while True:
                                # Get current terminal dimensions
                                height, width = stdscr.getmaxyx()

                                # Redraw trash viewer first (as background)
                                top_height = max(5, height * 2 // 5)
                                bottom_height = height - top_height
                                top_win = curses.newwin(top_height, width, 0, 0)
                                bottom_win = curses.newwin(bottom_height, width, top_height, 0)
                                self.draw_top_pane(top_win, top_height, width)
                                self.draw_bottom_pane(bottom_win, bottom_height, width)
                                trash_height = int(height * 0.92)
                                trash_width = int(width * 0.85)
                                trash_y = (height - trash_height) // 2
                                trash_x = (width - trash_width) // 2
                                trash_win = curses.newwin(trash_height, trash_width, trash_y, trash_x)
                                self.draw_trash_pane(trash_win, trash_height, trash_width)

                                # Draw file viewer overlay on top
                                scroll_offset, total_lines = self.draw_file_viewer(stdscr, trash_path, scroll_offset)

                                # Draw hint bar
                                self.draw_hint_bar(stdscr, 'viewer')

                                # Handle viewer input
                                view_key = stdscr.getch()

                                if view_key in (ord('q'), ord('Q'), 27):  # q, Q, or ESC
                                    break
                                elif view_key == curses.KEY_RESIZE:
                                    stdscr.clear()
                                    stdscr.refresh()
                                    continue
                                elif view_key == ord('?'):
                                    # Show help
                                    self.show_help_viewer(stdscr, 'viewer')
                                    continue
                                elif view_key in (curses.KEY_UP, ord('k')):
                                    scroll_offset = max(0, scroll_offset - 1)
                                elif view_key in (curses.KEY_DOWN, ord('j')):
                                    viewer_height = int(height * 0.85)
                                    visible_height = viewer_height - 2
                                    max_offset = max(0, total_lines - visible_height)
                                    scroll_offset = min(max_offset, scroll_offset + 1)
                                elif view_key in (curses.KEY_PPAGE, curses.KEY_NPAGE, 2, 6):  # PgUp/PgDn or Ctrl-B/Ctrl-F
                                    viewer_height = int(height * 0.85)
                                    visible_height = viewer_height - 2
                                    if view_key in (curses.KEY_PPAGE, 2):  # Page Up or Ctrl-B
                                        scroll_offset = max(0, scroll_offset - visible_height)
                                    else:  # Page Down or Ctrl-F
                                        max_offset = max(0, total_lines - visible_height)
                                        scroll_offset = min(max_offset, scroll_offset + visible_height)
                                elif view_key in (curses.KEY_HOME, ord('<')):
                                    scroll_offset = 0
                                elif view_key in (curses.KEY_END, ord('>')):
                                    viewer_height = int(height * 0.85)
                                    visible_height = viewer_height - 2
                                    scroll_offset = max(0, total_lines - visible_height)
                # Continue to redraw at top of loop
                continue

            # Tab to switch panes
            if key == ord('\t'):  # Tab key
                if self.active_pane == 'top':
                    self.active_pane = 'bottom'
                    # Set current_bottom_dir to the selected directory
                    dirs_to_use = self.current_filtered_dirs if self.current_filtered_dirs else self.sorted_dirs
                    if self.selected_idx < len(dirs_to_use):
                        new_dir = dirs_to_use[self.selected_idx][0]
                    else:
                        new_dir = self.sorted_dirs[0][0] if self.sorted_dirs else None
                    # If switching to a different directory, reset selection
                    if self.current_bottom_dir != new_dir:
                        self.current_bottom_dir = new_dir
                        if hasattr(self, 'bottom_selectable_indices') and self.bottom_selectable_indices:
                            self.bottom_selected_idx = self.bottom_selectable_indices[0]
                        else:
                            self.bottom_selected_idx = 0
                        self.bottom_offset = 0
                        self.selected_file = None  # Clear file filter when switching directories
                    # Otherwise preserve the current selection (already set)
                else:
                    self.active_pane = 'top'
                continue

            # Return key or Right arrow - context-sensitive drill down
            if key in (ord('\n'), ord('\r'), curses.KEY_ENTER, curses.KEY_RIGHT, ord('l')):
                if self.active_pane == 'top':
                    # Switch to bottom pane
                    self.active_pane = 'bottom'
                    # Set current_bottom_dir to the selected directory
                    dirs_to_use = self.current_filtered_dirs if self.current_filtered_dirs else self.sorted_dirs
                    if self.selected_idx < len(dirs_to_use):
                        new_dir = dirs_to_use[self.selected_idx][0]
                    else:
                        new_dir = self.sorted_dirs[0][0] if self.sorted_dirs else None
                    # If switching to a different directory, reset selection
                    if self.current_bottom_dir != new_dir:
                        self.current_bottom_dir = new_dir
                        if hasattr(self, 'bottom_selectable_indices') and self.bottom_selectable_indices:
                            self.bottom_selected_idx = self.bottom_selectable_indices[0]
                        else:
                            self.bottom_selected_idx = 0
                        self.bottom_offset = 0
                        self.selected_file = None  # Clear file filter when switching directories
                    self.show_quit_message = False
                else:  # bottom pane
                    # Check if current selection is a file - switch to top pane with filter
                    if hasattr(self, 'bottom_line_to_file') and self.bottom_selected_idx in self.bottom_line_to_file:
                        # File is already filtering top pane, just switch to top pane
                        self.selected_file = self.bottom_line_to_file[self.bottom_selected_idx]
                        # Push current state to navigation stack for back navigation
                        self.navigation_stack.append({
                            'type': 'file_filter',
                            'selected_idx': self.selected_idx,
                            'selected_file': None,  # Will restore to no filter
                            'bottom_selected_idx': self.bottom_selected_idx,
                            'current_bottom_dir': self.current_bottom_dir,
                            'active_pane': 'bottom'
                        })
                        self.active_pane = 'top'
                        self.selected_idx = 0
                        self.top_offset = 0
                    # Check if current selection is a related directory
                    elif hasattr(self, 'bottom_line_to_dir') and self.bottom_selected_idx in self.bottom_line_to_dir:
                        # Jump to that directory in top pane
                        target_idx = self.bottom_line_to_dir[self.bottom_selected_idx]
                        # Push current directory to navigation stack
                        self.navigation_stack.append({
                            'type': 'directory',
                            'selected_idx': self.selected_idx,
                            'selected_file': self.selected_file,
                            'current_bottom_dir': self.current_bottom_dir,
                            'bottom_selected_idx': self.bottom_selected_idx,
                            'active_pane': 'bottom'
                        })
                        # Jump to target directory
                        self.selected_idx = target_idx
                        self.active_pane = 'top'
                        self.current_bottom_dir = None  # Will be set when entering bottom pane
                        self.selected_file = None
                        # Adjust scroll to show selected directory
                        if self.selected_idx < self.top_offset:
                            self.top_offset = self.selected_idx
                        elif self.selected_idx >= self.top_offset + (top_height - 2):
                            self.top_offset = self.selected_idx - (top_height - 2) + 1
                continue

            # Escape key or Left arrow - context-sensitive behavior
            if key in (27, curses.KEY_LEFT, ord('h')):  # ESC or Left arrow
                if self.active_pane == 'bottom':
                    # Switch to top pane and clear filter (show all directories)
                    self.active_pane = 'top'
                    self.selected_file = None
                    self.navigation_stack = []  # Clear navigation stack
                    self.show_quit_message = False
                else:  # top pane
                    # Left arrow in top pane - pop from navigation stack if available
                    if key in (curses.KEY_LEFT, ord('h')) and self.navigation_stack:
                        nav_state = self.navigation_stack.pop()
                        if isinstance(nav_state, dict):
                            self.selected_idx = nav_state.get('selected_idx', 0)
                            self.selected_file = nav_state.get('selected_file', None)
                            self.current_bottom_dir = nav_state.get('current_bottom_dir', None)
                            # Restore active pane and bottom selection if available
                            if 'active_pane' in nav_state:
                                self.active_pane = nav_state['active_pane']
                            if 'bottom_selected_idx' in nav_state:
                                self.bottom_selected_idx = nav_state.get('bottom_selected_idx', 0)
                        else:
                            # Legacy: just an index
                            self.selected_idx = nav_state
                            self.selected_file = None
                            self.current_bottom_dir = None
                        # Adjust scroll to show selected directory
                        if self.selected_idx < self.top_offset:
                            self.top_offset = self.selected_idx
                        elif self.selected_idx >= self.top_offset + (top_height - 2):
                            self.top_offset = self.selected_idx - (top_height - 2) + 1
                    elif self.selected_file:
                        # Clear file filter, stay on current directory
                        self.selected_file = None
                        # Don't reset selected_idx - keep showing the same directory
                    elif key == 27:
                        # ESC shows quit message
                        self.show_quit_message = True
                continue

            # Q key - quit immediately
            if key in (ord('q'), ord('Q')):
                break
            # T key - toggle trash view
            elif key in (ord('t'), ord('T')):
                if not self.viewing_trash:
                    self.viewing_trash = True
                    self.trash_selected_idx = 0
                    self.trash_offset = 0
                continue
            # U key - undo last deletion
            elif key in (ord('u'), ord('U')):
                self.undo_last_deletion()
                continue
            # ? key - show help
            elif key == ord('?'):
                # Show help
                self.show_help_viewer(stdscr, 'main')
                continue
            # V key - view file
            elif key in (ord('v'), ord('V')):
                # Only allow viewing files from bottom pane
                if self.active_pane == 'bottom':
                    if hasattr(self, 'bottom_line_to_file') and self.bottom_selected_idx in self.bottom_line_to_file:
                        file_path = self.bottom_line_to_file[self.bottom_selected_idx]
                        if file_path.is_file():
                            # Enter file viewing mode
                            scroll_offset = 0
                            while True:
                                # Get current terminal dimensions
                                height, width = stdscr.getmaxyx()

                                # Redraw main screen first (as background)
                                top_height = max(5, height * 2 // 5)
                                bottom_height = height - top_height
                                top_win = curses.newwin(top_height, width, 0, 0)
                                bottom_win = curses.newwin(bottom_height, width, top_height, 0)
                                self.draw_top_pane(top_win, top_height, width)
                                self.draw_bottom_pane(bottom_win, bottom_height, width)

                                # Draw file viewer overlay on top
                                scroll_offset, total_lines = self.draw_file_viewer(stdscr, file_path, scroll_offset)

                                # Draw hint bar
                                self.draw_hint_bar(stdscr, 'viewer')

                                # Handle viewer input
                                view_key = stdscr.getch()

                                if view_key in (ord('q'), ord('Q'), 27):  # q, Q, or ESC
                                    break
                                elif view_key == curses.KEY_RESIZE:
                                    stdscr.clear()
                                    stdscr.refresh()
                                    continue
                                elif view_key == ord('?'):
                                    # Show help
                                    self.show_help_viewer(stdscr, 'viewer')
                                    continue
                                elif view_key in (curses.KEY_UP, ord('k')):
                                    scroll_offset = max(0, scroll_offset - 1)
                                elif view_key in (curses.KEY_DOWN, ord('j')):
                                    viewer_height = int(height * 0.85)
                                    visible_height = viewer_height - 2
                                    max_offset = max(0, total_lines - visible_height)
                                    scroll_offset = min(max_offset, scroll_offset + 1)
                                elif view_key in (curses.KEY_PPAGE, curses.KEY_NPAGE, 2, 6):  # PgUp/PgDn or Ctrl-B/Ctrl-F
                                    viewer_height = int(height * 0.85)
                                    visible_height = viewer_height - 2
                                    if view_key in (curses.KEY_PPAGE, 2):  # Page Up or Ctrl-B
                                        scroll_offset = max(0, scroll_offset - visible_height)
                                    else:  # Page Down or Ctrl-F
                                        max_offset = max(0, total_lines - visible_height)
                                        scroll_offset = min(max_offset, scroll_offset + visible_height)
                                elif view_key in (curses.KEY_HOME, ord('<')):
                                    scroll_offset = 0
                                elif view_key in (curses.KEY_END, ord('>')):
                                    viewer_height = int(height * 0.85)
                                    visible_height = viewer_height - 2
                                    scroll_offset = max(0, total_lines - visible_height)
                continue
            # D key - delete item
            elif key == ord('d'):
                item_to_delete = None
                delete_type = None

                if self.active_pane == 'top':
                    # Delete selected directory
                    dirs_to_use = self.current_filtered_dirs if self.current_filtered_dirs else self.sorted_dirs
                    if self.selected_idx < len(dirs_to_use):
                        dir_path = dirs_to_use[self.selected_idx][0]
                        item_to_delete = dir_path
                        delete_type = 'directory'
                elif self.active_pane == 'bottom':
                    # Delete selected file
                    if hasattr(self, 'bottom_line_to_file') and self.bottom_selected_idx in self.bottom_line_to_file:
                        file_path = self.bottom_line_to_file[self.bottom_selected_idx]
                        item_to_delete = file_path
                        delete_type = 'file'

                if item_to_delete:
                    # Check if fully redundant
                    needs_confirmation = False
                    num_roots = len(self.root_paths)

                    if delete_type == 'file':
                        count = self.get_file_redundancy_count(item_to_delete)
                        if count < num_roots:
                            needs_confirmation = True
                    else:  # directory
                        if not self.is_dir_fully_redundant(item_to_delete):
                            needs_confirmation = True

                    if needs_confirmation:
                        # Set confirmation state - will be drawn at top of loop
                        self.confirm_delete_item = item_to_delete
                        self.confirm_delete_type = delete_type
                    else:
                        # Delete immediately
                        was_in_bottom_pane = (self.active_pane == 'bottom' and delete_type == 'file')
                        self.delete_item(item_to_delete, delete_type)

                        # After deletion, clear navigation stack so left arrow works correctly
                        self.navigation_stack = []

                        # If we deleted a file from bottom pane, the filter needs updating
                        # The bottom_line_to_file mapping is stale, so just clear the filter
                        # It will be rebuilt on next draw with the new file list
                        if was_in_bottom_pane:
                            self.selected_file = None
                continue
            elif key in (curses.KEY_UP, ord('k')):
                self.show_quit_message = False
                if self.active_pane == 'top':
                    if self.selected_idx > 0:
                        self.selected_idx -= 1
                        # Mark that bottom pane needs refresh for new directory
                        self.last_bottom_dir_idx = None
                        # Adjust top offset if needed
                        if self.selected_idx < self.top_offset:
                            self.top_offset = self.selected_idx
                else:  # bottom pane
                    if hasattr(self, 'bottom_selectable_indices') and self.bottom_selectable_indices:
                        current_pos = self.bottom_selectable_indices.index(self.bottom_selected_idx) if self.bottom_selected_idx in self.bottom_selectable_indices else 0
                        if current_pos > 0:
                            self.bottom_selected_idx = self.bottom_selectable_indices[current_pos - 1]
                            # Adjust bottom offset if needed
                            if self.bottom_selected_idx < self.bottom_offset:
                                self.bottom_offset = self.bottom_selected_idx
                            # Update file filter based on new selection
                            if hasattr(self, 'bottom_line_to_file') and self.bottom_selected_idx in self.bottom_line_to_file:
                                self.selected_file = self.bottom_line_to_file[self.bottom_selected_idx]
                            else:
                                self.selected_file = None
            elif key in (curses.KEY_DOWN, ord('j')):
                self.show_quit_message = False
                if self.active_pane == 'top':
                    # Use filtered dirs for bounds checking
                    max_idx = len(self.current_filtered_dirs) - 1 if hasattr(self, 'current_filtered_dirs') and self.current_filtered_dirs else len(self.sorted_dirs) - 1
                    if self.selected_idx < max_idx:
                        self.selected_idx += 1
                        # Mark that bottom pane needs refresh for new directory
                        self.last_bottom_dir_idx = None
                        # Adjust top offset if needed
                        display_height = top_height - 2
                        if self.selected_idx >= self.top_offset + display_height:
                            self.top_offset = self.selected_idx - display_height + 1
                else:  # bottom pane
                    if hasattr(self, 'bottom_selectable_indices') and self.bottom_selectable_indices:
                        current_pos = self.bottom_selectable_indices.index(self.bottom_selected_idx) if self.bottom_selected_idx in self.bottom_selectable_indices else -1
                        if current_pos < len(self.bottom_selectable_indices) - 1:
                            self.bottom_selected_idx = self.bottom_selectable_indices[current_pos + 1]
                            # Adjust bottom offset if needed
                            display_height = bottom_height - 2
                            if self.bottom_selected_idx >= self.bottom_offset + display_height:
                                self.bottom_offset = self.bottom_selected_idx - display_height + 1
                            # Update file filter based on new selection
                            if hasattr(self, 'bottom_line_to_file') and self.bottom_selected_idx in self.bottom_line_to_file:
                                self.selected_file = self.bottom_line_to_file[self.bottom_selected_idx]
                            else:
                                self.selected_file = None
            elif key in (curses.KEY_PPAGE, 2):  # Page Up or Ctrl-B
                self.show_quit_message = False
                if self.active_pane == 'top':
                    self.selected_idx = max(0, self.selected_idx - (top_height - 2))
                    self.top_offset = max(0, self.top_offset - (top_height - 2))
                    self.last_bottom_dir_idx = None
                else:
                    if hasattr(self, 'bottom_selectable_indices') and self.bottom_selectable_indices:
                        current_pos = self.bottom_selectable_indices.index(self.bottom_selected_idx) if self.bottom_selected_idx in self.bottom_selectable_indices else 0
                        new_pos = max(0, current_pos - (bottom_height - 2))
                        self.bottom_selected_idx = self.bottom_selectable_indices[new_pos]
                        self.bottom_offset = max(0, self.bottom_selected_idx - (bottom_height - 2))
            elif key in (curses.KEY_NPAGE, 6):  # Page Down or Ctrl-F
                self.show_quit_message = False
                if self.active_pane == 'top':
                    display_height = top_height - 2
                    max_idx = len(self.current_filtered_dirs) - 1 if hasattr(self, 'current_filtered_dirs') and self.current_filtered_dirs else len(self.sorted_dirs) - 1
                    self.selected_idx = min(max_idx, self.selected_idx + display_height)
                    total_dirs = len(self.current_filtered_dirs) if hasattr(self, 'current_filtered_dirs') and self.current_filtered_dirs else len(self.sorted_dirs)
                    self.top_offset = min(max(0, total_dirs - display_height),
                                         self.top_offset + display_height)
                    self.last_bottom_dir_idx = None
                else:
                    if hasattr(self, 'bottom_selectable_indices') and self.bottom_selectable_indices:
                        current_pos = self.bottom_selectable_indices.index(self.bottom_selected_idx) if self.bottom_selected_idx in self.bottom_selectable_indices else 0
                        new_pos = min(len(self.bottom_selectable_indices) - 1, current_pos + (bottom_height - 2))
                        self.bottom_selected_idx = self.bottom_selectable_indices[new_pos]
                        display_height = bottom_height - 2
                        if self.bottom_selected_idx >= self.bottom_offset + display_height:
                            self.bottom_offset = self.bottom_selected_idx - display_height + 1

            elif key in (curses.KEY_HOME, ord('<')):  # Home or <
                self.show_quit_message = False
                if self.active_pane == 'top':
                    self.selected_idx = 0
                    self.top_offset = 0
                    self.last_bottom_dir_idx = None
                else:
                    if hasattr(self, 'bottom_selectable_indices') and self.bottom_selectable_indices:
                        self.bottom_selected_idx = self.bottom_selectable_indices[0]
                    else:
                        self.bottom_selected_idx = 0
                    self.bottom_offset = 0
            elif key in (curses.KEY_END, ord('>')):  # End or >
                self.show_quit_message = False
                if self.active_pane == 'top':
                    total_dirs = len(self.current_filtered_dirs) if hasattr(self, 'current_filtered_dirs') and self.current_filtered_dirs else len(self.sorted_dirs)
                    self.selected_idx = total_dirs - 1
                    display_height = top_height - 2
                    self.top_offset = max(0, total_dirs - display_height)
                    self.last_bottom_dir_idx = None
                else:
                    if hasattr(self, 'bottom_selectable_indices') and self.bottom_selectable_indices:
                        self.bottom_selected_idx = self.bottom_selectable_indices[-1]
                        display_height = bottom_height - 2
                        self.bottom_offset = max(0, self.bottom_selected_idx - display_height + 1)
            elif key == curses.KEY_RESIZE:
                stdscr.clear()


def main():
    import argparse

    parser = argparse.ArgumentParser(
        prog='dedupdir-tui',
        description='Interactive TUI for exploring redundant directories.'
    )
    parser.add_argument(
        'directories',
        nargs='*',
        default=['.'],
        metavar='directory',
        help='Directories to scan (default: current directory)'
    )
    parser.add_argument(
        '-a', '--algorithm',
        default='blake2b',
        choices=['md5', 'sha1', 'sha256', 'blake2b', 'blake2s'],
        help='Hash algorithm to use (default: blake2b)'
    )
    parser.add_argument(
        '-j', '--jobs',
        type=int,
        default=4,
        metavar='N',
        help='Number of parallel hashing jobs (default: 4, use 1 to disable)'
    )

    args = parser.parse_args()

    # Handle both single directory and multiple directories
    roots = []
    for directory in args.directories:
        root = Path(directory).resolve()
        if not root.exists():
            print(f"Error: '{directory}' does not exist", file=sys.stderr)
            sys.exit(1)
        if not root.is_dir():
            print(f"Error: '{directory}' is not a directory", file=sys.stderr)
            sys.exit(1)
        roots.append(root)

    tui = DedupdirTUI(roots, algorithm=args.algorithm, jobs=args.jobs)

    # Scan with progress output before starting TUI
    if len(roots) == 1:
        print(f"Scanning {roots[0]}...")
    else:
        print(f"Scanning {len(roots)} directories...")
        for root in roots:
            print(f"  {root}")
    tui.scan(quiet=False)

    if not tui.sorted_dirs:
        print("No duplicate files found.")
        sys.exit(0)

    try:
        curses.wrapper(tui.run)
    except KeyboardInterrupt:
        pass


if __name__ == '__main__':
    main()
